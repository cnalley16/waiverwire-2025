// @ts-nocheck
// NFL Data transformation script - TypeScript checking disabled for utility script
/**
 * NFL Data Transformer
 * Converts nfl_data_py output to match our Supabase database schema
 * 
 * This script:
 * 1. Reads JSON files generated by nfl-data-pipeline.py
 * 2. Transforms the data to match our database schema
 * 3. Validates data integrity
 * 4. Outputs database-ready JSON files
 * 5. Optionally updates Supabase directly
 */

import fs from 'fs'
import path from 'path'
import { createClient } from '@supabase/supabase-js'
import { v4 as uuidv4 } from 'uuid'
import { config } from 'dotenv'
import type { NFLPlayer, PlayerProjection, PlayerGameStats } from '@/src/types/database'

// Load environment variables from .env.local
config({ path: '.env.local' })

// Configure paths
const NFL_DATA_DIR = 'data/nfl'
const OUTPUT_DIR = 'data/transformed'

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true })
}

// Team abbreviation mapping (nfl_data_py format to our format)
const TEAM_MAPPING: Record<string, string> = {
  'ARI': 'ARI', 'ATL': 'ATL', 'BAL': 'BAL', 'BUF': 'BUF', 'CAR': 'CAR',
  'CHI': 'CHI', 'CIN': 'CIN', 'CLE': 'CLE', 'DAL': 'DAL', 'DEN': 'DEN',
  'DET': 'DET', 'GB': 'GB', 'HOU': 'HOU', 'IND': 'IND', 'JAX': 'JAX',
  'KC': 'KC', 'LV': 'LV', 'LAC': 'LAC', 'LAR': 'LAR', 'MIA': 'MIA',
  'MIN': 'MIN', 'NE': 'NE', 'NO': 'NO', 'NYG': 'NYG', 'NYJ': 'NYJ',
  'PHI': 'PHI', 'PIT': 'PIT', 'SF': 'SF', 'SEA': 'SEA', 'TB': 'TB',
  'TEN': 'TEN', 'WAS': 'WAS'
}

// Position mapping
const POSITION_MAPPING: Record<string, string> = {
  'QB': 'QB', 'RB': 'RB', 'WR': 'WR', 'TE': 'TE', 'K': 'K',
  'DEF': 'DEF', 'DL': 'DL', 'LB': 'LB', 'DB': 'DB'
}

interface NFLDataRoster {
  player_id: string
  player_name: string
  jersey_number: number
  position: string
  team: string
  height: string
  weight: number
  years_exp: number
  college: string
  status: string
}

interface NFLDataStats {
  player_id: string
  player_name: string
  position: string
  team: string
  week: number
  season: number
  completions?: number
  attempts?: number
  passing_yards?: number
  passing_tds?: number
  interceptions?: number
  carries?: number
  rushing_yards?: number
  rushing_tds?: number
  targets?: number
  receptions?: number
  receiving_yards?: number
  receiving_tds?: number
  [key: string]: any
}

class NFLDataTransformer {
  private supabase: any
  private playerIdMap: Map<string, string> = new Map()

  constructor() {
    // Initialize Supabase client 
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY

    let supabase: any = null
    if (supabaseUrl && supabaseKey) {
      supabase = createClient(supabaseUrl, supabaseKey)
      console.log('‚úÖ Supabase client initialized')
    } else {
      console.log('‚ö†Ô∏è Supabase credentials not found - will only generate files')
    }

    this.supabase = supabase
  }

  /**
   * Parse height string (e.g., "6-1") to inches
   */
  private parseHeight(heightStr: string): number | null {
    if (!heightStr) return null
    const parts = heightStr.split('-')
    if (parts.length !== 2) return null
    const feet = parseInt(parts[0])
    const inches = parseInt(parts[1])
    return (feet * 12) + inches
  }

  /**
   * Transform roster data to our player schema
   */
  transformRosterData(rosterFile: string): NFLPlayer[] {
    console.log(`üìã Transforming roster data from ${rosterFile}...`)

    if (!fs.existsSync(rosterFile)) {
      console.log(`‚ùå Roster file not found: ${rosterFile}`)
      return []
    }

    const rawData: NFLDataRoster[] = JSON.parse(fs.readFileSync(rosterFile, 'utf-8'))
    const transformedPlayers: NFLPlayer[] = []

    for (const player of rawData) {
      try {
        // Generate or reuse UUID for this player
        const playerId = this.playerIdMap.get(player.player_id) || uuidv4()
        this.playerIdMap.set(player.player_id, playerId)

        // Parse name
        const nameParts = player.player_name.split(' ')
        const firstName = nameParts[0] || ''
        const lastName = nameParts.slice(1).join(' ') || ''

        const transformedPlayer: NFLPlayer = {
          id: playerId,
          player_external_id: player.player_id,
          first_name: firstName,
          last_name: lastName,
          display_name: player.player_name,
          position: (POSITION_MAPPING[player.position] || player.position) as any,
          nfl_team: (TEAM_MAPPING[player.team] || player.team) as any,
          jersey_number: player.jersey_number || null,
          height_inches: this.parseHeight(player.height),
          weight_pounds: player.weight || null,
          age: null, // Will need to calculate from birth date if available
          years_pro: player.years_exp || 0,
          college: player.college || null,
          
          // Status and availability
          is_active: player.status === 'ACT',
          injury_status: 'HEALTHY', // Default, will update from injury data
          
          // Fantasy relevant defaults
          adp_half_ppr: null,
          adp_full_ppr: null,
          bye_week: null,
          
          // Performance metrics (to be updated from stats)
          fantasy_points_half_ppr: 0,
          fantasy_points_full_ppr: 0,
          targets_per_game: null,
          snap_percentage: null,
          red_zone_targets: null,
          air_yards_share: null,
          
          // Timestamps
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }

        transformedPlayers.push(transformedPlayer)
      } catch (error) {
        console.error(`‚ùå Error transforming player ${player.player_name}:`, error)
      }
    }

    console.log(`‚úÖ Transformed ${transformedPlayers.length} players`)
    return transformedPlayers
  }

  /**
   * Transform weekly stats to our game stats schema
   */
  transformStatsData(statsFile: string): PlayerGameStats[] {
    console.log(`üìä Transforming stats data from ${statsFile}...`)

    if (!fs.existsSync(statsFile)) {
      console.log(`‚ùå Stats file not found: ${statsFile}`)
      return []
    }

    const rawData: NFLDataStats[] = JSON.parse(fs.readFileSync(statsFile, 'utf-8'))
    const transformedStats: PlayerGameStats[] = []

    for (const stat of rawData) {
      try {
        // Find or create player ID
        const playerId = this.playerIdMap.get(stat.player_id) || uuidv4()
        this.playerIdMap.set(stat.player_id, playerId)

        const transformedStat: PlayerGameStats = {
          id: uuidv4(),
          player_id: playerId,
          week: stat.week,
          season: stat.season,
          
          // We'll need opponent info from schedule data
          opponent: 'TBD' as any, // TODO: Get from schedule
          is_home_game: false, // TODO: Get from schedule
          
          // Passing stats
          passing_attempts: stat.attempts || 0,
          passing_completions: stat.completions || 0,
          passing_yards: stat.passing_yards || 0,
          passing_tds: stat.passing_tds || 0,
          passing_ints: stat.interceptions || 0,
          
          // Rushing stats
          rushing_attempts: stat.carries || 0,
          rushing_yards: stat.rushing_yards || 0,
          rushing_tds: stat.rushing_tds || 0,
          
          // Receiving stats
          targets: stat.targets || 0,
          receptions: stat.receptions || 0,
          receiving_yards: stat.receiving_yards || 0,
          receiving_tds: stat.receiving_tds || 0,
          
          // Fantasy points calculation
          fantasy_points_standard: this.calculateFantasyPoints(stat, 'standard'),
          fantasy_points_half_ppr: this.calculateFantasyPoints(stat, 'half_ppr'),
          fantasy_points_ppr: this.calculateFantasyPoints(stat, 'full_ppr'),
          
          // Timestamps
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }

        transformedStats.push(transformedStat)
      } catch (error) {
        console.error(`‚ùå Error transforming stats for ${stat.player_name}:`, error)
      }
    }

    console.log(`‚úÖ Transformed ${transformedStats.length} stat records`)
    return transformedStats
  }

  /**
   * Calculate fantasy points based on scoring system
   */
  private calculateFantasyPoints(stats: NFLDataStats, scoringType: 'standard' | 'half_ppr' | 'full_ppr'): number {
    let points = 0

    // Passing points
    points += (stats.passing_yards || 0) * 0.04 // 1 point per 25 yards
    points += (stats.passing_tds || 0) * 4
    points -= (stats.interceptions || 0) * 2

    // Rushing points
    points += (stats.rushing_yards || 0) * 0.1 // 1 point per 10 yards
    points += (stats.rushing_tds || 0) * 6

    // Receiving points
    points += (stats.receiving_yards || 0) * 0.1 // 1 point per 10 yards
    points += (stats.receiving_tds || 0) * 6

    // PPR points
    const receptions = stats.receptions || 0
    if (scoringType === 'full_ppr') {
      points += receptions * 1
    } else if (scoringType === 'half_ppr') {
      points += receptions * 0.5
    }

    return Math.round(points * 100) / 100 // Round to 2 decimal places
  }

  /**
   * Generate projection data based on historical performance
   */
  generateProjections(players: NFLPlayer[], stats: PlayerGameStats[]): PlayerProjection[] {
    console.log(`üéØ Generating projections for ${players.length} players...`)

    const projections: PlayerProjection[] = []

    for (const player of players) {
      try {
        // Get player's historical stats
        const playerStats = stats.filter(s => s.player_id === player.id)
        
        if (playerStats.length === 0) continue

        // Calculate averages and projections
        const avgFantasyPoints = playerStats.reduce((sum, s) => sum + (s.fantasy_points_half_ppr || 0), 0) / playerStats.length
        const stdDev = this.calculateStandardDeviation(playerStats.map(s => s.fantasy_points_half_ppr || 0))

        const projection: PlayerProjection = {
          id: uuidv4(),
          player_id: player.id,
          week: 0, // Season-long projection
          season: 2024,
          projection_type: 'SEASON',
          
          // Basic projections
          projected_fantasy_points: avgFantasyPoints * 17, // Season projection
          expected_points: avgFantasyPoints,
          standard_deviation: stdDev,
          ceiling: avgFantasyPoints + (stdDev * 2),
          floor: Math.max(0, avgFantasyPoints - (stdDev * 2)),
          
          // Position-specific projections (simplified for now)
          projected_passing_yards: player.position === 'QB' ? this.getAvgStat(playerStats, 'passing_yards') * 17 : null,
          projected_passing_tds: player.position === 'QB' ? this.getAvgStat(playerStats, 'passing_tds') * 17 : null,
          projected_rushing_yards: ['QB', 'RB'].includes(player.position) ? this.getAvgStat(playerStats, 'rushing_yards') * 17 : null,
          projected_rushing_tds: ['QB', 'RB'].includes(player.position) ? this.getAvgStat(playerStats, 'rushing_tds') * 17 : null,
          projected_receiving_yards: ['WR', 'TE', 'RB'].includes(player.position) ? this.getAvgStat(playerStats, 'receiving_yards') * 17 : null,
          projected_receptions: ['WR', 'TE', 'RB'].includes(player.position) ? this.getAvgStat(playerStats, 'receptions') * 17 : null,
          projected_receiving_tds: ['WR', 'TE', 'RB'].includes(player.position) ? this.getAvgStat(playerStats, 'receiving_tds') * 17 : null,
          
          // Risk assessment (simplified)
          confidence_score: Math.min(100, playerStats.length * 10), // More games = higher confidence
          projection_tier: this.determineProjectionTier(avgFantasyPoints, player.position),
          
          // Timestamps
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }

        projections.push(projection)
      } catch (error) {
        console.error(`‚ùå Error generating projection for ${player.display_name}:`, error)
      }
    }

    console.log(`‚úÖ Generated ${projections.length} projections`)
    return projections
  }

  private getAvgStat(stats: PlayerGameStats[], statName: keyof PlayerGameStats): number {
    const values = stats.map(s => (s[statName] as number) || 0).filter(v => v > 0)
    return values.length > 0 ? values.reduce((sum, v) => sum + v, 0) / values.length : 0
  }

  private calculateStandardDeviation(values: number[]): number {
    const mean = values.reduce((sum, v) => sum + v, 0) / values.length
    const squaredDiffs = values.map(v => Math.pow(v - mean, 2))
    const avgSquaredDiff = squaredDiffs.reduce((sum, d) => sum + d, 0) / squaredDiffs.length
    return Math.sqrt(avgSquaredDiff)
  }

  private determineProjectionTier(avgPoints: number, position: string): 'ELITE' | 'HIGH' | 'MEDIUM' | 'LOW' | 'VOLATILE' {
    const thresholds = {
      QB: { elite: 20, high: 16, medium: 12 },
      RB: { elite: 15, high: 12, medium: 8 },
      WR: { elite: 13, high: 10, medium: 7 },
      TE: { elite: 10, high: 8, medium: 5 }
    }

    const posThresholds = thresholds[position as keyof typeof thresholds] || thresholds.WR

    if (avgPoints >= posThresholds.elite) return 'ELITE'
    if (avgPoints >= posThresholds.high) return 'HIGH'
    if (avgPoints >= posThresholds.medium) return 'MEDIUM'
    return 'LOW'
  }

  /**
   * Run the complete transformation pipeline
   */
  async runTransformation() {
    console.log('üöÄ Starting NFL data transformation...\n')

    try {
      // Transform roster data
      const rosterFile = path.join(NFL_DATA_DIR, 'rosters_2024.json')
      const players = this.transformRosterData(rosterFile)

      // Save transformed players
      const playersOutputFile = path.join(OUTPUT_DIR, 'players.json')
      fs.writeFileSync(playersOutputFile, JSON.stringify(players, null, 2))
      console.log(`üíæ Saved ${players.length} players to ${playersOutputFile}`)

      // Transform stats data
      const statsFiles = [
        'passing_stats_2024.json',
        'rushing_stats_2024.json',
        'receiving_stats_2024.json'
      ]

      let allStats: PlayerGameStats[] = []
      for (const statsFile of statsFiles) {
        const fullPath = path.join(NFL_DATA_DIR, statsFile)
        const stats = this.transformStatsData(fullPath)
        allStats = allStats.concat(stats)
      }

      // Save transformed stats
      const statsOutputFile = path.join(OUTPUT_DIR, 'game_stats.json')
      fs.writeFileSync(statsOutputFile, JSON.stringify(allStats, null, 2))
      console.log(`üíæ Saved ${allStats.length} stat records to ${statsOutputFile}`)

      // Generate projections
      const projections = this.generateProjections(players, allStats)

      // Save projections
      const projectionsOutputFile = path.join(OUTPUT_DIR, 'projections.json')
      fs.writeFileSync(projectionsOutputFile, JSON.stringify(projections, null, 2))
      console.log(`üíæ Saved ${projections.length} projections to ${projectionsOutputFile}`)

      // Update Supabase if available
      if (this.supabase) {
        console.log('\nüîÑ Updating Supabase database...')
        await this.updateSupabase('nfl_players', players)
        await this.updateSupabase('player_game_stats', allStats.slice(0, 1000)) // Limit for demo
        await this.updateSupabase('player_projections', projections)
      }

      console.log('\nüéâ Transformation completed successfully!')
      console.log(`üìÅ Transformed data saved to: ${OUTPUT_DIR}`)

    } catch (error) {
      console.error('‚ùå Transformation failed:', error)
      process.exit(1)
    }
  }

  /**
   * Update Supabase with transformed data
   */
  private async updateSupabase(tableName: string, data: any[]) {
    try {
      console.log(`üîÑ Updating ${tableName} with ${data.length} records...`)

      // Clear existing data first (optional)
      // await this.supabase.from(tableName).delete().neq('id', '')

      // Insert in batches
      const batchSize = 100
      for (let i = 0; i < data.length; i += batchSize) {
        const batch = data.slice(i, i + batchSize)
        const { error } = await this.supabase
          .from(tableName)
          .upsert(batch, { onConflict: 'id' })

        if (error) {
          console.error(`‚ùå Error updating batch ${i / batchSize + 1}:`, error)
        } else {
          console.log(`‚úÖ Updated batch ${i / batchSize + 1}/${Math.ceil(data.length / batchSize)}`)
        }
      }

      console.log(`üéâ Successfully updated ${tableName}`)
    } catch (error) {
      console.error(`‚ùå Error updating ${tableName}:`, error)
    }
  }
}

// Main execution
async function main() {
  console.log('üèà NFL Data Transformer\n')

  const transformer = new NFLDataTransformer()
  await transformer.runTransformation()
}

// Run if called directly
if (require.main === module) {
  main().catch(console.error)
}

export { NFLDataTransformer } 
