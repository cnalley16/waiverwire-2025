
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model League
 * 
 */
export type League = $Result.DefaultSelection<Prisma.$LeaguePayload>
/**
 * Model LeagueSettings
 * 
 */
export type LeagueSettings = $Result.DefaultSelection<Prisma.$LeagueSettingsPayload>
/**
 * Model ScoringSettings
 * 
 */
export type ScoringSettings = $Result.DefaultSelection<Prisma.$ScoringSettingsPayload>
/**
 * Model RosterSettings
 * 
 */
export type RosterSettings = $Result.DefaultSelection<Prisma.$RosterSettingsPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Player
 * 
 */
export type Player = $Result.DefaultSelection<Prisma.$PlayerPayload>
/**
 * Model Roster
 * 
 */
export type Roster = $Result.DefaultSelection<Prisma.$RosterPayload>
/**
 * Model Draft
 * 
 */
export type Draft = $Result.DefaultSelection<Prisma.$DraftPayload>
/**
 * Model DraftPick
 * 
 */
export type DraftPick = $Result.DefaultSelection<Prisma.$DraftPickPayload>
/**
 * Model Game
 * 
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model TradeOffer
 * 
 */
export type TradeOffer = $Result.DefaultSelection<Prisma.$TradeOfferPayload>
/**
 * Model TradeOfferPlayer
 * 
 */
export type TradeOfferPlayer = $Result.DefaultSelection<Prisma.$TradeOfferPlayerPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model GameStats
 * 
 */
export type GameStats = $Result.DefaultSelection<Prisma.$GameStatsPayload>
/**
 * Model WeeklyProjection
 * 
 */
export type WeeklyProjection = $Result.DefaultSelection<Prisma.$WeeklyProjectionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const DraftType: {
  LIVE_ONLINE: 'LIVE_ONLINE',
  LIVE_OFFLINE: 'LIVE_OFFLINE',
  AUTOMATED: 'AUTOMATED'
};

export type DraftType = (typeof DraftType)[keyof typeof DraftType]


export const ScoringType: {
  BASIC: 'BASIC',
  PERFORMANCE: 'PERFORMANCE'
};

export type ScoringType = (typeof ScoringType)[keyof typeof ScoringType]


export const TradeReviewType: {
  NONE: 'NONE',
  COMMISSIONER: 'COMMISSIONER',
  LEAGUE_VOTE: 'LEAGUE_VOTE'
};

export type TradeReviewType = (typeof TradeReviewType)[keyof typeof TradeReviewType]


export const WaiverType: {
  REVERSE_STANDINGS: 'REVERSE_STANDINGS',
  ROLLING: 'ROLLING',
  FAAB: 'FAAB'
};

export type WaiverType = (typeof WaiverType)[keyof typeof WaiverType]


export const Position: {
  QB: 'QB',
  RB: 'RB',
  WR: 'WR',
  TE: 'TE',
  K: 'K',
  DEF: 'DEF',
  DL: 'DL',
  LB: 'LB',
  DB: 'DB'
};

export type Position = (typeof Position)[keyof typeof Position]


export const RosterPosition: {
  QB: 'QB',
  RB: 'RB',
  WR: 'WR',
  TE: 'TE',
  FLEX: 'FLEX',
  K: 'K',
  DEF: 'DEF',
  BENCH: 'BENCH',
  IR: 'IR'
};

export type RosterPosition = (typeof RosterPosition)[keyof typeof RosterPosition]


export const InjuryStatus: {
  HEALTHY: 'HEALTHY',
  QUESTIONABLE: 'QUESTIONABLE',
  DOUBTFUL: 'DOUBTFUL',
  OUT: 'OUT',
  IR: 'IR',
  PUP: 'PUP'
};

export type InjuryStatus = (typeof InjuryStatus)[keyof typeof InjuryStatus]


export const TransactionType: {
  ADD: 'ADD',
  DROP: 'DROP',
  TRADE: 'TRADE',
  WAIVER_CLAIM: 'WAIVER_CLAIM'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const TradeStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED'
};

export type TradeStatus = (typeof TradeStatus)[keyof typeof TradeStatus]


export const MessageType: {
  PERSONAL: 'PERSONAL',
  LEAGUE_WIDE: 'LEAGUE_WIDE',
  SYSTEM: 'SYSTEM',
  TRADE_OFFER: 'TRADE_OFFER',
  COMMISSIONER: 'COMMISSIONER'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]

}

export type DraftType = $Enums.DraftType

export const DraftType: typeof $Enums.DraftType

export type ScoringType = $Enums.ScoringType

export const ScoringType: typeof $Enums.ScoringType

export type TradeReviewType = $Enums.TradeReviewType

export const TradeReviewType: typeof $Enums.TradeReviewType

export type WaiverType = $Enums.WaiverType

export const WaiverType: typeof $Enums.WaiverType

export type Position = $Enums.Position

export const Position: typeof $Enums.Position

export type RosterPosition = $Enums.RosterPosition

export const RosterPosition: typeof $Enums.RosterPosition

export type InjuryStatus = $Enums.InjuryStatus

export const InjuryStatus: typeof $Enums.InjuryStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type TradeStatus = $Enums.TradeStatus

export const TradeStatus: typeof $Enums.TradeStatus

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.league`: Exposes CRUD operations for the **League** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leagues
    * const leagues = await prisma.league.findMany()
    * ```
    */
  get league(): Prisma.LeagueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leagueSettings`: Exposes CRUD operations for the **LeagueSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeagueSettings
    * const leagueSettings = await prisma.leagueSettings.findMany()
    * ```
    */
  get leagueSettings(): Prisma.LeagueSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scoringSettings`: Exposes CRUD operations for the **ScoringSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScoringSettings
    * const scoringSettings = await prisma.scoringSettings.findMany()
    * ```
    */
  get scoringSettings(): Prisma.ScoringSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rosterSettings`: Exposes CRUD operations for the **RosterSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RosterSettings
    * const rosterSettings = await prisma.rosterSettings.findMany()
    * ```
    */
  get rosterSettings(): Prisma.RosterSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.player`: Exposes CRUD operations for the **Player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players
    * const players = await prisma.player.findMany()
    * ```
    */
  get player(): Prisma.PlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roster`: Exposes CRUD operations for the **Roster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rosters
    * const rosters = await prisma.roster.findMany()
    * ```
    */
  get roster(): Prisma.RosterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.draft`: Exposes CRUD operations for the **Draft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drafts
    * const drafts = await prisma.draft.findMany()
    * ```
    */
  get draft(): Prisma.DraftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.draftPick`: Exposes CRUD operations for the **DraftPick** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DraftPicks
    * const draftPicks = await prisma.draftPick.findMany()
    * ```
    */
  get draftPick(): Prisma.DraftPickDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tradeOffer`: Exposes CRUD operations for the **TradeOffer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TradeOffers
    * const tradeOffers = await prisma.tradeOffer.findMany()
    * ```
    */
  get tradeOffer(): Prisma.TradeOfferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tradeOfferPlayer`: Exposes CRUD operations for the **TradeOfferPlayer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TradeOfferPlayers
    * const tradeOfferPlayers = await prisma.tradeOfferPlayer.findMany()
    * ```
    */
  get tradeOfferPlayer(): Prisma.TradeOfferPlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameStats`: Exposes CRUD operations for the **GameStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameStats
    * const gameStats = await prisma.gameStats.findMany()
    * ```
    */
  get gameStats(): Prisma.GameStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weeklyProjection`: Exposes CRUD operations for the **WeeklyProjection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeeklyProjections
    * const weeklyProjections = await prisma.weeklyProjection.findMany()
    * ```
    */
  get weeklyProjection(): Prisma.WeeklyProjectionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    League: 'League',
    LeagueSettings: 'LeagueSettings',
    ScoringSettings: 'ScoringSettings',
    RosterSettings: 'RosterSettings',
    Team: 'Team',
    Player: 'Player',
    Roster: 'Roster',
    Draft: 'Draft',
    DraftPick: 'DraftPick',
    Game: 'Game',
    Transaction: 'Transaction',
    TradeOffer: 'TradeOffer',
    TradeOfferPlayer: 'TradeOfferPlayer',
    Message: 'Message',
    GameStats: 'GameStats',
    WeeklyProjection: 'WeeklyProjection'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "league" | "leagueSettings" | "scoringSettings" | "rosterSettings" | "team" | "player" | "roster" | "draft" | "draftPick" | "game" | "transaction" | "tradeOffer" | "tradeOfferPlayer" | "message" | "gameStats" | "weeklyProjection"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      League: {
        payload: Prisma.$LeaguePayload<ExtArgs>
        fields: Prisma.LeagueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeagueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeagueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          findFirst: {
            args: Prisma.LeagueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeagueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          findMany: {
            args: Prisma.LeagueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>[]
          }
          create: {
            args: Prisma.LeagueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          createMany: {
            args: Prisma.LeagueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeagueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>[]
          }
          delete: {
            args: Prisma.LeagueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          update: {
            args: Prisma.LeagueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          deleteMany: {
            args: Prisma.LeagueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeagueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeagueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>[]
          }
          upsert: {
            args: Prisma.LeagueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaguePayload>
          }
          aggregate: {
            args: Prisma.LeagueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeague>
          }
          groupBy: {
            args: Prisma.LeagueGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeagueGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeagueCountArgs<ExtArgs>
            result: $Utils.Optional<LeagueCountAggregateOutputType> | number
          }
        }
      }
      LeagueSettings: {
        payload: Prisma.$LeagueSettingsPayload<ExtArgs>
        fields: Prisma.LeagueSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeagueSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeagueSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueSettingsPayload>
          }
          findFirst: {
            args: Prisma.LeagueSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeagueSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueSettingsPayload>
          }
          findMany: {
            args: Prisma.LeagueSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueSettingsPayload>[]
          }
          create: {
            args: Prisma.LeagueSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueSettingsPayload>
          }
          createMany: {
            args: Prisma.LeagueSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeagueSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueSettingsPayload>[]
          }
          delete: {
            args: Prisma.LeagueSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueSettingsPayload>
          }
          update: {
            args: Prisma.LeagueSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueSettingsPayload>
          }
          deleteMany: {
            args: Prisma.LeagueSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeagueSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeagueSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueSettingsPayload>[]
          }
          upsert: {
            args: Prisma.LeagueSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeagueSettingsPayload>
          }
          aggregate: {
            args: Prisma.LeagueSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeagueSettings>
          }
          groupBy: {
            args: Prisma.LeagueSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeagueSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeagueSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<LeagueSettingsCountAggregateOutputType> | number
          }
        }
      }
      ScoringSettings: {
        payload: Prisma.$ScoringSettingsPayload<ExtArgs>
        fields: Prisma.ScoringSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScoringSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScoringSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringSettingsPayload>
          }
          findFirst: {
            args: Prisma.ScoringSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScoringSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringSettingsPayload>
          }
          findMany: {
            args: Prisma.ScoringSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringSettingsPayload>[]
          }
          create: {
            args: Prisma.ScoringSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringSettingsPayload>
          }
          createMany: {
            args: Prisma.ScoringSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScoringSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringSettingsPayload>[]
          }
          delete: {
            args: Prisma.ScoringSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringSettingsPayload>
          }
          update: {
            args: Prisma.ScoringSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringSettingsPayload>
          }
          deleteMany: {
            args: Prisma.ScoringSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScoringSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScoringSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringSettingsPayload>[]
          }
          upsert: {
            args: Prisma.ScoringSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoringSettingsPayload>
          }
          aggregate: {
            args: Prisma.ScoringSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScoringSettings>
          }
          groupBy: {
            args: Prisma.ScoringSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScoringSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScoringSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<ScoringSettingsCountAggregateOutputType> | number
          }
        }
      }
      RosterSettings: {
        payload: Prisma.$RosterSettingsPayload<ExtArgs>
        fields: Prisma.RosterSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RosterSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RosterSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterSettingsPayload>
          }
          findFirst: {
            args: Prisma.RosterSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RosterSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterSettingsPayload>
          }
          findMany: {
            args: Prisma.RosterSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterSettingsPayload>[]
          }
          create: {
            args: Prisma.RosterSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterSettingsPayload>
          }
          createMany: {
            args: Prisma.RosterSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RosterSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterSettingsPayload>[]
          }
          delete: {
            args: Prisma.RosterSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterSettingsPayload>
          }
          update: {
            args: Prisma.RosterSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterSettingsPayload>
          }
          deleteMany: {
            args: Prisma.RosterSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RosterSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RosterSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterSettingsPayload>[]
          }
          upsert: {
            args: Prisma.RosterSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterSettingsPayload>
          }
          aggregate: {
            args: Prisma.RosterSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRosterSettings>
          }
          groupBy: {
            args: Prisma.RosterSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RosterSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RosterSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<RosterSettingsCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Player: {
        payload: Prisma.$PlayerPayload<ExtArgs>
        fields: Prisma.PlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findFirst: {
            args: Prisma.PlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findMany: {
            args: Prisma.PlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          create: {
            args: Prisma.PlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          createMany: {
            args: Prisma.PlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          delete: {
            args: Prisma.PlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          update: {
            args: Prisma.PlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          deleteMany: {
            args: Prisma.PlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          upsert: {
            args: Prisma.PlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          aggregate: {
            args: Prisma.PlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayer>
          }
          groupBy: {
            args: Prisma.PlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerCountAggregateOutputType> | number
          }
        }
      }
      Roster: {
        payload: Prisma.$RosterPayload<ExtArgs>
        fields: Prisma.RosterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RosterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RosterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterPayload>
          }
          findFirst: {
            args: Prisma.RosterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RosterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterPayload>
          }
          findMany: {
            args: Prisma.RosterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterPayload>[]
          }
          create: {
            args: Prisma.RosterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterPayload>
          }
          createMany: {
            args: Prisma.RosterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RosterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterPayload>[]
          }
          delete: {
            args: Prisma.RosterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterPayload>
          }
          update: {
            args: Prisma.RosterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterPayload>
          }
          deleteMany: {
            args: Prisma.RosterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RosterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RosterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterPayload>[]
          }
          upsert: {
            args: Prisma.RosterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RosterPayload>
          }
          aggregate: {
            args: Prisma.RosterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoster>
          }
          groupBy: {
            args: Prisma.RosterGroupByArgs<ExtArgs>
            result: $Utils.Optional<RosterGroupByOutputType>[]
          }
          count: {
            args: Prisma.RosterCountArgs<ExtArgs>
            result: $Utils.Optional<RosterCountAggregateOutputType> | number
          }
        }
      }
      Draft: {
        payload: Prisma.$DraftPayload<ExtArgs>
        fields: Prisma.DraftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DraftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DraftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          findFirst: {
            args: Prisma.DraftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DraftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          findMany: {
            args: Prisma.DraftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>[]
          }
          create: {
            args: Prisma.DraftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          createMany: {
            args: Prisma.DraftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DraftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>[]
          }
          delete: {
            args: Prisma.DraftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          update: {
            args: Prisma.DraftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          deleteMany: {
            args: Prisma.DraftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DraftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DraftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>[]
          }
          upsert: {
            args: Prisma.DraftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          aggregate: {
            args: Prisma.DraftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDraft>
          }
          groupBy: {
            args: Prisma.DraftGroupByArgs<ExtArgs>
            result: $Utils.Optional<DraftGroupByOutputType>[]
          }
          count: {
            args: Prisma.DraftCountArgs<ExtArgs>
            result: $Utils.Optional<DraftCountAggregateOutputType> | number
          }
        }
      }
      DraftPick: {
        payload: Prisma.$DraftPickPayload<ExtArgs>
        fields: Prisma.DraftPickFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DraftPickFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPickPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DraftPickFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPickPayload>
          }
          findFirst: {
            args: Prisma.DraftPickFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPickPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DraftPickFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPickPayload>
          }
          findMany: {
            args: Prisma.DraftPickFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPickPayload>[]
          }
          create: {
            args: Prisma.DraftPickCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPickPayload>
          }
          createMany: {
            args: Prisma.DraftPickCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DraftPickCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPickPayload>[]
          }
          delete: {
            args: Prisma.DraftPickDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPickPayload>
          }
          update: {
            args: Prisma.DraftPickUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPickPayload>
          }
          deleteMany: {
            args: Prisma.DraftPickDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DraftPickUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DraftPickUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPickPayload>[]
          }
          upsert: {
            args: Prisma.DraftPickUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPickPayload>
          }
          aggregate: {
            args: Prisma.DraftPickAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDraftPick>
          }
          groupBy: {
            args: Prisma.DraftPickGroupByArgs<ExtArgs>
            result: $Utils.Optional<DraftPickGroupByOutputType>[]
          }
          count: {
            args: Prisma.DraftPickCountArgs<ExtArgs>
            result: $Utils.Optional<DraftPickCountAggregateOutputType> | number
          }
        }
      }
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>
        fields: Prisma.GameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      TradeOffer: {
        payload: Prisma.$TradeOfferPayload<ExtArgs>
        fields: Prisma.TradeOfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradeOfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradeOfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPayload>
          }
          findFirst: {
            args: Prisma.TradeOfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradeOfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPayload>
          }
          findMany: {
            args: Prisma.TradeOfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPayload>[]
          }
          create: {
            args: Prisma.TradeOfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPayload>
          }
          createMany: {
            args: Prisma.TradeOfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TradeOfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPayload>[]
          }
          delete: {
            args: Prisma.TradeOfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPayload>
          }
          update: {
            args: Prisma.TradeOfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPayload>
          }
          deleteMany: {
            args: Prisma.TradeOfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TradeOfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TradeOfferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPayload>[]
          }
          upsert: {
            args: Prisma.TradeOfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPayload>
          }
          aggregate: {
            args: Prisma.TradeOfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTradeOffer>
          }
          groupBy: {
            args: Prisma.TradeOfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradeOfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.TradeOfferCountArgs<ExtArgs>
            result: $Utils.Optional<TradeOfferCountAggregateOutputType> | number
          }
        }
      }
      TradeOfferPlayer: {
        payload: Prisma.$TradeOfferPlayerPayload<ExtArgs>
        fields: Prisma.TradeOfferPlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradeOfferPlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradeOfferPlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPlayerPayload>
          }
          findFirst: {
            args: Prisma.TradeOfferPlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradeOfferPlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPlayerPayload>
          }
          findMany: {
            args: Prisma.TradeOfferPlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPlayerPayload>[]
          }
          create: {
            args: Prisma.TradeOfferPlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPlayerPayload>
          }
          createMany: {
            args: Prisma.TradeOfferPlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TradeOfferPlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPlayerPayload>[]
          }
          delete: {
            args: Prisma.TradeOfferPlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPlayerPayload>
          }
          update: {
            args: Prisma.TradeOfferPlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPlayerPayload>
          }
          deleteMany: {
            args: Prisma.TradeOfferPlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TradeOfferPlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TradeOfferPlayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPlayerPayload>[]
          }
          upsert: {
            args: Prisma.TradeOfferPlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeOfferPlayerPayload>
          }
          aggregate: {
            args: Prisma.TradeOfferPlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTradeOfferPlayer>
          }
          groupBy: {
            args: Prisma.TradeOfferPlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradeOfferPlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.TradeOfferPlayerCountArgs<ExtArgs>
            result: $Utils.Optional<TradeOfferPlayerCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      GameStats: {
        payload: Prisma.$GameStatsPayload<ExtArgs>
        fields: Prisma.GameStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatsPayload>
          }
          findFirst: {
            args: Prisma.GameStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatsPayload>
          }
          findMany: {
            args: Prisma.GameStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatsPayload>[]
          }
          create: {
            args: Prisma.GameStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatsPayload>
          }
          createMany: {
            args: Prisma.GameStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatsPayload>[]
          }
          delete: {
            args: Prisma.GameStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatsPayload>
          }
          update: {
            args: Prisma.GameStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatsPayload>
          }
          deleteMany: {
            args: Prisma.GameStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatsPayload>[]
          }
          upsert: {
            args: Prisma.GameStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameStatsPayload>
          }
          aggregate: {
            args: Prisma.GameStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameStats>
          }
          groupBy: {
            args: Prisma.GameStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameStatsCountArgs<ExtArgs>
            result: $Utils.Optional<GameStatsCountAggregateOutputType> | number
          }
        }
      }
      WeeklyProjection: {
        payload: Prisma.$WeeklyProjectionPayload<ExtArgs>
        fields: Prisma.WeeklyProjectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeeklyProjectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyProjectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeeklyProjectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyProjectionPayload>
          }
          findFirst: {
            args: Prisma.WeeklyProjectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyProjectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeeklyProjectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyProjectionPayload>
          }
          findMany: {
            args: Prisma.WeeklyProjectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyProjectionPayload>[]
          }
          create: {
            args: Prisma.WeeklyProjectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyProjectionPayload>
          }
          createMany: {
            args: Prisma.WeeklyProjectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeeklyProjectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyProjectionPayload>[]
          }
          delete: {
            args: Prisma.WeeklyProjectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyProjectionPayload>
          }
          update: {
            args: Prisma.WeeklyProjectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyProjectionPayload>
          }
          deleteMany: {
            args: Prisma.WeeklyProjectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeeklyProjectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeeklyProjectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyProjectionPayload>[]
          }
          upsert: {
            args: Prisma.WeeklyProjectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyProjectionPayload>
          }
          aggregate: {
            args: Prisma.WeeklyProjectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeeklyProjection>
          }
          groupBy: {
            args: Prisma.WeeklyProjectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeeklyProjectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeeklyProjectionCountArgs<ExtArgs>
            result: $Utils.Optional<WeeklyProjectionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    league?: LeagueOmit
    leagueSettings?: LeagueSettingsOmit
    scoringSettings?: ScoringSettingsOmit
    rosterSettings?: RosterSettingsOmit
    team?: TeamOmit
    player?: PlayerOmit
    roster?: RosterOmit
    draft?: DraftOmit
    draftPick?: DraftPickOmit
    game?: GameOmit
    transaction?: TransactionOmit
    tradeOffer?: TradeOfferOmit
    tradeOfferPlayer?: TradeOfferPlayerOmit
    message?: MessageOmit
    gameStats?: GameStatsOmit
    weeklyProjection?: WeeklyProjectionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    teamsOwned: number
    leaguesCommissioned: number
    transactions: number
    messages: number
    draftPicks: number
    tradeOffers: number
    tradeTargets: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamsOwned?: boolean | UserCountOutputTypeCountTeamsOwnedArgs
    leaguesCommissioned?: boolean | UserCountOutputTypeCountLeaguesCommissionedArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    draftPicks?: boolean | UserCountOutputTypeCountDraftPicksArgs
    tradeOffers?: boolean | UserCountOutputTypeCountTradeOffersArgs
    tradeTargets?: boolean | UserCountOutputTypeCountTradeTargetsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaguesCommissionedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeagueWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDraftPicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftPickWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTradeOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeOfferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTradeTargetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeOfferWhereInput
  }


  /**
   * Count Type LeagueCountOutputType
   */

  export type LeagueCountOutputType = {
    teams: number
    games: number
    transactions: number
    messages: number
    tradeOffers: number
  }

  export type LeagueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teams?: boolean | LeagueCountOutputTypeCountTeamsArgs
    games?: boolean | LeagueCountOutputTypeCountGamesArgs
    transactions?: boolean | LeagueCountOutputTypeCountTransactionsArgs
    messages?: boolean | LeagueCountOutputTypeCountMessagesArgs
    tradeOffers?: boolean | LeagueCountOutputTypeCountTradeOffersArgs
  }

  // Custom InputTypes
  /**
   * LeagueCountOutputType without action
   */
  export type LeagueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueCountOutputType
     */
    select?: LeagueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeagueCountOutputType without action
   */
  export type LeagueCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * LeagueCountOutputType without action
   */
  export type LeagueCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }

  /**
   * LeagueCountOutputType without action
   */
  export type LeagueCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * LeagueCountOutputType without action
   */
  export type LeagueCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * LeagueCountOutputType without action
   */
  export type LeagueCountOutputTypeCountTradeOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeOfferWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    roster: number
    draftPicks: number
    homeGames: number
    awayGames: number
    transactions: number
    offeredTrades: number
    targetedTrades: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roster?: boolean | TeamCountOutputTypeCountRosterArgs
    draftPicks?: boolean | TeamCountOutputTypeCountDraftPicksArgs
    homeGames?: boolean | TeamCountOutputTypeCountHomeGamesArgs
    awayGames?: boolean | TeamCountOutputTypeCountAwayGamesArgs
    transactions?: boolean | TeamCountOutputTypeCountTransactionsArgs
    offeredTrades?: boolean | TeamCountOutputTypeCountOfferedTradesArgs
    targetedTrades?: boolean | TeamCountOutputTypeCountTargetedTradesArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountRosterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RosterWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountDraftPicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftPickWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountHomeGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountAwayGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountOfferedTradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeOfferWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTargetedTradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeOfferWhereInput
  }


  /**
   * Count Type PlayerCountOutputType
   */

  export type PlayerCountOutputType = {
    roster: number
    draftPicks: number
    transactions: number
    gameStats: number
    weeklyProjections: number
    tradeOfferPlayers: number
  }

  export type PlayerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roster?: boolean | PlayerCountOutputTypeCountRosterArgs
    draftPicks?: boolean | PlayerCountOutputTypeCountDraftPicksArgs
    transactions?: boolean | PlayerCountOutputTypeCountTransactionsArgs
    gameStats?: boolean | PlayerCountOutputTypeCountGameStatsArgs
    weeklyProjections?: boolean | PlayerCountOutputTypeCountWeeklyProjectionsArgs
    tradeOfferPlayers?: boolean | PlayerCountOutputTypeCountTradeOfferPlayersArgs
  }

  // Custom InputTypes
  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCountOutputType
     */
    select?: PlayerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountRosterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RosterWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountDraftPicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftPickWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountGameStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameStatsWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountWeeklyProjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyProjectionWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountTradeOfferPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeOfferPlayerWhereInput
  }


  /**
   * Count Type DraftCountOutputType
   */

  export type DraftCountOutputType = {
    picks: number
  }

  export type DraftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    picks?: boolean | DraftCountOutputTypeCountPicksArgs
  }

  // Custom InputTypes
  /**
   * DraftCountOutputType without action
   */
  export type DraftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftCountOutputType
     */
    select?: DraftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DraftCountOutputType without action
   */
  export type DraftCountOutputTypeCountPicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftPickWhereInput
  }


  /**
   * Count Type TradeOfferCountOutputType
   */

  export type TradeOfferCountOutputType = {
    players: number
  }

  export type TradeOfferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | TradeOfferCountOutputTypeCountPlayersArgs
  }

  // Custom InputTypes
  /**
   * TradeOfferCountOutputType without action
   */
  export type TradeOfferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOfferCountOutputType
     */
    select?: TradeOfferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TradeOfferCountOutputType without action
   */
  export type TradeOfferCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeOfferPlayerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    profileImage: string | null
    timezone: string | null
    isActive: boolean | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    profileImage: string | null
    timezone: string | null
    isActive: boolean | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    firstName: number
    lastName: number
    profileImage: number
    timezone: number
    isActive: number
    emailVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    firstName?: true
    lastName?: true
    profileImage?: true
    timezone?: true
    isActive?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    firstName?: true
    lastName?: true
    profileImage?: true
    timezone?: true
    isActive?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    firstName?: true
    lastName?: true
    profileImage?: true
    timezone?: true
    isActive?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    firstName: string | null
    lastName: string | null
    profileImage: string | null
    timezone: string
    isActive: boolean
    emailVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImage?: boolean
    timezone?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamsOwned?: boolean | User$teamsOwnedArgs<ExtArgs>
    leaguesCommissioned?: boolean | User$leaguesCommissionedArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    draftPicks?: boolean | User$draftPicksArgs<ExtArgs>
    tradeOffers?: boolean | User$tradeOffersArgs<ExtArgs>
    tradeTargets?: boolean | User$tradeTargetsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImage?: boolean
    timezone?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImage?: boolean
    timezone?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImage?: boolean
    timezone?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "firstName" | "lastName" | "profileImage" | "timezone" | "isActive" | "emailVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamsOwned?: boolean | User$teamsOwnedArgs<ExtArgs>
    leaguesCommissioned?: boolean | User$leaguesCommissionedArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    draftPicks?: boolean | User$draftPicksArgs<ExtArgs>
    tradeOffers?: boolean | User$tradeOffersArgs<ExtArgs>
    tradeTargets?: boolean | User$tradeTargetsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      teamsOwned: Prisma.$TeamPayload<ExtArgs>[]
      leaguesCommissioned: Prisma.$LeaguePayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      draftPicks: Prisma.$DraftPickPayload<ExtArgs>[]
      tradeOffers: Prisma.$TradeOfferPayload<ExtArgs>[]
      tradeTargets: Prisma.$TradeOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      firstName: string | null
      lastName: string | null
      profileImage: string | null
      timezone: string
      isActive: boolean
      emailVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teamsOwned<T extends User$teamsOwnedArgs<ExtArgs> = {}>(args?: Subset<T, User$teamsOwnedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaguesCommissioned<T extends User$leaguesCommissionedArgs<ExtArgs> = {}>(args?: Subset<T, User$leaguesCommissionedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    draftPicks<T extends User$draftPicksArgs<ExtArgs> = {}>(args?: Subset<T, User$draftPicksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPickPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tradeOffers<T extends User$tradeOffersArgs<ExtArgs> = {}>(args?: Subset<T, User$tradeOffersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tradeTargets<T extends User$tradeTargetsArgs<ExtArgs> = {}>(args?: Subset<T, User$tradeTargetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.teamsOwned
   */
  export type User$teamsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * User.leaguesCommissioned
   */
  export type User$leaguesCommissionedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    where?: LeagueWhereInput
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    cursor?: LeagueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeagueScalarFieldEnum | LeagueScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.draftPicks
   */
  export type User$draftPicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickInclude<ExtArgs> | null
    where?: DraftPickWhereInput
    orderBy?: DraftPickOrderByWithRelationInput | DraftPickOrderByWithRelationInput[]
    cursor?: DraftPickWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DraftPickScalarFieldEnum | DraftPickScalarFieldEnum[]
  }

  /**
   * User.tradeOffers
   */
  export type User$tradeOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferInclude<ExtArgs> | null
    where?: TradeOfferWhereInput
    orderBy?: TradeOfferOrderByWithRelationInput | TradeOfferOrderByWithRelationInput[]
    cursor?: TradeOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeOfferScalarFieldEnum | TradeOfferScalarFieldEnum[]
  }

  /**
   * User.tradeTargets
   */
  export type User$tradeTargetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferInclude<ExtArgs> | null
    where?: TradeOfferWhereInput
    orderBy?: TradeOfferOrderByWithRelationInput | TradeOfferOrderByWithRelationInput[]
    cursor?: TradeOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeOfferScalarFieldEnum | TradeOfferScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model League
   */

  export type AggregateLeague = {
    _count: LeagueCountAggregateOutputType | null
    _avg: LeagueAvgAggregateOutputType | null
    _sum: LeagueSumAggregateOutputType | null
    _min: LeagueMinAggregateOutputType | null
    _max: LeagueMaxAggregateOutputType | null
  }

  export type LeagueAvgAggregateOutputType = {
    maxTeams: number | null
    entryFee: Decimal | null
    prizeAmount: Decimal | null
    seasonStartWeek: number | null
    maxAddsPerSeason: number | null
    maxAddsPerWeek: number | null
    tradeRejectTime: number | null
    waiverTime: number | null
  }

  export type LeagueSumAggregateOutputType = {
    maxTeams: number | null
    entryFee: Decimal | null
    prizeAmount: Decimal | null
    seasonStartWeek: number | null
    maxAddsPerSeason: number | null
    maxAddsPerWeek: number | null
    tradeRejectTime: number | null
    waiverTime: number | null
  }

  export type LeagueMinAggregateOutputType = {
    id: string | null
    name: string | null
    password: string | null
    customUrl: string | null
    commissionerId: string | null
    maxTeams: number | null
    isActive: boolean | null
    isPaid: boolean | null
    entryFee: Decimal | null
    prizeAmount: Decimal | null
    draftType: $Enums.DraftType | null
    draftDate: Date | null
    seasonStartWeek: number | null
    leagueStartDate: Date | null
    rosterDeadline: Date | null
    maxAddsPerSeason: number | null
    maxAddsPerWeek: number | null
    tradeRejectTime: number | null
    tradeEndDate: Date | null
    waiverTime: number | null
    commissionerMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeagueMaxAggregateOutputType = {
    id: string | null
    name: string | null
    password: string | null
    customUrl: string | null
    commissionerId: string | null
    maxTeams: number | null
    isActive: boolean | null
    isPaid: boolean | null
    entryFee: Decimal | null
    prizeAmount: Decimal | null
    draftType: $Enums.DraftType | null
    draftDate: Date | null
    seasonStartWeek: number | null
    leagueStartDate: Date | null
    rosterDeadline: Date | null
    maxAddsPerSeason: number | null
    maxAddsPerWeek: number | null
    tradeRejectTime: number | null
    tradeEndDate: Date | null
    waiverTime: number | null
    commissionerMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeagueCountAggregateOutputType = {
    id: number
    name: number
    password: number
    customUrl: number
    commissionerId: number
    maxTeams: number
    isActive: number
    isPaid: number
    entryFee: number
    prizeAmount: number
    draftType: number
    draftDate: number
    seasonStartWeek: number
    leagueStartDate: number
    rosterDeadline: number
    maxAddsPerSeason: number
    maxAddsPerWeek: number
    tradeRejectTime: number
    tradeEndDate: number
    waiverTime: number
    commissionerMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeagueAvgAggregateInputType = {
    maxTeams?: true
    entryFee?: true
    prizeAmount?: true
    seasonStartWeek?: true
    maxAddsPerSeason?: true
    maxAddsPerWeek?: true
    tradeRejectTime?: true
    waiverTime?: true
  }

  export type LeagueSumAggregateInputType = {
    maxTeams?: true
    entryFee?: true
    prizeAmount?: true
    seasonStartWeek?: true
    maxAddsPerSeason?: true
    maxAddsPerWeek?: true
    tradeRejectTime?: true
    waiverTime?: true
  }

  export type LeagueMinAggregateInputType = {
    id?: true
    name?: true
    password?: true
    customUrl?: true
    commissionerId?: true
    maxTeams?: true
    isActive?: true
    isPaid?: true
    entryFee?: true
    prizeAmount?: true
    draftType?: true
    draftDate?: true
    seasonStartWeek?: true
    leagueStartDate?: true
    rosterDeadline?: true
    maxAddsPerSeason?: true
    maxAddsPerWeek?: true
    tradeRejectTime?: true
    tradeEndDate?: true
    waiverTime?: true
    commissionerMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeagueMaxAggregateInputType = {
    id?: true
    name?: true
    password?: true
    customUrl?: true
    commissionerId?: true
    maxTeams?: true
    isActive?: true
    isPaid?: true
    entryFee?: true
    prizeAmount?: true
    draftType?: true
    draftDate?: true
    seasonStartWeek?: true
    leagueStartDate?: true
    rosterDeadline?: true
    maxAddsPerSeason?: true
    maxAddsPerWeek?: true
    tradeRejectTime?: true
    tradeEndDate?: true
    waiverTime?: true
    commissionerMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeagueCountAggregateInputType = {
    id?: true
    name?: true
    password?: true
    customUrl?: true
    commissionerId?: true
    maxTeams?: true
    isActive?: true
    isPaid?: true
    entryFee?: true
    prizeAmount?: true
    draftType?: true
    draftDate?: true
    seasonStartWeek?: true
    leagueStartDate?: true
    rosterDeadline?: true
    maxAddsPerSeason?: true
    maxAddsPerWeek?: true
    tradeRejectTime?: true
    tradeEndDate?: true
    waiverTime?: true
    commissionerMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeagueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which League to aggregate.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leagues
    **/
    _count?: true | LeagueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeagueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeagueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeagueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeagueMaxAggregateInputType
  }

  export type GetLeagueAggregateType<T extends LeagueAggregateArgs> = {
        [P in keyof T & keyof AggregateLeague]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeague[P]>
      : GetScalarType<T[P], AggregateLeague[P]>
  }




  export type LeagueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeagueWhereInput
    orderBy?: LeagueOrderByWithAggregationInput | LeagueOrderByWithAggregationInput[]
    by: LeagueScalarFieldEnum[] | LeagueScalarFieldEnum
    having?: LeagueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeagueCountAggregateInputType | true
    _avg?: LeagueAvgAggregateInputType
    _sum?: LeagueSumAggregateInputType
    _min?: LeagueMinAggregateInputType
    _max?: LeagueMaxAggregateInputType
  }

  export type LeagueGroupByOutputType = {
    id: string
    name: string
    password: string | null
    customUrl: string | null
    commissionerId: string
    maxTeams: number
    isActive: boolean
    isPaid: boolean
    entryFee: Decimal | null
    prizeAmount: Decimal | null
    draftType: $Enums.DraftType
    draftDate: Date | null
    seasonStartWeek: number
    leagueStartDate: Date | null
    rosterDeadline: Date | null
    maxAddsPerSeason: number | null
    maxAddsPerWeek: number | null
    tradeRejectTime: number
    tradeEndDate: Date | null
    waiverTime: number
    commissionerMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeagueCountAggregateOutputType | null
    _avg: LeagueAvgAggregateOutputType | null
    _sum: LeagueSumAggregateOutputType | null
    _min: LeagueMinAggregateOutputType | null
    _max: LeagueMaxAggregateOutputType | null
  }

  type GetLeagueGroupByPayload<T extends LeagueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeagueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeagueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeagueGroupByOutputType[P]>
            : GetScalarType<T[P], LeagueGroupByOutputType[P]>
        }
      >
    >


  export type LeagueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    password?: boolean
    customUrl?: boolean
    commissionerId?: boolean
    maxTeams?: boolean
    isActive?: boolean
    isPaid?: boolean
    entryFee?: boolean
    prizeAmount?: boolean
    draftType?: boolean
    draftDate?: boolean
    seasonStartWeek?: boolean
    leagueStartDate?: boolean
    rosterDeadline?: boolean
    maxAddsPerSeason?: boolean
    maxAddsPerWeek?: boolean
    tradeRejectTime?: boolean
    tradeEndDate?: boolean
    waiverTime?: boolean
    commissionerMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commissioner?: boolean | UserDefaultArgs<ExtArgs>
    teams?: boolean | League$teamsArgs<ExtArgs>
    leagueSettings?: boolean | League$leagueSettingsArgs<ExtArgs>
    scoringSettings?: boolean | League$scoringSettingsArgs<ExtArgs>
    rosterSettings?: boolean | League$rosterSettingsArgs<ExtArgs>
    draft?: boolean | League$draftArgs<ExtArgs>
    games?: boolean | League$gamesArgs<ExtArgs>
    transactions?: boolean | League$transactionsArgs<ExtArgs>
    messages?: boolean | League$messagesArgs<ExtArgs>
    tradeOffers?: boolean | League$tradeOffersArgs<ExtArgs>
    _count?: boolean | LeagueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["league"]>

  export type LeagueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    password?: boolean
    customUrl?: boolean
    commissionerId?: boolean
    maxTeams?: boolean
    isActive?: boolean
    isPaid?: boolean
    entryFee?: boolean
    prizeAmount?: boolean
    draftType?: boolean
    draftDate?: boolean
    seasonStartWeek?: boolean
    leagueStartDate?: boolean
    rosterDeadline?: boolean
    maxAddsPerSeason?: boolean
    maxAddsPerWeek?: boolean
    tradeRejectTime?: boolean
    tradeEndDate?: boolean
    waiverTime?: boolean
    commissionerMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commissioner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["league"]>

  export type LeagueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    password?: boolean
    customUrl?: boolean
    commissionerId?: boolean
    maxTeams?: boolean
    isActive?: boolean
    isPaid?: boolean
    entryFee?: boolean
    prizeAmount?: boolean
    draftType?: boolean
    draftDate?: boolean
    seasonStartWeek?: boolean
    leagueStartDate?: boolean
    rosterDeadline?: boolean
    maxAddsPerSeason?: boolean
    maxAddsPerWeek?: boolean
    tradeRejectTime?: boolean
    tradeEndDate?: boolean
    waiverTime?: boolean
    commissionerMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commissioner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["league"]>

  export type LeagueSelectScalar = {
    id?: boolean
    name?: boolean
    password?: boolean
    customUrl?: boolean
    commissionerId?: boolean
    maxTeams?: boolean
    isActive?: boolean
    isPaid?: boolean
    entryFee?: boolean
    prizeAmount?: boolean
    draftType?: boolean
    draftDate?: boolean
    seasonStartWeek?: boolean
    leagueStartDate?: boolean
    rosterDeadline?: boolean
    maxAddsPerSeason?: boolean
    maxAddsPerWeek?: boolean
    tradeRejectTime?: boolean
    tradeEndDate?: boolean
    waiverTime?: boolean
    commissionerMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeagueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "password" | "customUrl" | "commissionerId" | "maxTeams" | "isActive" | "isPaid" | "entryFee" | "prizeAmount" | "draftType" | "draftDate" | "seasonStartWeek" | "leagueStartDate" | "rosterDeadline" | "maxAddsPerSeason" | "maxAddsPerWeek" | "tradeRejectTime" | "tradeEndDate" | "waiverTime" | "commissionerMessage" | "createdAt" | "updatedAt", ExtArgs["result"]["league"]>
  export type LeagueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commissioner?: boolean | UserDefaultArgs<ExtArgs>
    teams?: boolean | League$teamsArgs<ExtArgs>
    leagueSettings?: boolean | League$leagueSettingsArgs<ExtArgs>
    scoringSettings?: boolean | League$scoringSettingsArgs<ExtArgs>
    rosterSettings?: boolean | League$rosterSettingsArgs<ExtArgs>
    draft?: boolean | League$draftArgs<ExtArgs>
    games?: boolean | League$gamesArgs<ExtArgs>
    transactions?: boolean | League$transactionsArgs<ExtArgs>
    messages?: boolean | League$messagesArgs<ExtArgs>
    tradeOffers?: boolean | League$tradeOffersArgs<ExtArgs>
    _count?: boolean | LeagueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeagueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commissioner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LeagueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commissioner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LeaguePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "League"
    objects: {
      commissioner: Prisma.$UserPayload<ExtArgs>
      teams: Prisma.$TeamPayload<ExtArgs>[]
      leagueSettings: Prisma.$LeagueSettingsPayload<ExtArgs> | null
      scoringSettings: Prisma.$ScoringSettingsPayload<ExtArgs> | null
      rosterSettings: Prisma.$RosterSettingsPayload<ExtArgs> | null
      draft: Prisma.$DraftPayload<ExtArgs> | null
      games: Prisma.$GamePayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      tradeOffers: Prisma.$TradeOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      password: string | null
      customUrl: string | null
      commissionerId: string
      maxTeams: number
      isActive: boolean
      isPaid: boolean
      entryFee: Prisma.Decimal | null
      prizeAmount: Prisma.Decimal | null
      draftType: $Enums.DraftType
      draftDate: Date | null
      seasonStartWeek: number
      leagueStartDate: Date | null
      rosterDeadline: Date | null
      maxAddsPerSeason: number | null
      maxAddsPerWeek: number | null
      tradeRejectTime: number
      tradeEndDate: Date | null
      waiverTime: number
      commissionerMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["league"]>
    composites: {}
  }

  type LeagueGetPayload<S extends boolean | null | undefined | LeagueDefaultArgs> = $Result.GetResult<Prisma.$LeaguePayload, S>

  type LeagueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeagueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeagueCountAggregateInputType | true
    }

  export interface LeagueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['League'], meta: { name: 'League' } }
    /**
     * Find zero or one League that matches the filter.
     * @param {LeagueFindUniqueArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeagueFindUniqueArgs>(args: SelectSubset<T, LeagueFindUniqueArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one League that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeagueFindUniqueOrThrowArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeagueFindUniqueOrThrowArgs>(args: SelectSubset<T, LeagueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first League that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueFindFirstArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeagueFindFirstArgs>(args?: SelectSubset<T, LeagueFindFirstArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first League that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueFindFirstOrThrowArgs} args - Arguments to find a League
     * @example
     * // Get one League
     * const league = await prisma.league.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeagueFindFirstOrThrowArgs>(args?: SelectSubset<T, LeagueFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leagues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leagues
     * const leagues = await prisma.league.findMany()
     * 
     * // Get first 10 Leagues
     * const leagues = await prisma.league.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leagueWithIdOnly = await prisma.league.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeagueFindManyArgs>(args?: SelectSubset<T, LeagueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a League.
     * @param {LeagueCreateArgs} args - Arguments to create a League.
     * @example
     * // Create one League
     * const League = await prisma.league.create({
     *   data: {
     *     // ... data to create a League
     *   }
     * })
     * 
     */
    create<T extends LeagueCreateArgs>(args: SelectSubset<T, LeagueCreateArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leagues.
     * @param {LeagueCreateManyArgs} args - Arguments to create many Leagues.
     * @example
     * // Create many Leagues
     * const league = await prisma.league.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeagueCreateManyArgs>(args?: SelectSubset<T, LeagueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leagues and returns the data saved in the database.
     * @param {LeagueCreateManyAndReturnArgs} args - Arguments to create many Leagues.
     * @example
     * // Create many Leagues
     * const league = await prisma.league.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leagues and only return the `id`
     * const leagueWithIdOnly = await prisma.league.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeagueCreateManyAndReturnArgs>(args?: SelectSubset<T, LeagueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a League.
     * @param {LeagueDeleteArgs} args - Arguments to delete one League.
     * @example
     * // Delete one League
     * const League = await prisma.league.delete({
     *   where: {
     *     // ... filter to delete one League
     *   }
     * })
     * 
     */
    delete<T extends LeagueDeleteArgs>(args: SelectSubset<T, LeagueDeleteArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one League.
     * @param {LeagueUpdateArgs} args - Arguments to update one League.
     * @example
     * // Update one League
     * const league = await prisma.league.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeagueUpdateArgs>(args: SelectSubset<T, LeagueUpdateArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leagues.
     * @param {LeagueDeleteManyArgs} args - Arguments to filter Leagues to delete.
     * @example
     * // Delete a few Leagues
     * const { count } = await prisma.league.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeagueDeleteManyArgs>(args?: SelectSubset<T, LeagueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leagues
     * const league = await prisma.league.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeagueUpdateManyArgs>(args: SelectSubset<T, LeagueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leagues and returns the data updated in the database.
     * @param {LeagueUpdateManyAndReturnArgs} args - Arguments to update many Leagues.
     * @example
     * // Update many Leagues
     * const league = await prisma.league.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leagues and only return the `id`
     * const leagueWithIdOnly = await prisma.league.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeagueUpdateManyAndReturnArgs>(args: SelectSubset<T, LeagueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one League.
     * @param {LeagueUpsertArgs} args - Arguments to update or create a League.
     * @example
     * // Update or create a League
     * const league = await prisma.league.upsert({
     *   create: {
     *     // ... data to create a League
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the League we want to update
     *   }
     * })
     */
    upsert<T extends LeagueUpsertArgs>(args: SelectSubset<T, LeagueUpsertArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueCountArgs} args - Arguments to filter Leagues to count.
     * @example
     * // Count the number of Leagues
     * const count = await prisma.league.count({
     *   where: {
     *     // ... the filter for the Leagues we want to count
     *   }
     * })
    **/
    count<T extends LeagueCountArgs>(
      args?: Subset<T, LeagueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeagueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a League.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeagueAggregateArgs>(args: Subset<T, LeagueAggregateArgs>): Prisma.PrismaPromise<GetLeagueAggregateType<T>>

    /**
     * Group by League.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeagueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeagueGroupByArgs['orderBy'] }
        : { orderBy?: LeagueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeagueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeagueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the League model
   */
  readonly fields: LeagueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for League.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeagueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    commissioner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teams<T extends League$teamsArgs<ExtArgs> = {}>(args?: Subset<T, League$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leagueSettings<T extends League$leagueSettingsArgs<ExtArgs> = {}>(args?: Subset<T, League$leagueSettingsArgs<ExtArgs>>): Prisma__LeagueSettingsClient<$Result.GetResult<Prisma.$LeagueSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    scoringSettings<T extends League$scoringSettingsArgs<ExtArgs> = {}>(args?: Subset<T, League$scoringSettingsArgs<ExtArgs>>): Prisma__ScoringSettingsClient<$Result.GetResult<Prisma.$ScoringSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rosterSettings<T extends League$rosterSettingsArgs<ExtArgs> = {}>(args?: Subset<T, League$rosterSettingsArgs<ExtArgs>>): Prisma__RosterSettingsClient<$Result.GetResult<Prisma.$RosterSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    draft<T extends League$draftArgs<ExtArgs> = {}>(args?: Subset<T, League$draftArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    games<T extends League$gamesArgs<ExtArgs> = {}>(args?: Subset<T, League$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends League$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, League$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends League$messagesArgs<ExtArgs> = {}>(args?: Subset<T, League$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tradeOffers<T extends League$tradeOffersArgs<ExtArgs> = {}>(args?: Subset<T, League$tradeOffersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the League model
   */
  interface LeagueFieldRefs {
    readonly id: FieldRef<"League", 'String'>
    readonly name: FieldRef<"League", 'String'>
    readonly password: FieldRef<"League", 'String'>
    readonly customUrl: FieldRef<"League", 'String'>
    readonly commissionerId: FieldRef<"League", 'String'>
    readonly maxTeams: FieldRef<"League", 'Int'>
    readonly isActive: FieldRef<"League", 'Boolean'>
    readonly isPaid: FieldRef<"League", 'Boolean'>
    readonly entryFee: FieldRef<"League", 'Decimal'>
    readonly prizeAmount: FieldRef<"League", 'Decimal'>
    readonly draftType: FieldRef<"League", 'DraftType'>
    readonly draftDate: FieldRef<"League", 'DateTime'>
    readonly seasonStartWeek: FieldRef<"League", 'Int'>
    readonly leagueStartDate: FieldRef<"League", 'DateTime'>
    readonly rosterDeadline: FieldRef<"League", 'DateTime'>
    readonly maxAddsPerSeason: FieldRef<"League", 'Int'>
    readonly maxAddsPerWeek: FieldRef<"League", 'Int'>
    readonly tradeRejectTime: FieldRef<"League", 'Int'>
    readonly tradeEndDate: FieldRef<"League", 'DateTime'>
    readonly waiverTime: FieldRef<"League", 'Int'>
    readonly commissionerMessage: FieldRef<"League", 'String'>
    readonly createdAt: FieldRef<"League", 'DateTime'>
    readonly updatedAt: FieldRef<"League", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * League findUnique
   */
  export type LeagueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League findUniqueOrThrow
   */
  export type LeagueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League findFirst
   */
  export type LeagueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leagues.
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leagues.
     */
    distinct?: LeagueScalarFieldEnum | LeagueScalarFieldEnum[]
  }

  /**
   * League findFirstOrThrow
   */
  export type LeagueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which League to fetch.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leagues.
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leagues.
     */
    distinct?: LeagueScalarFieldEnum | LeagueScalarFieldEnum[]
  }

  /**
   * League findMany
   */
  export type LeagueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter, which Leagues to fetch.
     */
    where?: LeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leagues to fetch.
     */
    orderBy?: LeagueOrderByWithRelationInput | LeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leagues.
     */
    cursor?: LeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leagues.
     */
    skip?: number
    distinct?: LeagueScalarFieldEnum | LeagueScalarFieldEnum[]
  }

  /**
   * League create
   */
  export type LeagueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * The data needed to create a League.
     */
    data: XOR<LeagueCreateInput, LeagueUncheckedCreateInput>
  }

  /**
   * League createMany
   */
  export type LeagueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leagues.
     */
    data: LeagueCreateManyInput | LeagueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * League createManyAndReturn
   */
  export type LeagueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * The data used to create many Leagues.
     */
    data: LeagueCreateManyInput | LeagueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * League update
   */
  export type LeagueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * The data needed to update a League.
     */
    data: XOR<LeagueUpdateInput, LeagueUncheckedUpdateInput>
    /**
     * Choose, which League to update.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League updateMany
   */
  export type LeagueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leagues.
     */
    data: XOR<LeagueUpdateManyMutationInput, LeagueUncheckedUpdateManyInput>
    /**
     * Filter which Leagues to update
     */
    where?: LeagueWhereInput
    /**
     * Limit how many Leagues to update.
     */
    limit?: number
  }

  /**
   * League updateManyAndReturn
   */
  export type LeagueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * The data used to update Leagues.
     */
    data: XOR<LeagueUpdateManyMutationInput, LeagueUncheckedUpdateManyInput>
    /**
     * Filter which Leagues to update
     */
    where?: LeagueWhereInput
    /**
     * Limit how many Leagues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * League upsert
   */
  export type LeagueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * The filter to search for the League to update in case it exists.
     */
    where: LeagueWhereUniqueInput
    /**
     * In case the League found by the `where` argument doesn't exist, create a new League with this data.
     */
    create: XOR<LeagueCreateInput, LeagueUncheckedCreateInput>
    /**
     * In case the League was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeagueUpdateInput, LeagueUncheckedUpdateInput>
  }

  /**
   * League delete
   */
  export type LeagueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    /**
     * Filter which League to delete.
     */
    where: LeagueWhereUniqueInput
  }

  /**
   * League deleteMany
   */
  export type LeagueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leagues to delete
     */
    where?: LeagueWhereInput
    /**
     * Limit how many Leagues to delete.
     */
    limit?: number
  }

  /**
   * League.teams
   */
  export type League$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * League.leagueSettings
   */
  export type League$leagueSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueSettings
     */
    select?: LeagueSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueSettings
     */
    omit?: LeagueSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueSettingsInclude<ExtArgs> | null
    where?: LeagueSettingsWhereInput
  }

  /**
   * League.scoringSettings
   */
  export type League$scoringSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringSettings
     */
    select?: ScoringSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringSettings
     */
    omit?: ScoringSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringSettingsInclude<ExtArgs> | null
    where?: ScoringSettingsWhereInput
  }

  /**
   * League.rosterSettings
   */
  export type League$rosterSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterSettings
     */
    select?: RosterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterSettings
     */
    omit?: RosterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterSettingsInclude<ExtArgs> | null
    where?: RosterSettingsWhereInput
  }

  /**
   * League.draft
   */
  export type League$draftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    where?: DraftWhereInput
  }

  /**
   * League.games
   */
  export type League$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * League.transactions
   */
  export type League$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * League.messages
   */
  export type League$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * League.tradeOffers
   */
  export type League$tradeOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferInclude<ExtArgs> | null
    where?: TradeOfferWhereInput
    orderBy?: TradeOfferOrderByWithRelationInput | TradeOfferOrderByWithRelationInput[]
    cursor?: TradeOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeOfferScalarFieldEnum | TradeOfferScalarFieldEnum[]
  }

  /**
   * League without action
   */
  export type LeagueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
  }


  /**
   * Model LeagueSettings
   */

  export type AggregateLeagueSettings = {
    _count: LeagueSettingsCountAggregateOutputType | null
    _avg: LeagueSettingsAvgAggregateOutputType | null
    _sum: LeagueSettingsSumAggregateOutputType | null
    _min: LeagueSettingsMinAggregateOutputType | null
    _max: LeagueSettingsMaxAggregateOutputType | null
  }

  export type LeagueSettingsAvgAggregateOutputType = {
    playoffTeams: number | null
    playoffStartWeek: number | null
  }

  export type LeagueSettingsSumAggregateOutputType = {
    playoffTeams: number | null
    playoffStartWeek: number | null
  }

  export type LeagueSettingsMinAggregateOutputType = {
    id: string | null
    leagueId: string | null
    scoringType: $Enums.ScoringType | null
    hasDivisions: boolean | null
    playoffTeams: number | null
    playoffStartWeek: number | null
    canTradeDraftPicks: boolean | null
    tradeReviewType: $Enums.TradeReviewType | null
    waiverType: $Enums.WaiverType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeagueSettingsMaxAggregateOutputType = {
    id: string | null
    leagueId: string | null
    scoringType: $Enums.ScoringType | null
    hasDivisions: boolean | null
    playoffTeams: number | null
    playoffStartWeek: number | null
    canTradeDraftPicks: boolean | null
    tradeReviewType: $Enums.TradeReviewType | null
    waiverType: $Enums.WaiverType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeagueSettingsCountAggregateOutputType = {
    id: number
    leagueId: number
    scoringType: number
    hasDivisions: number
    playoffTeams: number
    playoffStartWeek: number
    canTradeDraftPicks: number
    tradeReviewType: number
    waiverType: number
    cantCutList: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeagueSettingsAvgAggregateInputType = {
    playoffTeams?: true
    playoffStartWeek?: true
  }

  export type LeagueSettingsSumAggregateInputType = {
    playoffTeams?: true
    playoffStartWeek?: true
  }

  export type LeagueSettingsMinAggregateInputType = {
    id?: true
    leagueId?: true
    scoringType?: true
    hasDivisions?: true
    playoffTeams?: true
    playoffStartWeek?: true
    canTradeDraftPicks?: true
    tradeReviewType?: true
    waiverType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeagueSettingsMaxAggregateInputType = {
    id?: true
    leagueId?: true
    scoringType?: true
    hasDivisions?: true
    playoffTeams?: true
    playoffStartWeek?: true
    canTradeDraftPicks?: true
    tradeReviewType?: true
    waiverType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeagueSettingsCountAggregateInputType = {
    id?: true
    leagueId?: true
    scoringType?: true
    hasDivisions?: true
    playoffTeams?: true
    playoffStartWeek?: true
    canTradeDraftPicks?: true
    tradeReviewType?: true
    waiverType?: true
    cantCutList?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeagueSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeagueSettings to aggregate.
     */
    where?: LeagueSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeagueSettings to fetch.
     */
    orderBy?: LeagueSettingsOrderByWithRelationInput | LeagueSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeagueSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeagueSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeagueSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeagueSettings
    **/
    _count?: true | LeagueSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeagueSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeagueSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeagueSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeagueSettingsMaxAggregateInputType
  }

  export type GetLeagueSettingsAggregateType<T extends LeagueSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateLeagueSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeagueSettings[P]>
      : GetScalarType<T[P], AggregateLeagueSettings[P]>
  }




  export type LeagueSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeagueSettingsWhereInput
    orderBy?: LeagueSettingsOrderByWithAggregationInput | LeagueSettingsOrderByWithAggregationInput[]
    by: LeagueSettingsScalarFieldEnum[] | LeagueSettingsScalarFieldEnum
    having?: LeagueSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeagueSettingsCountAggregateInputType | true
    _avg?: LeagueSettingsAvgAggregateInputType
    _sum?: LeagueSettingsSumAggregateInputType
    _min?: LeagueSettingsMinAggregateInputType
    _max?: LeagueSettingsMaxAggregateInputType
  }

  export type LeagueSettingsGroupByOutputType = {
    id: string
    leagueId: string
    scoringType: $Enums.ScoringType
    hasDivisions: boolean
    playoffTeams: number
    playoffStartWeek: number
    canTradeDraftPicks: boolean
    tradeReviewType: $Enums.TradeReviewType
    waiverType: $Enums.WaiverType
    cantCutList: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: LeagueSettingsCountAggregateOutputType | null
    _avg: LeagueSettingsAvgAggregateOutputType | null
    _sum: LeagueSettingsSumAggregateOutputType | null
    _min: LeagueSettingsMinAggregateOutputType | null
    _max: LeagueSettingsMaxAggregateOutputType | null
  }

  type GetLeagueSettingsGroupByPayload<T extends LeagueSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeagueSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeagueSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeagueSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], LeagueSettingsGroupByOutputType[P]>
        }
      >
    >


  export type LeagueSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    scoringType?: boolean
    hasDivisions?: boolean
    playoffTeams?: boolean
    playoffStartWeek?: boolean
    canTradeDraftPicks?: boolean
    tradeReviewType?: boolean
    waiverType?: boolean
    cantCutList?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leagueSettings"]>

  export type LeagueSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    scoringType?: boolean
    hasDivisions?: boolean
    playoffTeams?: boolean
    playoffStartWeek?: boolean
    canTradeDraftPicks?: boolean
    tradeReviewType?: boolean
    waiverType?: boolean
    cantCutList?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leagueSettings"]>

  export type LeagueSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    scoringType?: boolean
    hasDivisions?: boolean
    playoffTeams?: boolean
    playoffStartWeek?: boolean
    canTradeDraftPicks?: boolean
    tradeReviewType?: boolean
    waiverType?: boolean
    cantCutList?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leagueSettings"]>

  export type LeagueSettingsSelectScalar = {
    id?: boolean
    leagueId?: boolean
    scoringType?: boolean
    hasDivisions?: boolean
    playoffTeams?: boolean
    playoffStartWeek?: boolean
    canTradeDraftPicks?: boolean
    tradeReviewType?: boolean
    waiverType?: boolean
    cantCutList?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeagueSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leagueId" | "scoringType" | "hasDivisions" | "playoffTeams" | "playoffStartWeek" | "canTradeDraftPicks" | "tradeReviewType" | "waiverType" | "cantCutList" | "createdAt" | "updatedAt", ExtArgs["result"]["leagueSettings"]>
  export type LeagueSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }
  export type LeagueSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }
  export type LeagueSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }

  export type $LeagueSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeagueSettings"
    objects: {
      league: Prisma.$LeaguePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leagueId: string
      scoringType: $Enums.ScoringType
      hasDivisions: boolean
      playoffTeams: number
      playoffStartWeek: number
      canTradeDraftPicks: boolean
      tradeReviewType: $Enums.TradeReviewType
      waiverType: $Enums.WaiverType
      cantCutList: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leagueSettings"]>
    composites: {}
  }

  type LeagueSettingsGetPayload<S extends boolean | null | undefined | LeagueSettingsDefaultArgs> = $Result.GetResult<Prisma.$LeagueSettingsPayload, S>

  type LeagueSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeagueSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeagueSettingsCountAggregateInputType | true
    }

  export interface LeagueSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeagueSettings'], meta: { name: 'LeagueSettings' } }
    /**
     * Find zero or one LeagueSettings that matches the filter.
     * @param {LeagueSettingsFindUniqueArgs} args - Arguments to find a LeagueSettings
     * @example
     * // Get one LeagueSettings
     * const leagueSettings = await prisma.leagueSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeagueSettingsFindUniqueArgs>(args: SelectSubset<T, LeagueSettingsFindUniqueArgs<ExtArgs>>): Prisma__LeagueSettingsClient<$Result.GetResult<Prisma.$LeagueSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeagueSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeagueSettingsFindUniqueOrThrowArgs} args - Arguments to find a LeagueSettings
     * @example
     * // Get one LeagueSettings
     * const leagueSettings = await prisma.leagueSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeagueSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, LeagueSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeagueSettingsClient<$Result.GetResult<Prisma.$LeagueSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeagueSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueSettingsFindFirstArgs} args - Arguments to find a LeagueSettings
     * @example
     * // Get one LeagueSettings
     * const leagueSettings = await prisma.leagueSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeagueSettingsFindFirstArgs>(args?: SelectSubset<T, LeagueSettingsFindFirstArgs<ExtArgs>>): Prisma__LeagueSettingsClient<$Result.GetResult<Prisma.$LeagueSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeagueSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueSettingsFindFirstOrThrowArgs} args - Arguments to find a LeagueSettings
     * @example
     * // Get one LeagueSettings
     * const leagueSettings = await prisma.leagueSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeagueSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, LeagueSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeagueSettingsClient<$Result.GetResult<Prisma.$LeagueSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeagueSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeagueSettings
     * const leagueSettings = await prisma.leagueSettings.findMany()
     * 
     * // Get first 10 LeagueSettings
     * const leagueSettings = await prisma.leagueSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leagueSettingsWithIdOnly = await prisma.leagueSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeagueSettingsFindManyArgs>(args?: SelectSubset<T, LeagueSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeagueSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeagueSettings.
     * @param {LeagueSettingsCreateArgs} args - Arguments to create a LeagueSettings.
     * @example
     * // Create one LeagueSettings
     * const LeagueSettings = await prisma.leagueSettings.create({
     *   data: {
     *     // ... data to create a LeagueSettings
     *   }
     * })
     * 
     */
    create<T extends LeagueSettingsCreateArgs>(args: SelectSubset<T, LeagueSettingsCreateArgs<ExtArgs>>): Prisma__LeagueSettingsClient<$Result.GetResult<Prisma.$LeagueSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeagueSettings.
     * @param {LeagueSettingsCreateManyArgs} args - Arguments to create many LeagueSettings.
     * @example
     * // Create many LeagueSettings
     * const leagueSettings = await prisma.leagueSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeagueSettingsCreateManyArgs>(args?: SelectSubset<T, LeagueSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeagueSettings and returns the data saved in the database.
     * @param {LeagueSettingsCreateManyAndReturnArgs} args - Arguments to create many LeagueSettings.
     * @example
     * // Create many LeagueSettings
     * const leagueSettings = await prisma.leagueSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeagueSettings and only return the `id`
     * const leagueSettingsWithIdOnly = await prisma.leagueSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeagueSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, LeagueSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeagueSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeagueSettings.
     * @param {LeagueSettingsDeleteArgs} args - Arguments to delete one LeagueSettings.
     * @example
     * // Delete one LeagueSettings
     * const LeagueSettings = await prisma.leagueSettings.delete({
     *   where: {
     *     // ... filter to delete one LeagueSettings
     *   }
     * })
     * 
     */
    delete<T extends LeagueSettingsDeleteArgs>(args: SelectSubset<T, LeagueSettingsDeleteArgs<ExtArgs>>): Prisma__LeagueSettingsClient<$Result.GetResult<Prisma.$LeagueSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeagueSettings.
     * @param {LeagueSettingsUpdateArgs} args - Arguments to update one LeagueSettings.
     * @example
     * // Update one LeagueSettings
     * const leagueSettings = await prisma.leagueSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeagueSettingsUpdateArgs>(args: SelectSubset<T, LeagueSettingsUpdateArgs<ExtArgs>>): Prisma__LeagueSettingsClient<$Result.GetResult<Prisma.$LeagueSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeagueSettings.
     * @param {LeagueSettingsDeleteManyArgs} args - Arguments to filter LeagueSettings to delete.
     * @example
     * // Delete a few LeagueSettings
     * const { count } = await prisma.leagueSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeagueSettingsDeleteManyArgs>(args?: SelectSubset<T, LeagueSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeagueSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeagueSettings
     * const leagueSettings = await prisma.leagueSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeagueSettingsUpdateManyArgs>(args: SelectSubset<T, LeagueSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeagueSettings and returns the data updated in the database.
     * @param {LeagueSettingsUpdateManyAndReturnArgs} args - Arguments to update many LeagueSettings.
     * @example
     * // Update many LeagueSettings
     * const leagueSettings = await prisma.leagueSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeagueSettings and only return the `id`
     * const leagueSettingsWithIdOnly = await prisma.leagueSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeagueSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, LeagueSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeagueSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeagueSettings.
     * @param {LeagueSettingsUpsertArgs} args - Arguments to update or create a LeagueSettings.
     * @example
     * // Update or create a LeagueSettings
     * const leagueSettings = await prisma.leagueSettings.upsert({
     *   create: {
     *     // ... data to create a LeagueSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeagueSettings we want to update
     *   }
     * })
     */
    upsert<T extends LeagueSettingsUpsertArgs>(args: SelectSubset<T, LeagueSettingsUpsertArgs<ExtArgs>>): Prisma__LeagueSettingsClient<$Result.GetResult<Prisma.$LeagueSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeagueSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueSettingsCountArgs} args - Arguments to filter LeagueSettings to count.
     * @example
     * // Count the number of LeagueSettings
     * const count = await prisma.leagueSettings.count({
     *   where: {
     *     // ... the filter for the LeagueSettings we want to count
     *   }
     * })
    **/
    count<T extends LeagueSettingsCountArgs>(
      args?: Subset<T, LeagueSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeagueSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeagueSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeagueSettingsAggregateArgs>(args: Subset<T, LeagueSettingsAggregateArgs>): Prisma.PrismaPromise<GetLeagueSettingsAggregateType<T>>

    /**
     * Group by LeagueSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeagueSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeagueSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeagueSettingsGroupByArgs['orderBy'] }
        : { orderBy?: LeagueSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeagueSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeagueSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeagueSettings model
   */
  readonly fields: LeagueSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeagueSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeagueSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    league<T extends LeagueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeagueDefaultArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeagueSettings model
   */
  interface LeagueSettingsFieldRefs {
    readonly id: FieldRef<"LeagueSettings", 'String'>
    readonly leagueId: FieldRef<"LeagueSettings", 'String'>
    readonly scoringType: FieldRef<"LeagueSettings", 'ScoringType'>
    readonly hasDivisions: FieldRef<"LeagueSettings", 'Boolean'>
    readonly playoffTeams: FieldRef<"LeagueSettings", 'Int'>
    readonly playoffStartWeek: FieldRef<"LeagueSettings", 'Int'>
    readonly canTradeDraftPicks: FieldRef<"LeagueSettings", 'Boolean'>
    readonly tradeReviewType: FieldRef<"LeagueSettings", 'TradeReviewType'>
    readonly waiverType: FieldRef<"LeagueSettings", 'WaiverType'>
    readonly cantCutList: FieldRef<"LeagueSettings", 'Json'>
    readonly createdAt: FieldRef<"LeagueSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"LeagueSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeagueSettings findUnique
   */
  export type LeagueSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueSettings
     */
    select?: LeagueSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueSettings
     */
    omit?: LeagueSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueSettingsInclude<ExtArgs> | null
    /**
     * Filter, which LeagueSettings to fetch.
     */
    where: LeagueSettingsWhereUniqueInput
  }

  /**
   * LeagueSettings findUniqueOrThrow
   */
  export type LeagueSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueSettings
     */
    select?: LeagueSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueSettings
     */
    omit?: LeagueSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueSettingsInclude<ExtArgs> | null
    /**
     * Filter, which LeagueSettings to fetch.
     */
    where: LeagueSettingsWhereUniqueInput
  }

  /**
   * LeagueSettings findFirst
   */
  export type LeagueSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueSettings
     */
    select?: LeagueSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueSettings
     */
    omit?: LeagueSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueSettingsInclude<ExtArgs> | null
    /**
     * Filter, which LeagueSettings to fetch.
     */
    where?: LeagueSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeagueSettings to fetch.
     */
    orderBy?: LeagueSettingsOrderByWithRelationInput | LeagueSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeagueSettings.
     */
    cursor?: LeagueSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeagueSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeagueSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeagueSettings.
     */
    distinct?: LeagueSettingsScalarFieldEnum | LeagueSettingsScalarFieldEnum[]
  }

  /**
   * LeagueSettings findFirstOrThrow
   */
  export type LeagueSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueSettings
     */
    select?: LeagueSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueSettings
     */
    omit?: LeagueSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueSettingsInclude<ExtArgs> | null
    /**
     * Filter, which LeagueSettings to fetch.
     */
    where?: LeagueSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeagueSettings to fetch.
     */
    orderBy?: LeagueSettingsOrderByWithRelationInput | LeagueSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeagueSettings.
     */
    cursor?: LeagueSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeagueSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeagueSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeagueSettings.
     */
    distinct?: LeagueSettingsScalarFieldEnum | LeagueSettingsScalarFieldEnum[]
  }

  /**
   * LeagueSettings findMany
   */
  export type LeagueSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueSettings
     */
    select?: LeagueSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueSettings
     */
    omit?: LeagueSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueSettingsInclude<ExtArgs> | null
    /**
     * Filter, which LeagueSettings to fetch.
     */
    where?: LeagueSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeagueSettings to fetch.
     */
    orderBy?: LeagueSettingsOrderByWithRelationInput | LeagueSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeagueSettings.
     */
    cursor?: LeagueSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeagueSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeagueSettings.
     */
    skip?: number
    distinct?: LeagueSettingsScalarFieldEnum | LeagueSettingsScalarFieldEnum[]
  }

  /**
   * LeagueSettings create
   */
  export type LeagueSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueSettings
     */
    select?: LeagueSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueSettings
     */
    omit?: LeagueSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a LeagueSettings.
     */
    data: XOR<LeagueSettingsCreateInput, LeagueSettingsUncheckedCreateInput>
  }

  /**
   * LeagueSettings createMany
   */
  export type LeagueSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeagueSettings.
     */
    data: LeagueSettingsCreateManyInput | LeagueSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeagueSettings createManyAndReturn
   */
  export type LeagueSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueSettings
     */
    select?: LeagueSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueSettings
     */
    omit?: LeagueSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many LeagueSettings.
     */
    data: LeagueSettingsCreateManyInput | LeagueSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeagueSettings update
   */
  export type LeagueSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueSettings
     */
    select?: LeagueSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueSettings
     */
    omit?: LeagueSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a LeagueSettings.
     */
    data: XOR<LeagueSettingsUpdateInput, LeagueSettingsUncheckedUpdateInput>
    /**
     * Choose, which LeagueSettings to update.
     */
    where: LeagueSettingsWhereUniqueInput
  }

  /**
   * LeagueSettings updateMany
   */
  export type LeagueSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeagueSettings.
     */
    data: XOR<LeagueSettingsUpdateManyMutationInput, LeagueSettingsUncheckedUpdateManyInput>
    /**
     * Filter which LeagueSettings to update
     */
    where?: LeagueSettingsWhereInput
    /**
     * Limit how many LeagueSettings to update.
     */
    limit?: number
  }

  /**
   * LeagueSettings updateManyAndReturn
   */
  export type LeagueSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueSettings
     */
    select?: LeagueSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueSettings
     */
    omit?: LeagueSettingsOmit<ExtArgs> | null
    /**
     * The data used to update LeagueSettings.
     */
    data: XOR<LeagueSettingsUpdateManyMutationInput, LeagueSettingsUncheckedUpdateManyInput>
    /**
     * Filter which LeagueSettings to update
     */
    where?: LeagueSettingsWhereInput
    /**
     * Limit how many LeagueSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeagueSettings upsert
   */
  export type LeagueSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueSettings
     */
    select?: LeagueSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueSettings
     */
    omit?: LeagueSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the LeagueSettings to update in case it exists.
     */
    where: LeagueSettingsWhereUniqueInput
    /**
     * In case the LeagueSettings found by the `where` argument doesn't exist, create a new LeagueSettings with this data.
     */
    create: XOR<LeagueSettingsCreateInput, LeagueSettingsUncheckedCreateInput>
    /**
     * In case the LeagueSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeagueSettingsUpdateInput, LeagueSettingsUncheckedUpdateInput>
  }

  /**
   * LeagueSettings delete
   */
  export type LeagueSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueSettings
     */
    select?: LeagueSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueSettings
     */
    omit?: LeagueSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueSettingsInclude<ExtArgs> | null
    /**
     * Filter which LeagueSettings to delete.
     */
    where: LeagueSettingsWhereUniqueInput
  }

  /**
   * LeagueSettings deleteMany
   */
  export type LeagueSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeagueSettings to delete
     */
    where?: LeagueSettingsWhereInput
    /**
     * Limit how many LeagueSettings to delete.
     */
    limit?: number
  }

  /**
   * LeagueSettings without action
   */
  export type LeagueSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeagueSettings
     */
    select?: LeagueSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeagueSettings
     */
    omit?: LeagueSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueSettingsInclude<ExtArgs> | null
  }


  /**
   * Model ScoringSettings
   */

  export type AggregateScoringSettings = {
    _count: ScoringSettingsCountAggregateOutputType | null
    _avg: ScoringSettingsAvgAggregateOutputType | null
    _sum: ScoringSettingsSumAggregateOutputType | null
    _min: ScoringSettingsMinAggregateOutputType | null
    _max: ScoringSettingsMaxAggregateOutputType | null
  }

  export type ScoringSettingsAvgAggregateOutputType = {
    passingYards: Decimal | null
    passingTds: Decimal | null
    passingInts: Decimal | null
    rushingYards: Decimal | null
    rushingTds: Decimal | null
    receivingYards: Decimal | null
    receivingTds: Decimal | null
    receptions: Decimal | null
    fumbles: Decimal | null
    fieldGoals: Decimal | null
    extraPoints: Decimal | null
    sacks: Decimal | null
    interceptions: Decimal | null
    fumbleRecoveries: Decimal | null
    safeties: Decimal | null
    defensiveTds: Decimal | null
    pointsAllowed0: Decimal | null
    pointsAllowed1to6: Decimal | null
    pointsAllowed7to13: Decimal | null
    pointsAllowed14to20: Decimal | null
    pointsAllowed21to27: Decimal | null
    pointsAllowed28plus: Decimal | null
  }

  export type ScoringSettingsSumAggregateOutputType = {
    passingYards: Decimal | null
    passingTds: Decimal | null
    passingInts: Decimal | null
    rushingYards: Decimal | null
    rushingTds: Decimal | null
    receivingYards: Decimal | null
    receivingTds: Decimal | null
    receptions: Decimal | null
    fumbles: Decimal | null
    fieldGoals: Decimal | null
    extraPoints: Decimal | null
    sacks: Decimal | null
    interceptions: Decimal | null
    fumbleRecoveries: Decimal | null
    safeties: Decimal | null
    defensiveTds: Decimal | null
    pointsAllowed0: Decimal | null
    pointsAllowed1to6: Decimal | null
    pointsAllowed7to13: Decimal | null
    pointsAllowed14to20: Decimal | null
    pointsAllowed21to27: Decimal | null
    pointsAllowed28plus: Decimal | null
  }

  export type ScoringSettingsMinAggregateOutputType = {
    id: string | null
    leagueId: string | null
    passingYards: Decimal | null
    passingTds: Decimal | null
    passingInts: Decimal | null
    rushingYards: Decimal | null
    rushingTds: Decimal | null
    receivingYards: Decimal | null
    receivingTds: Decimal | null
    receptions: Decimal | null
    fumbles: Decimal | null
    fieldGoals: Decimal | null
    extraPoints: Decimal | null
    sacks: Decimal | null
    interceptions: Decimal | null
    fumbleRecoveries: Decimal | null
    safeties: Decimal | null
    defensiveTds: Decimal | null
    pointsAllowed0: Decimal | null
    pointsAllowed1to6: Decimal | null
    pointsAllowed7to13: Decimal | null
    pointsAllowed14to20: Decimal | null
    pointsAllowed21to27: Decimal | null
    pointsAllowed28plus: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScoringSettingsMaxAggregateOutputType = {
    id: string | null
    leagueId: string | null
    passingYards: Decimal | null
    passingTds: Decimal | null
    passingInts: Decimal | null
    rushingYards: Decimal | null
    rushingTds: Decimal | null
    receivingYards: Decimal | null
    receivingTds: Decimal | null
    receptions: Decimal | null
    fumbles: Decimal | null
    fieldGoals: Decimal | null
    extraPoints: Decimal | null
    sacks: Decimal | null
    interceptions: Decimal | null
    fumbleRecoveries: Decimal | null
    safeties: Decimal | null
    defensiveTds: Decimal | null
    pointsAllowed0: Decimal | null
    pointsAllowed1to6: Decimal | null
    pointsAllowed7to13: Decimal | null
    pointsAllowed14to20: Decimal | null
    pointsAllowed21to27: Decimal | null
    pointsAllowed28plus: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScoringSettingsCountAggregateOutputType = {
    id: number
    leagueId: number
    passingYards: number
    passingTds: number
    passingInts: number
    rushingYards: number
    rushingTds: number
    receivingYards: number
    receivingTds: number
    receptions: number
    fumbles: number
    fieldGoals: number
    extraPoints: number
    sacks: number
    interceptions: number
    fumbleRecoveries: number
    safeties: number
    defensiveTds: number
    pointsAllowed0: number
    pointsAllowed1to6: number
    pointsAllowed7to13: number
    pointsAllowed14to20: number
    pointsAllowed21to27: number
    pointsAllowed28plus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScoringSettingsAvgAggregateInputType = {
    passingYards?: true
    passingTds?: true
    passingInts?: true
    rushingYards?: true
    rushingTds?: true
    receivingYards?: true
    receivingTds?: true
    receptions?: true
    fumbles?: true
    fieldGoals?: true
    extraPoints?: true
    sacks?: true
    interceptions?: true
    fumbleRecoveries?: true
    safeties?: true
    defensiveTds?: true
    pointsAllowed0?: true
    pointsAllowed1to6?: true
    pointsAllowed7to13?: true
    pointsAllowed14to20?: true
    pointsAllowed21to27?: true
    pointsAllowed28plus?: true
  }

  export type ScoringSettingsSumAggregateInputType = {
    passingYards?: true
    passingTds?: true
    passingInts?: true
    rushingYards?: true
    rushingTds?: true
    receivingYards?: true
    receivingTds?: true
    receptions?: true
    fumbles?: true
    fieldGoals?: true
    extraPoints?: true
    sacks?: true
    interceptions?: true
    fumbleRecoveries?: true
    safeties?: true
    defensiveTds?: true
    pointsAllowed0?: true
    pointsAllowed1to6?: true
    pointsAllowed7to13?: true
    pointsAllowed14to20?: true
    pointsAllowed21to27?: true
    pointsAllowed28plus?: true
  }

  export type ScoringSettingsMinAggregateInputType = {
    id?: true
    leagueId?: true
    passingYards?: true
    passingTds?: true
    passingInts?: true
    rushingYards?: true
    rushingTds?: true
    receivingYards?: true
    receivingTds?: true
    receptions?: true
    fumbles?: true
    fieldGoals?: true
    extraPoints?: true
    sacks?: true
    interceptions?: true
    fumbleRecoveries?: true
    safeties?: true
    defensiveTds?: true
    pointsAllowed0?: true
    pointsAllowed1to6?: true
    pointsAllowed7to13?: true
    pointsAllowed14to20?: true
    pointsAllowed21to27?: true
    pointsAllowed28plus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScoringSettingsMaxAggregateInputType = {
    id?: true
    leagueId?: true
    passingYards?: true
    passingTds?: true
    passingInts?: true
    rushingYards?: true
    rushingTds?: true
    receivingYards?: true
    receivingTds?: true
    receptions?: true
    fumbles?: true
    fieldGoals?: true
    extraPoints?: true
    sacks?: true
    interceptions?: true
    fumbleRecoveries?: true
    safeties?: true
    defensiveTds?: true
    pointsAllowed0?: true
    pointsAllowed1to6?: true
    pointsAllowed7to13?: true
    pointsAllowed14to20?: true
    pointsAllowed21to27?: true
    pointsAllowed28plus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScoringSettingsCountAggregateInputType = {
    id?: true
    leagueId?: true
    passingYards?: true
    passingTds?: true
    passingInts?: true
    rushingYards?: true
    rushingTds?: true
    receivingYards?: true
    receivingTds?: true
    receptions?: true
    fumbles?: true
    fieldGoals?: true
    extraPoints?: true
    sacks?: true
    interceptions?: true
    fumbleRecoveries?: true
    safeties?: true
    defensiveTds?: true
    pointsAllowed0?: true
    pointsAllowed1to6?: true
    pointsAllowed7to13?: true
    pointsAllowed14to20?: true
    pointsAllowed21to27?: true
    pointsAllowed28plus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScoringSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScoringSettings to aggregate.
     */
    where?: ScoringSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoringSettings to fetch.
     */
    orderBy?: ScoringSettingsOrderByWithRelationInput | ScoringSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScoringSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoringSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoringSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScoringSettings
    **/
    _count?: true | ScoringSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScoringSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScoringSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScoringSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScoringSettingsMaxAggregateInputType
  }

  export type GetScoringSettingsAggregateType<T extends ScoringSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateScoringSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScoringSettings[P]>
      : GetScalarType<T[P], AggregateScoringSettings[P]>
  }




  export type ScoringSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoringSettingsWhereInput
    orderBy?: ScoringSettingsOrderByWithAggregationInput | ScoringSettingsOrderByWithAggregationInput[]
    by: ScoringSettingsScalarFieldEnum[] | ScoringSettingsScalarFieldEnum
    having?: ScoringSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScoringSettingsCountAggregateInputType | true
    _avg?: ScoringSettingsAvgAggregateInputType
    _sum?: ScoringSettingsSumAggregateInputType
    _min?: ScoringSettingsMinAggregateInputType
    _max?: ScoringSettingsMaxAggregateInputType
  }

  export type ScoringSettingsGroupByOutputType = {
    id: string
    leagueId: string
    passingYards: Decimal
    passingTds: Decimal
    passingInts: Decimal
    rushingYards: Decimal
    rushingTds: Decimal
    receivingYards: Decimal
    receivingTds: Decimal
    receptions: Decimal
    fumbles: Decimal
    fieldGoals: Decimal
    extraPoints: Decimal
    sacks: Decimal
    interceptions: Decimal
    fumbleRecoveries: Decimal
    safeties: Decimal
    defensiveTds: Decimal
    pointsAllowed0: Decimal
    pointsAllowed1to6: Decimal
    pointsAllowed7to13: Decimal
    pointsAllowed14to20: Decimal
    pointsAllowed21to27: Decimal
    pointsAllowed28plus: Decimal
    createdAt: Date
    updatedAt: Date
    _count: ScoringSettingsCountAggregateOutputType | null
    _avg: ScoringSettingsAvgAggregateOutputType | null
    _sum: ScoringSettingsSumAggregateOutputType | null
    _min: ScoringSettingsMinAggregateOutputType | null
    _max: ScoringSettingsMaxAggregateOutputType | null
  }

  type GetScoringSettingsGroupByPayload<T extends ScoringSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScoringSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScoringSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScoringSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], ScoringSettingsGroupByOutputType[P]>
        }
      >
    >


  export type ScoringSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    passingYards?: boolean
    passingTds?: boolean
    passingInts?: boolean
    rushingYards?: boolean
    rushingTds?: boolean
    receivingYards?: boolean
    receivingTds?: boolean
    receptions?: boolean
    fumbles?: boolean
    fieldGoals?: boolean
    extraPoints?: boolean
    sacks?: boolean
    interceptions?: boolean
    fumbleRecoveries?: boolean
    safeties?: boolean
    defensiveTds?: boolean
    pointsAllowed0?: boolean
    pointsAllowed1to6?: boolean
    pointsAllowed7to13?: boolean
    pointsAllowed14to20?: boolean
    pointsAllowed21to27?: boolean
    pointsAllowed28plus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scoringSettings"]>

  export type ScoringSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    passingYards?: boolean
    passingTds?: boolean
    passingInts?: boolean
    rushingYards?: boolean
    rushingTds?: boolean
    receivingYards?: boolean
    receivingTds?: boolean
    receptions?: boolean
    fumbles?: boolean
    fieldGoals?: boolean
    extraPoints?: boolean
    sacks?: boolean
    interceptions?: boolean
    fumbleRecoveries?: boolean
    safeties?: boolean
    defensiveTds?: boolean
    pointsAllowed0?: boolean
    pointsAllowed1to6?: boolean
    pointsAllowed7to13?: boolean
    pointsAllowed14to20?: boolean
    pointsAllowed21to27?: boolean
    pointsAllowed28plus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scoringSettings"]>

  export type ScoringSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    passingYards?: boolean
    passingTds?: boolean
    passingInts?: boolean
    rushingYards?: boolean
    rushingTds?: boolean
    receivingYards?: boolean
    receivingTds?: boolean
    receptions?: boolean
    fumbles?: boolean
    fieldGoals?: boolean
    extraPoints?: boolean
    sacks?: boolean
    interceptions?: boolean
    fumbleRecoveries?: boolean
    safeties?: boolean
    defensiveTds?: boolean
    pointsAllowed0?: boolean
    pointsAllowed1to6?: boolean
    pointsAllowed7to13?: boolean
    pointsAllowed14to20?: boolean
    pointsAllowed21to27?: boolean
    pointsAllowed28plus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scoringSettings"]>

  export type ScoringSettingsSelectScalar = {
    id?: boolean
    leagueId?: boolean
    passingYards?: boolean
    passingTds?: boolean
    passingInts?: boolean
    rushingYards?: boolean
    rushingTds?: boolean
    receivingYards?: boolean
    receivingTds?: boolean
    receptions?: boolean
    fumbles?: boolean
    fieldGoals?: boolean
    extraPoints?: boolean
    sacks?: boolean
    interceptions?: boolean
    fumbleRecoveries?: boolean
    safeties?: boolean
    defensiveTds?: boolean
    pointsAllowed0?: boolean
    pointsAllowed1to6?: boolean
    pointsAllowed7to13?: boolean
    pointsAllowed14to20?: boolean
    pointsAllowed21to27?: boolean
    pointsAllowed28plus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScoringSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leagueId" | "passingYards" | "passingTds" | "passingInts" | "rushingYards" | "rushingTds" | "receivingYards" | "receivingTds" | "receptions" | "fumbles" | "fieldGoals" | "extraPoints" | "sacks" | "interceptions" | "fumbleRecoveries" | "safeties" | "defensiveTds" | "pointsAllowed0" | "pointsAllowed1to6" | "pointsAllowed7to13" | "pointsAllowed14to20" | "pointsAllowed21to27" | "pointsAllowed28plus" | "createdAt" | "updatedAt", ExtArgs["result"]["scoringSettings"]>
  export type ScoringSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }
  export type ScoringSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }
  export type ScoringSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }

  export type $ScoringSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScoringSettings"
    objects: {
      league: Prisma.$LeaguePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leagueId: string
      passingYards: Prisma.Decimal
      passingTds: Prisma.Decimal
      passingInts: Prisma.Decimal
      rushingYards: Prisma.Decimal
      rushingTds: Prisma.Decimal
      receivingYards: Prisma.Decimal
      receivingTds: Prisma.Decimal
      receptions: Prisma.Decimal
      fumbles: Prisma.Decimal
      fieldGoals: Prisma.Decimal
      extraPoints: Prisma.Decimal
      sacks: Prisma.Decimal
      interceptions: Prisma.Decimal
      fumbleRecoveries: Prisma.Decimal
      safeties: Prisma.Decimal
      defensiveTds: Prisma.Decimal
      pointsAllowed0: Prisma.Decimal
      pointsAllowed1to6: Prisma.Decimal
      pointsAllowed7to13: Prisma.Decimal
      pointsAllowed14to20: Prisma.Decimal
      pointsAllowed21to27: Prisma.Decimal
      pointsAllowed28plus: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scoringSettings"]>
    composites: {}
  }

  type ScoringSettingsGetPayload<S extends boolean | null | undefined | ScoringSettingsDefaultArgs> = $Result.GetResult<Prisma.$ScoringSettingsPayload, S>

  type ScoringSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScoringSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScoringSettingsCountAggregateInputType | true
    }

  export interface ScoringSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScoringSettings'], meta: { name: 'ScoringSettings' } }
    /**
     * Find zero or one ScoringSettings that matches the filter.
     * @param {ScoringSettingsFindUniqueArgs} args - Arguments to find a ScoringSettings
     * @example
     * // Get one ScoringSettings
     * const scoringSettings = await prisma.scoringSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScoringSettingsFindUniqueArgs>(args: SelectSubset<T, ScoringSettingsFindUniqueArgs<ExtArgs>>): Prisma__ScoringSettingsClient<$Result.GetResult<Prisma.$ScoringSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScoringSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScoringSettingsFindUniqueOrThrowArgs} args - Arguments to find a ScoringSettings
     * @example
     * // Get one ScoringSettings
     * const scoringSettings = await prisma.scoringSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScoringSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, ScoringSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScoringSettingsClient<$Result.GetResult<Prisma.$ScoringSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScoringSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoringSettingsFindFirstArgs} args - Arguments to find a ScoringSettings
     * @example
     * // Get one ScoringSettings
     * const scoringSettings = await prisma.scoringSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScoringSettingsFindFirstArgs>(args?: SelectSubset<T, ScoringSettingsFindFirstArgs<ExtArgs>>): Prisma__ScoringSettingsClient<$Result.GetResult<Prisma.$ScoringSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScoringSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoringSettingsFindFirstOrThrowArgs} args - Arguments to find a ScoringSettings
     * @example
     * // Get one ScoringSettings
     * const scoringSettings = await prisma.scoringSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScoringSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, ScoringSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScoringSettingsClient<$Result.GetResult<Prisma.$ScoringSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScoringSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoringSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScoringSettings
     * const scoringSettings = await prisma.scoringSettings.findMany()
     * 
     * // Get first 10 ScoringSettings
     * const scoringSettings = await prisma.scoringSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scoringSettingsWithIdOnly = await prisma.scoringSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScoringSettingsFindManyArgs>(args?: SelectSubset<T, ScoringSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScoringSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScoringSettings.
     * @param {ScoringSettingsCreateArgs} args - Arguments to create a ScoringSettings.
     * @example
     * // Create one ScoringSettings
     * const ScoringSettings = await prisma.scoringSettings.create({
     *   data: {
     *     // ... data to create a ScoringSettings
     *   }
     * })
     * 
     */
    create<T extends ScoringSettingsCreateArgs>(args: SelectSubset<T, ScoringSettingsCreateArgs<ExtArgs>>): Prisma__ScoringSettingsClient<$Result.GetResult<Prisma.$ScoringSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScoringSettings.
     * @param {ScoringSettingsCreateManyArgs} args - Arguments to create many ScoringSettings.
     * @example
     * // Create many ScoringSettings
     * const scoringSettings = await prisma.scoringSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScoringSettingsCreateManyArgs>(args?: SelectSubset<T, ScoringSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScoringSettings and returns the data saved in the database.
     * @param {ScoringSettingsCreateManyAndReturnArgs} args - Arguments to create many ScoringSettings.
     * @example
     * // Create many ScoringSettings
     * const scoringSettings = await prisma.scoringSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScoringSettings and only return the `id`
     * const scoringSettingsWithIdOnly = await prisma.scoringSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScoringSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, ScoringSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScoringSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScoringSettings.
     * @param {ScoringSettingsDeleteArgs} args - Arguments to delete one ScoringSettings.
     * @example
     * // Delete one ScoringSettings
     * const ScoringSettings = await prisma.scoringSettings.delete({
     *   where: {
     *     // ... filter to delete one ScoringSettings
     *   }
     * })
     * 
     */
    delete<T extends ScoringSettingsDeleteArgs>(args: SelectSubset<T, ScoringSettingsDeleteArgs<ExtArgs>>): Prisma__ScoringSettingsClient<$Result.GetResult<Prisma.$ScoringSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScoringSettings.
     * @param {ScoringSettingsUpdateArgs} args - Arguments to update one ScoringSettings.
     * @example
     * // Update one ScoringSettings
     * const scoringSettings = await prisma.scoringSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScoringSettingsUpdateArgs>(args: SelectSubset<T, ScoringSettingsUpdateArgs<ExtArgs>>): Prisma__ScoringSettingsClient<$Result.GetResult<Prisma.$ScoringSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScoringSettings.
     * @param {ScoringSettingsDeleteManyArgs} args - Arguments to filter ScoringSettings to delete.
     * @example
     * // Delete a few ScoringSettings
     * const { count } = await prisma.scoringSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScoringSettingsDeleteManyArgs>(args?: SelectSubset<T, ScoringSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScoringSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoringSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScoringSettings
     * const scoringSettings = await prisma.scoringSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScoringSettingsUpdateManyArgs>(args: SelectSubset<T, ScoringSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScoringSettings and returns the data updated in the database.
     * @param {ScoringSettingsUpdateManyAndReturnArgs} args - Arguments to update many ScoringSettings.
     * @example
     * // Update many ScoringSettings
     * const scoringSettings = await prisma.scoringSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScoringSettings and only return the `id`
     * const scoringSettingsWithIdOnly = await prisma.scoringSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScoringSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, ScoringSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScoringSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScoringSettings.
     * @param {ScoringSettingsUpsertArgs} args - Arguments to update or create a ScoringSettings.
     * @example
     * // Update or create a ScoringSettings
     * const scoringSettings = await prisma.scoringSettings.upsert({
     *   create: {
     *     // ... data to create a ScoringSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScoringSettings we want to update
     *   }
     * })
     */
    upsert<T extends ScoringSettingsUpsertArgs>(args: SelectSubset<T, ScoringSettingsUpsertArgs<ExtArgs>>): Prisma__ScoringSettingsClient<$Result.GetResult<Prisma.$ScoringSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScoringSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoringSettingsCountArgs} args - Arguments to filter ScoringSettings to count.
     * @example
     * // Count the number of ScoringSettings
     * const count = await prisma.scoringSettings.count({
     *   where: {
     *     // ... the filter for the ScoringSettings we want to count
     *   }
     * })
    **/
    count<T extends ScoringSettingsCountArgs>(
      args?: Subset<T, ScoringSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScoringSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScoringSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoringSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScoringSettingsAggregateArgs>(args: Subset<T, ScoringSettingsAggregateArgs>): Prisma.PrismaPromise<GetScoringSettingsAggregateType<T>>

    /**
     * Group by ScoringSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoringSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScoringSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScoringSettingsGroupByArgs['orderBy'] }
        : { orderBy?: ScoringSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScoringSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScoringSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScoringSettings model
   */
  readonly fields: ScoringSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScoringSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScoringSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    league<T extends LeagueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeagueDefaultArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScoringSettings model
   */
  interface ScoringSettingsFieldRefs {
    readonly id: FieldRef<"ScoringSettings", 'String'>
    readonly leagueId: FieldRef<"ScoringSettings", 'String'>
    readonly passingYards: FieldRef<"ScoringSettings", 'Decimal'>
    readonly passingTds: FieldRef<"ScoringSettings", 'Decimal'>
    readonly passingInts: FieldRef<"ScoringSettings", 'Decimal'>
    readonly rushingYards: FieldRef<"ScoringSettings", 'Decimal'>
    readonly rushingTds: FieldRef<"ScoringSettings", 'Decimal'>
    readonly receivingYards: FieldRef<"ScoringSettings", 'Decimal'>
    readonly receivingTds: FieldRef<"ScoringSettings", 'Decimal'>
    readonly receptions: FieldRef<"ScoringSettings", 'Decimal'>
    readonly fumbles: FieldRef<"ScoringSettings", 'Decimal'>
    readonly fieldGoals: FieldRef<"ScoringSettings", 'Decimal'>
    readonly extraPoints: FieldRef<"ScoringSettings", 'Decimal'>
    readonly sacks: FieldRef<"ScoringSettings", 'Decimal'>
    readonly interceptions: FieldRef<"ScoringSettings", 'Decimal'>
    readonly fumbleRecoveries: FieldRef<"ScoringSettings", 'Decimal'>
    readonly safeties: FieldRef<"ScoringSettings", 'Decimal'>
    readonly defensiveTds: FieldRef<"ScoringSettings", 'Decimal'>
    readonly pointsAllowed0: FieldRef<"ScoringSettings", 'Decimal'>
    readonly pointsAllowed1to6: FieldRef<"ScoringSettings", 'Decimal'>
    readonly pointsAllowed7to13: FieldRef<"ScoringSettings", 'Decimal'>
    readonly pointsAllowed14to20: FieldRef<"ScoringSettings", 'Decimal'>
    readonly pointsAllowed21to27: FieldRef<"ScoringSettings", 'Decimal'>
    readonly pointsAllowed28plus: FieldRef<"ScoringSettings", 'Decimal'>
    readonly createdAt: FieldRef<"ScoringSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"ScoringSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScoringSettings findUnique
   */
  export type ScoringSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringSettings
     */
    select?: ScoringSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringSettings
     */
    omit?: ScoringSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ScoringSettings to fetch.
     */
    where: ScoringSettingsWhereUniqueInput
  }

  /**
   * ScoringSettings findUniqueOrThrow
   */
  export type ScoringSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringSettings
     */
    select?: ScoringSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringSettings
     */
    omit?: ScoringSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ScoringSettings to fetch.
     */
    where: ScoringSettingsWhereUniqueInput
  }

  /**
   * ScoringSettings findFirst
   */
  export type ScoringSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringSettings
     */
    select?: ScoringSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringSettings
     */
    omit?: ScoringSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ScoringSettings to fetch.
     */
    where?: ScoringSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoringSettings to fetch.
     */
    orderBy?: ScoringSettingsOrderByWithRelationInput | ScoringSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScoringSettings.
     */
    cursor?: ScoringSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoringSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoringSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScoringSettings.
     */
    distinct?: ScoringSettingsScalarFieldEnum | ScoringSettingsScalarFieldEnum[]
  }

  /**
   * ScoringSettings findFirstOrThrow
   */
  export type ScoringSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringSettings
     */
    select?: ScoringSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringSettings
     */
    omit?: ScoringSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ScoringSettings to fetch.
     */
    where?: ScoringSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoringSettings to fetch.
     */
    orderBy?: ScoringSettingsOrderByWithRelationInput | ScoringSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScoringSettings.
     */
    cursor?: ScoringSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoringSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoringSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScoringSettings.
     */
    distinct?: ScoringSettingsScalarFieldEnum | ScoringSettingsScalarFieldEnum[]
  }

  /**
   * ScoringSettings findMany
   */
  export type ScoringSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringSettings
     */
    select?: ScoringSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringSettings
     */
    omit?: ScoringSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ScoringSettings to fetch.
     */
    where?: ScoringSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoringSettings to fetch.
     */
    orderBy?: ScoringSettingsOrderByWithRelationInput | ScoringSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScoringSettings.
     */
    cursor?: ScoringSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoringSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoringSettings.
     */
    skip?: number
    distinct?: ScoringSettingsScalarFieldEnum | ScoringSettingsScalarFieldEnum[]
  }

  /**
   * ScoringSettings create
   */
  export type ScoringSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringSettings
     */
    select?: ScoringSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringSettings
     */
    omit?: ScoringSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a ScoringSettings.
     */
    data: XOR<ScoringSettingsCreateInput, ScoringSettingsUncheckedCreateInput>
  }

  /**
   * ScoringSettings createMany
   */
  export type ScoringSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScoringSettings.
     */
    data: ScoringSettingsCreateManyInput | ScoringSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScoringSettings createManyAndReturn
   */
  export type ScoringSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringSettings
     */
    select?: ScoringSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringSettings
     */
    omit?: ScoringSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many ScoringSettings.
     */
    data: ScoringSettingsCreateManyInput | ScoringSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScoringSettings update
   */
  export type ScoringSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringSettings
     */
    select?: ScoringSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringSettings
     */
    omit?: ScoringSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a ScoringSettings.
     */
    data: XOR<ScoringSettingsUpdateInput, ScoringSettingsUncheckedUpdateInput>
    /**
     * Choose, which ScoringSettings to update.
     */
    where: ScoringSettingsWhereUniqueInput
  }

  /**
   * ScoringSettings updateMany
   */
  export type ScoringSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScoringSettings.
     */
    data: XOR<ScoringSettingsUpdateManyMutationInput, ScoringSettingsUncheckedUpdateManyInput>
    /**
     * Filter which ScoringSettings to update
     */
    where?: ScoringSettingsWhereInput
    /**
     * Limit how many ScoringSettings to update.
     */
    limit?: number
  }

  /**
   * ScoringSettings updateManyAndReturn
   */
  export type ScoringSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringSettings
     */
    select?: ScoringSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringSettings
     */
    omit?: ScoringSettingsOmit<ExtArgs> | null
    /**
     * The data used to update ScoringSettings.
     */
    data: XOR<ScoringSettingsUpdateManyMutationInput, ScoringSettingsUncheckedUpdateManyInput>
    /**
     * Filter which ScoringSettings to update
     */
    where?: ScoringSettingsWhereInput
    /**
     * Limit how many ScoringSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScoringSettings upsert
   */
  export type ScoringSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringSettings
     */
    select?: ScoringSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringSettings
     */
    omit?: ScoringSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the ScoringSettings to update in case it exists.
     */
    where: ScoringSettingsWhereUniqueInput
    /**
     * In case the ScoringSettings found by the `where` argument doesn't exist, create a new ScoringSettings with this data.
     */
    create: XOR<ScoringSettingsCreateInput, ScoringSettingsUncheckedCreateInput>
    /**
     * In case the ScoringSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScoringSettingsUpdateInput, ScoringSettingsUncheckedUpdateInput>
  }

  /**
   * ScoringSettings delete
   */
  export type ScoringSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringSettings
     */
    select?: ScoringSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringSettings
     */
    omit?: ScoringSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringSettingsInclude<ExtArgs> | null
    /**
     * Filter which ScoringSettings to delete.
     */
    where: ScoringSettingsWhereUniqueInput
  }

  /**
   * ScoringSettings deleteMany
   */
  export type ScoringSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScoringSettings to delete
     */
    where?: ScoringSettingsWhereInput
    /**
     * Limit how many ScoringSettings to delete.
     */
    limit?: number
  }

  /**
   * ScoringSettings without action
   */
  export type ScoringSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoringSettings
     */
    select?: ScoringSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScoringSettings
     */
    omit?: ScoringSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoringSettingsInclude<ExtArgs> | null
  }


  /**
   * Model RosterSettings
   */

  export type AggregateRosterSettings = {
    _count: RosterSettingsCountAggregateOutputType | null
    _avg: RosterSettingsAvgAggregateOutputType | null
    _sum: RosterSettingsSumAggregateOutputType | null
    _min: RosterSettingsMinAggregateOutputType | null
    _max: RosterSettingsMaxAggregateOutputType | null
  }

  export type RosterSettingsAvgAggregateOutputType = {
    qbSlots: number | null
    rbSlots: number | null
    wrSlots: number | null
    teSlots: number | null
    flexSlots: number | null
    kSlots: number | null
    defSlots: number | null
    benchSlots: number | null
    irSlots: number | null
    maxRosterSize: number | null
  }

  export type RosterSettingsSumAggregateOutputType = {
    qbSlots: number | null
    rbSlots: number | null
    wrSlots: number | null
    teSlots: number | null
    flexSlots: number | null
    kSlots: number | null
    defSlots: number | null
    benchSlots: number | null
    irSlots: number | null
    maxRosterSize: number | null
  }

  export type RosterSettingsMinAggregateOutputType = {
    id: string | null
    leagueId: string | null
    qbSlots: number | null
    rbSlots: number | null
    wrSlots: number | null
    teSlots: number | null
    flexSlots: number | null
    kSlots: number | null
    defSlots: number | null
    benchSlots: number | null
    irSlots: number | null
    maxRosterSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RosterSettingsMaxAggregateOutputType = {
    id: string | null
    leagueId: string | null
    qbSlots: number | null
    rbSlots: number | null
    wrSlots: number | null
    teSlots: number | null
    flexSlots: number | null
    kSlots: number | null
    defSlots: number | null
    benchSlots: number | null
    irSlots: number | null
    maxRosterSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RosterSettingsCountAggregateOutputType = {
    id: number
    leagueId: number
    qbSlots: number
    rbSlots: number
    wrSlots: number
    teSlots: number
    flexSlots: number
    kSlots: number
    defSlots: number
    benchSlots: number
    irSlots: number
    maxRosterSize: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RosterSettingsAvgAggregateInputType = {
    qbSlots?: true
    rbSlots?: true
    wrSlots?: true
    teSlots?: true
    flexSlots?: true
    kSlots?: true
    defSlots?: true
    benchSlots?: true
    irSlots?: true
    maxRosterSize?: true
  }

  export type RosterSettingsSumAggregateInputType = {
    qbSlots?: true
    rbSlots?: true
    wrSlots?: true
    teSlots?: true
    flexSlots?: true
    kSlots?: true
    defSlots?: true
    benchSlots?: true
    irSlots?: true
    maxRosterSize?: true
  }

  export type RosterSettingsMinAggregateInputType = {
    id?: true
    leagueId?: true
    qbSlots?: true
    rbSlots?: true
    wrSlots?: true
    teSlots?: true
    flexSlots?: true
    kSlots?: true
    defSlots?: true
    benchSlots?: true
    irSlots?: true
    maxRosterSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RosterSettingsMaxAggregateInputType = {
    id?: true
    leagueId?: true
    qbSlots?: true
    rbSlots?: true
    wrSlots?: true
    teSlots?: true
    flexSlots?: true
    kSlots?: true
    defSlots?: true
    benchSlots?: true
    irSlots?: true
    maxRosterSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RosterSettingsCountAggregateInputType = {
    id?: true
    leagueId?: true
    qbSlots?: true
    rbSlots?: true
    wrSlots?: true
    teSlots?: true
    flexSlots?: true
    kSlots?: true
    defSlots?: true
    benchSlots?: true
    irSlots?: true
    maxRosterSize?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RosterSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RosterSettings to aggregate.
     */
    where?: RosterSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RosterSettings to fetch.
     */
    orderBy?: RosterSettingsOrderByWithRelationInput | RosterSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RosterSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RosterSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RosterSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RosterSettings
    **/
    _count?: true | RosterSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RosterSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RosterSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RosterSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RosterSettingsMaxAggregateInputType
  }

  export type GetRosterSettingsAggregateType<T extends RosterSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateRosterSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRosterSettings[P]>
      : GetScalarType<T[P], AggregateRosterSettings[P]>
  }




  export type RosterSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RosterSettingsWhereInput
    orderBy?: RosterSettingsOrderByWithAggregationInput | RosterSettingsOrderByWithAggregationInput[]
    by: RosterSettingsScalarFieldEnum[] | RosterSettingsScalarFieldEnum
    having?: RosterSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RosterSettingsCountAggregateInputType | true
    _avg?: RosterSettingsAvgAggregateInputType
    _sum?: RosterSettingsSumAggregateInputType
    _min?: RosterSettingsMinAggregateInputType
    _max?: RosterSettingsMaxAggregateInputType
  }

  export type RosterSettingsGroupByOutputType = {
    id: string
    leagueId: string
    qbSlots: number
    rbSlots: number
    wrSlots: number
    teSlots: number
    flexSlots: number
    kSlots: number
    defSlots: number
    benchSlots: number
    irSlots: number
    maxRosterSize: number
    createdAt: Date
    updatedAt: Date
    _count: RosterSettingsCountAggregateOutputType | null
    _avg: RosterSettingsAvgAggregateOutputType | null
    _sum: RosterSettingsSumAggregateOutputType | null
    _min: RosterSettingsMinAggregateOutputType | null
    _max: RosterSettingsMaxAggregateOutputType | null
  }

  type GetRosterSettingsGroupByPayload<T extends RosterSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RosterSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RosterSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RosterSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], RosterSettingsGroupByOutputType[P]>
        }
      >
    >


  export type RosterSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    qbSlots?: boolean
    rbSlots?: boolean
    wrSlots?: boolean
    teSlots?: boolean
    flexSlots?: boolean
    kSlots?: boolean
    defSlots?: boolean
    benchSlots?: boolean
    irSlots?: boolean
    maxRosterSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rosterSettings"]>

  export type RosterSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    qbSlots?: boolean
    rbSlots?: boolean
    wrSlots?: boolean
    teSlots?: boolean
    flexSlots?: boolean
    kSlots?: boolean
    defSlots?: boolean
    benchSlots?: boolean
    irSlots?: boolean
    maxRosterSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rosterSettings"]>

  export type RosterSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    qbSlots?: boolean
    rbSlots?: boolean
    wrSlots?: boolean
    teSlots?: boolean
    flexSlots?: boolean
    kSlots?: boolean
    defSlots?: boolean
    benchSlots?: boolean
    irSlots?: boolean
    maxRosterSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rosterSettings"]>

  export type RosterSettingsSelectScalar = {
    id?: boolean
    leagueId?: boolean
    qbSlots?: boolean
    rbSlots?: boolean
    wrSlots?: boolean
    teSlots?: boolean
    flexSlots?: boolean
    kSlots?: boolean
    defSlots?: boolean
    benchSlots?: boolean
    irSlots?: boolean
    maxRosterSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RosterSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leagueId" | "qbSlots" | "rbSlots" | "wrSlots" | "teSlots" | "flexSlots" | "kSlots" | "defSlots" | "benchSlots" | "irSlots" | "maxRosterSize" | "createdAt" | "updatedAt", ExtArgs["result"]["rosterSettings"]>
  export type RosterSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }
  export type RosterSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }
  export type RosterSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }

  export type $RosterSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RosterSettings"
    objects: {
      league: Prisma.$LeaguePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leagueId: string
      qbSlots: number
      rbSlots: number
      wrSlots: number
      teSlots: number
      flexSlots: number
      kSlots: number
      defSlots: number
      benchSlots: number
      irSlots: number
      maxRosterSize: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rosterSettings"]>
    composites: {}
  }

  type RosterSettingsGetPayload<S extends boolean | null | undefined | RosterSettingsDefaultArgs> = $Result.GetResult<Prisma.$RosterSettingsPayload, S>

  type RosterSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RosterSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RosterSettingsCountAggregateInputType | true
    }

  export interface RosterSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RosterSettings'], meta: { name: 'RosterSettings' } }
    /**
     * Find zero or one RosterSettings that matches the filter.
     * @param {RosterSettingsFindUniqueArgs} args - Arguments to find a RosterSettings
     * @example
     * // Get one RosterSettings
     * const rosterSettings = await prisma.rosterSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RosterSettingsFindUniqueArgs>(args: SelectSubset<T, RosterSettingsFindUniqueArgs<ExtArgs>>): Prisma__RosterSettingsClient<$Result.GetResult<Prisma.$RosterSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RosterSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RosterSettingsFindUniqueOrThrowArgs} args - Arguments to find a RosterSettings
     * @example
     * // Get one RosterSettings
     * const rosterSettings = await prisma.rosterSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RosterSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, RosterSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RosterSettingsClient<$Result.GetResult<Prisma.$RosterSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RosterSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterSettingsFindFirstArgs} args - Arguments to find a RosterSettings
     * @example
     * // Get one RosterSettings
     * const rosterSettings = await prisma.rosterSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RosterSettingsFindFirstArgs>(args?: SelectSubset<T, RosterSettingsFindFirstArgs<ExtArgs>>): Prisma__RosterSettingsClient<$Result.GetResult<Prisma.$RosterSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RosterSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterSettingsFindFirstOrThrowArgs} args - Arguments to find a RosterSettings
     * @example
     * // Get one RosterSettings
     * const rosterSettings = await prisma.rosterSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RosterSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, RosterSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RosterSettingsClient<$Result.GetResult<Prisma.$RosterSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RosterSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RosterSettings
     * const rosterSettings = await prisma.rosterSettings.findMany()
     * 
     * // Get first 10 RosterSettings
     * const rosterSettings = await prisma.rosterSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rosterSettingsWithIdOnly = await prisma.rosterSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RosterSettingsFindManyArgs>(args?: SelectSubset<T, RosterSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RosterSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RosterSettings.
     * @param {RosterSettingsCreateArgs} args - Arguments to create a RosterSettings.
     * @example
     * // Create one RosterSettings
     * const RosterSettings = await prisma.rosterSettings.create({
     *   data: {
     *     // ... data to create a RosterSettings
     *   }
     * })
     * 
     */
    create<T extends RosterSettingsCreateArgs>(args: SelectSubset<T, RosterSettingsCreateArgs<ExtArgs>>): Prisma__RosterSettingsClient<$Result.GetResult<Prisma.$RosterSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RosterSettings.
     * @param {RosterSettingsCreateManyArgs} args - Arguments to create many RosterSettings.
     * @example
     * // Create many RosterSettings
     * const rosterSettings = await prisma.rosterSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RosterSettingsCreateManyArgs>(args?: SelectSubset<T, RosterSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RosterSettings and returns the data saved in the database.
     * @param {RosterSettingsCreateManyAndReturnArgs} args - Arguments to create many RosterSettings.
     * @example
     * // Create many RosterSettings
     * const rosterSettings = await prisma.rosterSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RosterSettings and only return the `id`
     * const rosterSettingsWithIdOnly = await prisma.rosterSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RosterSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, RosterSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RosterSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RosterSettings.
     * @param {RosterSettingsDeleteArgs} args - Arguments to delete one RosterSettings.
     * @example
     * // Delete one RosterSettings
     * const RosterSettings = await prisma.rosterSettings.delete({
     *   where: {
     *     // ... filter to delete one RosterSettings
     *   }
     * })
     * 
     */
    delete<T extends RosterSettingsDeleteArgs>(args: SelectSubset<T, RosterSettingsDeleteArgs<ExtArgs>>): Prisma__RosterSettingsClient<$Result.GetResult<Prisma.$RosterSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RosterSettings.
     * @param {RosterSettingsUpdateArgs} args - Arguments to update one RosterSettings.
     * @example
     * // Update one RosterSettings
     * const rosterSettings = await prisma.rosterSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RosterSettingsUpdateArgs>(args: SelectSubset<T, RosterSettingsUpdateArgs<ExtArgs>>): Prisma__RosterSettingsClient<$Result.GetResult<Prisma.$RosterSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RosterSettings.
     * @param {RosterSettingsDeleteManyArgs} args - Arguments to filter RosterSettings to delete.
     * @example
     * // Delete a few RosterSettings
     * const { count } = await prisma.rosterSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RosterSettingsDeleteManyArgs>(args?: SelectSubset<T, RosterSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RosterSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RosterSettings
     * const rosterSettings = await prisma.rosterSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RosterSettingsUpdateManyArgs>(args: SelectSubset<T, RosterSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RosterSettings and returns the data updated in the database.
     * @param {RosterSettingsUpdateManyAndReturnArgs} args - Arguments to update many RosterSettings.
     * @example
     * // Update many RosterSettings
     * const rosterSettings = await prisma.rosterSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RosterSettings and only return the `id`
     * const rosterSettingsWithIdOnly = await prisma.rosterSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RosterSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, RosterSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RosterSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RosterSettings.
     * @param {RosterSettingsUpsertArgs} args - Arguments to update or create a RosterSettings.
     * @example
     * // Update or create a RosterSettings
     * const rosterSettings = await prisma.rosterSettings.upsert({
     *   create: {
     *     // ... data to create a RosterSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RosterSettings we want to update
     *   }
     * })
     */
    upsert<T extends RosterSettingsUpsertArgs>(args: SelectSubset<T, RosterSettingsUpsertArgs<ExtArgs>>): Prisma__RosterSettingsClient<$Result.GetResult<Prisma.$RosterSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RosterSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterSettingsCountArgs} args - Arguments to filter RosterSettings to count.
     * @example
     * // Count the number of RosterSettings
     * const count = await prisma.rosterSettings.count({
     *   where: {
     *     // ... the filter for the RosterSettings we want to count
     *   }
     * })
    **/
    count<T extends RosterSettingsCountArgs>(
      args?: Subset<T, RosterSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RosterSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RosterSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RosterSettingsAggregateArgs>(args: Subset<T, RosterSettingsAggregateArgs>): Prisma.PrismaPromise<GetRosterSettingsAggregateType<T>>

    /**
     * Group by RosterSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RosterSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RosterSettingsGroupByArgs['orderBy'] }
        : { orderBy?: RosterSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RosterSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRosterSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RosterSettings model
   */
  readonly fields: RosterSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RosterSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RosterSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    league<T extends LeagueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeagueDefaultArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RosterSettings model
   */
  interface RosterSettingsFieldRefs {
    readonly id: FieldRef<"RosterSettings", 'String'>
    readonly leagueId: FieldRef<"RosterSettings", 'String'>
    readonly qbSlots: FieldRef<"RosterSettings", 'Int'>
    readonly rbSlots: FieldRef<"RosterSettings", 'Int'>
    readonly wrSlots: FieldRef<"RosterSettings", 'Int'>
    readonly teSlots: FieldRef<"RosterSettings", 'Int'>
    readonly flexSlots: FieldRef<"RosterSettings", 'Int'>
    readonly kSlots: FieldRef<"RosterSettings", 'Int'>
    readonly defSlots: FieldRef<"RosterSettings", 'Int'>
    readonly benchSlots: FieldRef<"RosterSettings", 'Int'>
    readonly irSlots: FieldRef<"RosterSettings", 'Int'>
    readonly maxRosterSize: FieldRef<"RosterSettings", 'Int'>
    readonly createdAt: FieldRef<"RosterSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"RosterSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RosterSettings findUnique
   */
  export type RosterSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterSettings
     */
    select?: RosterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterSettings
     */
    omit?: RosterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterSettingsInclude<ExtArgs> | null
    /**
     * Filter, which RosterSettings to fetch.
     */
    where: RosterSettingsWhereUniqueInput
  }

  /**
   * RosterSettings findUniqueOrThrow
   */
  export type RosterSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterSettings
     */
    select?: RosterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterSettings
     */
    omit?: RosterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterSettingsInclude<ExtArgs> | null
    /**
     * Filter, which RosterSettings to fetch.
     */
    where: RosterSettingsWhereUniqueInput
  }

  /**
   * RosterSettings findFirst
   */
  export type RosterSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterSettings
     */
    select?: RosterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterSettings
     */
    omit?: RosterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterSettingsInclude<ExtArgs> | null
    /**
     * Filter, which RosterSettings to fetch.
     */
    where?: RosterSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RosterSettings to fetch.
     */
    orderBy?: RosterSettingsOrderByWithRelationInput | RosterSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RosterSettings.
     */
    cursor?: RosterSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RosterSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RosterSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RosterSettings.
     */
    distinct?: RosterSettingsScalarFieldEnum | RosterSettingsScalarFieldEnum[]
  }

  /**
   * RosterSettings findFirstOrThrow
   */
  export type RosterSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterSettings
     */
    select?: RosterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterSettings
     */
    omit?: RosterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterSettingsInclude<ExtArgs> | null
    /**
     * Filter, which RosterSettings to fetch.
     */
    where?: RosterSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RosterSettings to fetch.
     */
    orderBy?: RosterSettingsOrderByWithRelationInput | RosterSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RosterSettings.
     */
    cursor?: RosterSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RosterSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RosterSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RosterSettings.
     */
    distinct?: RosterSettingsScalarFieldEnum | RosterSettingsScalarFieldEnum[]
  }

  /**
   * RosterSettings findMany
   */
  export type RosterSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterSettings
     */
    select?: RosterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterSettings
     */
    omit?: RosterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterSettingsInclude<ExtArgs> | null
    /**
     * Filter, which RosterSettings to fetch.
     */
    where?: RosterSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RosterSettings to fetch.
     */
    orderBy?: RosterSettingsOrderByWithRelationInput | RosterSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RosterSettings.
     */
    cursor?: RosterSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RosterSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RosterSettings.
     */
    skip?: number
    distinct?: RosterSettingsScalarFieldEnum | RosterSettingsScalarFieldEnum[]
  }

  /**
   * RosterSettings create
   */
  export type RosterSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterSettings
     */
    select?: RosterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterSettings
     */
    omit?: RosterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a RosterSettings.
     */
    data: XOR<RosterSettingsCreateInput, RosterSettingsUncheckedCreateInput>
  }

  /**
   * RosterSettings createMany
   */
  export type RosterSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RosterSettings.
     */
    data: RosterSettingsCreateManyInput | RosterSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RosterSettings createManyAndReturn
   */
  export type RosterSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterSettings
     */
    select?: RosterSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RosterSettings
     */
    omit?: RosterSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many RosterSettings.
     */
    data: RosterSettingsCreateManyInput | RosterSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RosterSettings update
   */
  export type RosterSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterSettings
     */
    select?: RosterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterSettings
     */
    omit?: RosterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a RosterSettings.
     */
    data: XOR<RosterSettingsUpdateInput, RosterSettingsUncheckedUpdateInput>
    /**
     * Choose, which RosterSettings to update.
     */
    where: RosterSettingsWhereUniqueInput
  }

  /**
   * RosterSettings updateMany
   */
  export type RosterSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RosterSettings.
     */
    data: XOR<RosterSettingsUpdateManyMutationInput, RosterSettingsUncheckedUpdateManyInput>
    /**
     * Filter which RosterSettings to update
     */
    where?: RosterSettingsWhereInput
    /**
     * Limit how many RosterSettings to update.
     */
    limit?: number
  }

  /**
   * RosterSettings updateManyAndReturn
   */
  export type RosterSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterSettings
     */
    select?: RosterSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RosterSettings
     */
    omit?: RosterSettingsOmit<ExtArgs> | null
    /**
     * The data used to update RosterSettings.
     */
    data: XOR<RosterSettingsUpdateManyMutationInput, RosterSettingsUncheckedUpdateManyInput>
    /**
     * Filter which RosterSettings to update
     */
    where?: RosterSettingsWhereInput
    /**
     * Limit how many RosterSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RosterSettings upsert
   */
  export type RosterSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterSettings
     */
    select?: RosterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterSettings
     */
    omit?: RosterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the RosterSettings to update in case it exists.
     */
    where: RosterSettingsWhereUniqueInput
    /**
     * In case the RosterSettings found by the `where` argument doesn't exist, create a new RosterSettings with this data.
     */
    create: XOR<RosterSettingsCreateInput, RosterSettingsUncheckedCreateInput>
    /**
     * In case the RosterSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RosterSettingsUpdateInput, RosterSettingsUncheckedUpdateInput>
  }

  /**
   * RosterSettings delete
   */
  export type RosterSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterSettings
     */
    select?: RosterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterSettings
     */
    omit?: RosterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterSettingsInclude<ExtArgs> | null
    /**
     * Filter which RosterSettings to delete.
     */
    where: RosterSettingsWhereUniqueInput
  }

  /**
   * RosterSettings deleteMany
   */
  export type RosterSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RosterSettings to delete
     */
    where?: RosterSettingsWhereInput
    /**
     * Limit how many RosterSettings to delete.
     */
    limit?: number
  }

  /**
   * RosterSettings without action
   */
  export type RosterSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RosterSettings
     */
    select?: RosterSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RosterSettings
     */
    omit?: RosterSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterSettingsInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    wins: number | null
    losses: number | null
    ties: number | null
    totalPoints: Decimal | null
    waiverPriority: number | null
    transactionCount: number | null
    amountOwed: Decimal | null
    amountPaid: Decimal | null
  }

  export type TeamSumAggregateOutputType = {
    wins: number | null
    losses: number | null
    ties: number | null
    totalPoints: Decimal | null
    waiverPriority: number | null
    transactionCount: number | null
    amountOwed: Decimal | null
    amountPaid: Decimal | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    leagueId: string | null
    ownerId: string | null
    name: string | null
    logoUrl: string | null
    wins: number | null
    losses: number | null
    ties: number | null
    totalPoints: Decimal | null
    isActive: boolean | null
    waiverPriority: number | null
    transactionCount: number | null
    paidEntry: boolean | null
    amountOwed: Decimal | null
    amountPaid: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    leagueId: string | null
    ownerId: string | null
    name: string | null
    logoUrl: string | null
    wins: number | null
    losses: number | null
    ties: number | null
    totalPoints: Decimal | null
    isActive: boolean | null
    waiverPriority: number | null
    transactionCount: number | null
    paidEntry: boolean | null
    amountOwed: Decimal | null
    amountPaid: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    leagueId: number
    ownerId: number
    name: number
    logoUrl: number
    wins: number
    losses: number
    ties: number
    totalPoints: number
    isActive: number
    waiverPriority: number
    transactionCount: number
    paidEntry: number
    amountOwed: number
    amountPaid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    wins?: true
    losses?: true
    ties?: true
    totalPoints?: true
    waiverPriority?: true
    transactionCount?: true
    amountOwed?: true
    amountPaid?: true
  }

  export type TeamSumAggregateInputType = {
    wins?: true
    losses?: true
    ties?: true
    totalPoints?: true
    waiverPriority?: true
    transactionCount?: true
    amountOwed?: true
    amountPaid?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    leagueId?: true
    ownerId?: true
    name?: true
    logoUrl?: true
    wins?: true
    losses?: true
    ties?: true
    totalPoints?: true
    isActive?: true
    waiverPriority?: true
    transactionCount?: true
    paidEntry?: true
    amountOwed?: true
    amountPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    leagueId?: true
    ownerId?: true
    name?: true
    logoUrl?: true
    wins?: true
    losses?: true
    ties?: true
    totalPoints?: true
    isActive?: true
    waiverPriority?: true
    transactionCount?: true
    paidEntry?: true
    amountOwed?: true
    amountPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    leagueId?: true
    ownerId?: true
    name?: true
    logoUrl?: true
    wins?: true
    losses?: true
    ties?: true
    totalPoints?: true
    isActive?: true
    waiverPriority?: true
    transactionCount?: true
    paidEntry?: true
    amountOwed?: true
    amountPaid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    leagueId: string
    ownerId: string
    name: string
    logoUrl: string | null
    wins: number
    losses: number
    ties: number
    totalPoints: Decimal
    isActive: boolean
    waiverPriority: number
    transactionCount: number
    paidEntry: boolean
    amountOwed: Decimal
    amountPaid: Decimal
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    ownerId?: boolean
    name?: boolean
    logoUrl?: boolean
    wins?: boolean
    losses?: boolean
    ties?: boolean
    totalPoints?: boolean
    isActive?: boolean
    waiverPriority?: boolean
    transactionCount?: boolean
    paidEntry?: boolean
    amountOwed?: boolean
    amountPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    roster?: boolean | Team$rosterArgs<ExtArgs>
    draftPicks?: boolean | Team$draftPicksArgs<ExtArgs>
    homeGames?: boolean | Team$homeGamesArgs<ExtArgs>
    awayGames?: boolean | Team$awayGamesArgs<ExtArgs>
    transactions?: boolean | Team$transactionsArgs<ExtArgs>
    offeredTrades?: boolean | Team$offeredTradesArgs<ExtArgs>
    targetedTrades?: boolean | Team$targetedTradesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    ownerId?: boolean
    name?: boolean
    logoUrl?: boolean
    wins?: boolean
    losses?: boolean
    ties?: boolean
    totalPoints?: boolean
    isActive?: boolean
    waiverPriority?: boolean
    transactionCount?: boolean
    paidEntry?: boolean
    amountOwed?: boolean
    amountPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    ownerId?: boolean
    name?: boolean
    logoUrl?: boolean
    wins?: boolean
    losses?: boolean
    ties?: boolean
    totalPoints?: boolean
    isActive?: boolean
    waiverPriority?: boolean
    transactionCount?: boolean
    paidEntry?: boolean
    amountOwed?: boolean
    amountPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    leagueId?: boolean
    ownerId?: boolean
    name?: boolean
    logoUrl?: boolean
    wins?: boolean
    losses?: boolean
    ties?: boolean
    totalPoints?: boolean
    isActive?: boolean
    waiverPriority?: boolean
    transactionCount?: boolean
    paidEntry?: boolean
    amountOwed?: boolean
    amountPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leagueId" | "ownerId" | "name" | "logoUrl" | "wins" | "losses" | "ties" | "totalPoints" | "isActive" | "waiverPriority" | "transactionCount" | "paidEntry" | "amountOwed" | "amountPaid" | "createdAt" | "updatedAt", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    roster?: boolean | Team$rosterArgs<ExtArgs>
    draftPicks?: boolean | Team$draftPicksArgs<ExtArgs>
    homeGames?: boolean | Team$homeGamesArgs<ExtArgs>
    awayGames?: boolean | Team$awayGamesArgs<ExtArgs>
    transactions?: boolean | Team$transactionsArgs<ExtArgs>
    offeredTrades?: boolean | Team$offeredTradesArgs<ExtArgs>
    targetedTrades?: boolean | Team$targetedTradesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      league: Prisma.$LeaguePayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
      roster: Prisma.$RosterPayload<ExtArgs>[]
      draftPicks: Prisma.$DraftPickPayload<ExtArgs>[]
      homeGames: Prisma.$GamePayload<ExtArgs>[]
      awayGames: Prisma.$GamePayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      offeredTrades: Prisma.$TradeOfferPayload<ExtArgs>[]
      targetedTrades: Prisma.$TradeOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leagueId: string
      ownerId: string
      name: string
      logoUrl: string | null
      wins: number
      losses: number
      ties: number
      totalPoints: Prisma.Decimal
      isActive: boolean
      waiverPriority: number
      transactionCount: number
      paidEntry: boolean
      amountOwed: Prisma.Decimal
      amountPaid: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    league<T extends LeagueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeagueDefaultArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    roster<T extends Team$rosterArgs<ExtArgs> = {}>(args?: Subset<T, Team$rosterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    draftPicks<T extends Team$draftPicksArgs<ExtArgs> = {}>(args?: Subset<T, Team$draftPicksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPickPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    homeGames<T extends Team$homeGamesArgs<ExtArgs> = {}>(args?: Subset<T, Team$homeGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    awayGames<T extends Team$awayGamesArgs<ExtArgs> = {}>(args?: Subset<T, Team$awayGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Team$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Team$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offeredTrades<T extends Team$offeredTradesArgs<ExtArgs> = {}>(args?: Subset<T, Team$offeredTradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    targetedTrades<T extends Team$targetedTradesArgs<ExtArgs> = {}>(args?: Subset<T, Team$targetedTradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly leagueId: FieldRef<"Team", 'String'>
    readonly ownerId: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly logoUrl: FieldRef<"Team", 'String'>
    readonly wins: FieldRef<"Team", 'Int'>
    readonly losses: FieldRef<"Team", 'Int'>
    readonly ties: FieldRef<"Team", 'Int'>
    readonly totalPoints: FieldRef<"Team", 'Decimal'>
    readonly isActive: FieldRef<"Team", 'Boolean'>
    readonly waiverPriority: FieldRef<"Team", 'Int'>
    readonly transactionCount: FieldRef<"Team", 'Int'>
    readonly paidEntry: FieldRef<"Team", 'Boolean'>
    readonly amountOwed: FieldRef<"Team", 'Decimal'>
    readonly amountPaid: FieldRef<"Team", 'Decimal'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.roster
   */
  export type Team$rosterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roster
     */
    select?: RosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roster
     */
    omit?: RosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterInclude<ExtArgs> | null
    where?: RosterWhereInput
    orderBy?: RosterOrderByWithRelationInput | RosterOrderByWithRelationInput[]
    cursor?: RosterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RosterScalarFieldEnum | RosterScalarFieldEnum[]
  }

  /**
   * Team.draftPicks
   */
  export type Team$draftPicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickInclude<ExtArgs> | null
    where?: DraftPickWhereInput
    orderBy?: DraftPickOrderByWithRelationInput | DraftPickOrderByWithRelationInput[]
    cursor?: DraftPickWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DraftPickScalarFieldEnum | DraftPickScalarFieldEnum[]
  }

  /**
   * Team.homeGames
   */
  export type Team$homeGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Team.awayGames
   */
  export type Team$awayGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Team.transactions
   */
  export type Team$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Team.offeredTrades
   */
  export type Team$offeredTradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferInclude<ExtArgs> | null
    where?: TradeOfferWhereInput
    orderBy?: TradeOfferOrderByWithRelationInput | TradeOfferOrderByWithRelationInput[]
    cursor?: TradeOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeOfferScalarFieldEnum | TradeOfferScalarFieldEnum[]
  }

  /**
   * Team.targetedTrades
   */
  export type Team$targetedTradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferInclude<ExtArgs> | null
    where?: TradeOfferWhereInput
    orderBy?: TradeOfferOrderByWithRelationInput | TradeOfferOrderByWithRelationInput[]
    cursor?: TradeOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeOfferScalarFieldEnum | TradeOfferScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Player
   */

  export type AggregatePlayer = {
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  export type PlayerAvgAggregateOutputType = {
    number: number | null
    byeWeek: number | null
  }

  export type PlayerSumAggregateOutputType = {
    number: number | null
    byeWeek: number | null
  }

  export type PlayerMinAggregateOutputType = {
    id: string | null
    externalId: string | null
    firstName: string | null
    lastName: string | null
    position: $Enums.Position | null
    team: string | null
    number: number | null
    byeWeek: number | null
    isActive: boolean | null
    injuryStatus: $Enums.InjuryStatus | null
    injuryNote: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerMaxAggregateOutputType = {
    id: string | null
    externalId: string | null
    firstName: string | null
    lastName: string | null
    position: $Enums.Position | null
    team: string | null
    number: number | null
    byeWeek: number | null
    isActive: boolean | null
    injuryStatus: $Enums.InjuryStatus | null
    injuryNote: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerCountAggregateOutputType = {
    id: number
    externalId: number
    firstName: number
    lastName: number
    position: number
    team: number
    number: number
    byeWeek: number
    isActive: number
    injuryStatus: number
    injuryNote: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerAvgAggregateInputType = {
    number?: true
    byeWeek?: true
  }

  export type PlayerSumAggregateInputType = {
    number?: true
    byeWeek?: true
  }

  export type PlayerMinAggregateInputType = {
    id?: true
    externalId?: true
    firstName?: true
    lastName?: true
    position?: true
    team?: true
    number?: true
    byeWeek?: true
    isActive?: true
    injuryStatus?: true
    injuryNote?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerMaxAggregateInputType = {
    id?: true
    externalId?: true
    firstName?: true
    lastName?: true
    position?: true
    team?: true
    number?: true
    byeWeek?: true
    isActive?: true
    injuryStatus?: true
    injuryNote?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerCountAggregateInputType = {
    id?: true
    externalId?: true
    firstName?: true
    lastName?: true
    position?: true
    team?: true
    number?: true
    byeWeek?: true
    isActive?: true
    injuryStatus?: true
    injuryNote?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Player to aggregate.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Players
    **/
    _count?: true | PlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaxAggregateInputType
  }

  export type GetPlayerAggregateType<T extends PlayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer[P]>
      : GetScalarType<T[P], AggregatePlayer[P]>
  }




  export type PlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithAggregationInput | PlayerOrderByWithAggregationInput[]
    by: PlayerScalarFieldEnum[] | PlayerScalarFieldEnum
    having?: PlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCountAggregateInputType | true
    _avg?: PlayerAvgAggregateInputType
    _sum?: PlayerSumAggregateInputType
    _min?: PlayerMinAggregateInputType
    _max?: PlayerMaxAggregateInputType
  }

  export type PlayerGroupByOutputType = {
    id: string
    externalId: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number: number | null
    byeWeek: number | null
    isActive: boolean
    injuryStatus: $Enums.InjuryStatus
    injuryNote: string | null
    imageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  type GetPlayerGroupByPayload<T extends PlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    firstName?: boolean
    lastName?: boolean
    position?: boolean
    team?: boolean
    number?: boolean
    byeWeek?: boolean
    isActive?: boolean
    injuryStatus?: boolean
    injuryNote?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roster?: boolean | Player$rosterArgs<ExtArgs>
    draftPicks?: boolean | Player$draftPicksArgs<ExtArgs>
    transactions?: boolean | Player$transactionsArgs<ExtArgs>
    gameStats?: boolean | Player$gameStatsArgs<ExtArgs>
    weeklyProjections?: boolean | Player$weeklyProjectionsArgs<ExtArgs>
    tradeOfferPlayers?: boolean | Player$tradeOfferPlayersArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    firstName?: boolean
    lastName?: boolean
    position?: boolean
    team?: boolean
    number?: boolean
    byeWeek?: boolean
    isActive?: boolean
    injuryStatus?: boolean
    injuryNote?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    firstName?: boolean
    lastName?: boolean
    position?: boolean
    team?: boolean
    number?: boolean
    byeWeek?: boolean
    isActive?: boolean
    injuryStatus?: boolean
    injuryNote?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectScalar = {
    id?: boolean
    externalId?: boolean
    firstName?: boolean
    lastName?: boolean
    position?: boolean
    team?: boolean
    number?: boolean
    byeWeek?: boolean
    isActive?: boolean
    injuryStatus?: boolean
    injuryNote?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "firstName" | "lastName" | "position" | "team" | "number" | "byeWeek" | "isActive" | "injuryStatus" | "injuryNote" | "imageUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["player"]>
  export type PlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roster?: boolean | Player$rosterArgs<ExtArgs>
    draftPicks?: boolean | Player$draftPicksArgs<ExtArgs>
    transactions?: boolean | Player$transactionsArgs<ExtArgs>
    gameStats?: boolean | Player$gameStatsArgs<ExtArgs>
    weeklyProjections?: boolean | Player$weeklyProjectionsArgs<ExtArgs>
    tradeOfferPlayers?: boolean | Player$tradeOfferPlayersArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlayerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Player"
    objects: {
      roster: Prisma.$RosterPayload<ExtArgs>[]
      draftPicks: Prisma.$DraftPickPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      gameStats: Prisma.$GameStatsPayload<ExtArgs>[]
      weeklyProjections: Prisma.$WeeklyProjectionPayload<ExtArgs>[]
      tradeOfferPlayers: Prisma.$TradeOfferPlayerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: string | null
      firstName: string
      lastName: string
      position: $Enums.Position
      team: string
      number: number | null
      byeWeek: number | null
      isActive: boolean
      injuryStatus: $Enums.InjuryStatus
      injuryNote: string | null
      imageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["player"]>
    composites: {}
  }

  type PlayerGetPayload<S extends boolean | null | undefined | PlayerDefaultArgs> = $Result.GetResult<Prisma.$PlayerPayload, S>

  type PlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerCountAggregateInputType | true
    }

  export interface PlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Player'], meta: { name: 'Player' } }
    /**
     * Find zero or one Player that matches the filter.
     * @param {PlayerFindUniqueArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerFindUniqueArgs>(args: SelectSubset<T, PlayerFindUniqueArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Player that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerFindUniqueOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerFindFirstArgs>(args?: SelectSubset<T, PlayerFindFirstArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players
     * const players = await prisma.player.findMany()
     * 
     * // Get first 10 Players
     * const players = await prisma.player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerWithIdOnly = await prisma.player.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerFindManyArgs>(args?: SelectSubset<T, PlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Player.
     * @param {PlayerCreateArgs} args - Arguments to create a Player.
     * @example
     * // Create one Player
     * const Player = await prisma.player.create({
     *   data: {
     *     // ... data to create a Player
     *   }
     * })
     * 
     */
    create<T extends PlayerCreateArgs>(args: SelectSubset<T, PlayerCreateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Players.
     * @param {PlayerCreateManyArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerCreateManyArgs>(args?: SelectSubset<T, PlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Players and returns the data saved in the database.
     * @param {PlayerCreateManyAndReturnArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Player.
     * @param {PlayerDeleteArgs} args - Arguments to delete one Player.
     * @example
     * // Delete one Player
     * const Player = await prisma.player.delete({
     *   where: {
     *     // ... filter to delete one Player
     *   }
     * })
     * 
     */
    delete<T extends PlayerDeleteArgs>(args: SelectSubset<T, PlayerDeleteArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Player.
     * @param {PlayerUpdateArgs} args - Arguments to update one Player.
     * @example
     * // Update one Player
     * const player = await prisma.player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerUpdateArgs>(args: SelectSubset<T, PlayerUpdateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Players.
     * @param {PlayerDeleteManyArgs} args - Arguments to filter Players to delete.
     * @example
     * // Delete a few Players
     * const { count } = await prisma.player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerDeleteManyArgs>(args?: SelectSubset<T, PlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerUpdateManyArgs>(args: SelectSubset<T, PlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players and returns the data updated in the database.
     * @param {PlayerUpdateManyAndReturnArgs} args - Arguments to update many Players.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Player.
     * @param {PlayerUpsertArgs} args - Arguments to update or create a Player.
     * @example
     * // Update or create a Player
     * const player = await prisma.player.upsert({
     *   create: {
     *     // ... data to create a Player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player we want to update
     *   }
     * })
     */
    upsert<T extends PlayerUpsertArgs>(args: SelectSubset<T, PlayerUpsertArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCountArgs} args - Arguments to filter Players to count.
     * @example
     * // Count the number of Players
     * const count = await prisma.player.count({
     *   where: {
     *     // ... the filter for the Players we want to count
     *   }
     * })
    **/
    count<T extends PlayerCountArgs>(
      args?: Subset<T, PlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAggregateArgs>(args: Subset<T, PlayerAggregateArgs>): Prisma.PrismaPromise<GetPlayerAggregateType<T>>

    /**
     * Group by Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerGroupByArgs['orderBy'] }
        : { orderBy?: PlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Player model
   */
  readonly fields: PlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roster<T extends Player$rosterArgs<ExtArgs> = {}>(args?: Subset<T, Player$rosterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    draftPicks<T extends Player$draftPicksArgs<ExtArgs> = {}>(args?: Subset<T, Player$draftPicksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPickPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Player$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Player$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gameStats<T extends Player$gameStatsArgs<ExtArgs> = {}>(args?: Subset<T, Player$gameStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    weeklyProjections<T extends Player$weeklyProjectionsArgs<ExtArgs> = {}>(args?: Subset<T, Player$weeklyProjectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyProjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tradeOfferPlayers<T extends Player$tradeOfferPlayersArgs<ExtArgs> = {}>(args?: Subset<T, Player$tradeOfferPlayersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeOfferPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Player model
   */
  interface PlayerFieldRefs {
    readonly id: FieldRef<"Player", 'String'>
    readonly externalId: FieldRef<"Player", 'String'>
    readonly firstName: FieldRef<"Player", 'String'>
    readonly lastName: FieldRef<"Player", 'String'>
    readonly position: FieldRef<"Player", 'Position'>
    readonly team: FieldRef<"Player", 'String'>
    readonly number: FieldRef<"Player", 'Int'>
    readonly byeWeek: FieldRef<"Player", 'Int'>
    readonly isActive: FieldRef<"Player", 'Boolean'>
    readonly injuryStatus: FieldRef<"Player", 'InjuryStatus'>
    readonly injuryNote: FieldRef<"Player", 'String'>
    readonly imageUrl: FieldRef<"Player", 'String'>
    readonly createdAt: FieldRef<"Player", 'DateTime'>
    readonly updatedAt: FieldRef<"Player", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Player findUnique
   */
  export type PlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findUniqueOrThrow
   */
  export type PlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findFirst
   */
  export type PlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findFirstOrThrow
   */
  export type PlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findMany
   */
  export type PlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Players to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player create
   */
  export type PlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a Player.
     */
    data: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
  }

  /**
   * Player createMany
   */
  export type PlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Player createManyAndReturn
   */
  export type PlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Player update
   */
  export type PlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a Player.
     */
    data: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
    /**
     * Choose, which Player to update.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player updateMany
   */
  export type PlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to update.
     */
    limit?: number
  }

  /**
   * Player updateManyAndReturn
   */
  export type PlayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to update.
     */
    limit?: number
  }

  /**
   * Player upsert
   */
  export type PlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the Player to update in case it exists.
     */
    where: PlayerWhereUniqueInput
    /**
     * In case the Player found by the `where` argument doesn't exist, create a new Player with this data.
     */
    create: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
    /**
     * In case the Player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
  }

  /**
   * Player delete
   */
  export type PlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter which Player to delete.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player deleteMany
   */
  export type PlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Players to delete
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to delete.
     */
    limit?: number
  }

  /**
   * Player.roster
   */
  export type Player$rosterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roster
     */
    select?: RosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roster
     */
    omit?: RosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterInclude<ExtArgs> | null
    where?: RosterWhereInput
    orderBy?: RosterOrderByWithRelationInput | RosterOrderByWithRelationInput[]
    cursor?: RosterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RosterScalarFieldEnum | RosterScalarFieldEnum[]
  }

  /**
   * Player.draftPicks
   */
  export type Player$draftPicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickInclude<ExtArgs> | null
    where?: DraftPickWhereInput
    orderBy?: DraftPickOrderByWithRelationInput | DraftPickOrderByWithRelationInput[]
    cursor?: DraftPickWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DraftPickScalarFieldEnum | DraftPickScalarFieldEnum[]
  }

  /**
   * Player.transactions
   */
  export type Player$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Player.gameStats
   */
  export type Player$gameStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStats
     */
    select?: GameStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStats
     */
    omit?: GameStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatsInclude<ExtArgs> | null
    where?: GameStatsWhereInput
    orderBy?: GameStatsOrderByWithRelationInput | GameStatsOrderByWithRelationInput[]
    cursor?: GameStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameStatsScalarFieldEnum | GameStatsScalarFieldEnum[]
  }

  /**
   * Player.weeklyProjections
   */
  export type Player$weeklyProjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyProjection
     */
    select?: WeeklyProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyProjection
     */
    omit?: WeeklyProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyProjectionInclude<ExtArgs> | null
    where?: WeeklyProjectionWhereInput
    orderBy?: WeeklyProjectionOrderByWithRelationInput | WeeklyProjectionOrderByWithRelationInput[]
    cursor?: WeeklyProjectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeeklyProjectionScalarFieldEnum | WeeklyProjectionScalarFieldEnum[]
  }

  /**
   * Player.tradeOfferPlayers
   */
  export type Player$tradeOfferPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOfferPlayer
     */
    select?: TradeOfferPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOfferPlayer
     */
    omit?: TradeOfferPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferPlayerInclude<ExtArgs> | null
    where?: TradeOfferPlayerWhereInput
    orderBy?: TradeOfferPlayerOrderByWithRelationInput | TradeOfferPlayerOrderByWithRelationInput[]
    cursor?: TradeOfferPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeOfferPlayerScalarFieldEnum | TradeOfferPlayerScalarFieldEnum[]
  }

  /**
   * Player without action
   */
  export type PlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
  }


  /**
   * Model Roster
   */

  export type AggregateRoster = {
    _count: RosterCountAggregateOutputType | null
    _avg: RosterAvgAggregateOutputType | null
    _sum: RosterSumAggregateOutputType | null
    _min: RosterMinAggregateOutputType | null
    _max: RosterMaxAggregateOutputType | null
  }

  export type RosterAvgAggregateOutputType = {
    weekAdded: number | null
  }

  export type RosterSumAggregateOutputType = {
    weekAdded: number | null
  }

  export type RosterMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    playerId: string | null
    position: $Enums.RosterPosition | null
    isStarter: boolean | null
    acquiredDate: Date | null
    weekAdded: number | null
  }

  export type RosterMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    playerId: string | null
    position: $Enums.RosterPosition | null
    isStarter: boolean | null
    acquiredDate: Date | null
    weekAdded: number | null
  }

  export type RosterCountAggregateOutputType = {
    id: number
    teamId: number
    playerId: number
    position: number
    isStarter: number
    acquiredDate: number
    weekAdded: number
    _all: number
  }


  export type RosterAvgAggregateInputType = {
    weekAdded?: true
  }

  export type RosterSumAggregateInputType = {
    weekAdded?: true
  }

  export type RosterMinAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    position?: true
    isStarter?: true
    acquiredDate?: true
    weekAdded?: true
  }

  export type RosterMaxAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    position?: true
    isStarter?: true
    acquiredDate?: true
    weekAdded?: true
  }

  export type RosterCountAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    position?: true
    isStarter?: true
    acquiredDate?: true
    weekAdded?: true
    _all?: true
  }

  export type RosterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roster to aggregate.
     */
    where?: RosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rosters to fetch.
     */
    orderBy?: RosterOrderByWithRelationInput | RosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rosters
    **/
    _count?: true | RosterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RosterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RosterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RosterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RosterMaxAggregateInputType
  }

  export type GetRosterAggregateType<T extends RosterAggregateArgs> = {
        [P in keyof T & keyof AggregateRoster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoster[P]>
      : GetScalarType<T[P], AggregateRoster[P]>
  }




  export type RosterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RosterWhereInput
    orderBy?: RosterOrderByWithAggregationInput | RosterOrderByWithAggregationInput[]
    by: RosterScalarFieldEnum[] | RosterScalarFieldEnum
    having?: RosterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RosterCountAggregateInputType | true
    _avg?: RosterAvgAggregateInputType
    _sum?: RosterSumAggregateInputType
    _min?: RosterMinAggregateInputType
    _max?: RosterMaxAggregateInputType
  }

  export type RosterGroupByOutputType = {
    id: string
    teamId: string
    playerId: string
    position: $Enums.RosterPosition
    isStarter: boolean
    acquiredDate: Date
    weekAdded: number | null
    _count: RosterCountAggregateOutputType | null
    _avg: RosterAvgAggregateOutputType | null
    _sum: RosterSumAggregateOutputType | null
    _min: RosterMinAggregateOutputType | null
    _max: RosterMaxAggregateOutputType | null
  }

  type GetRosterGroupByPayload<T extends RosterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RosterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RosterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RosterGroupByOutputType[P]>
            : GetScalarType<T[P], RosterGroupByOutputType[P]>
        }
      >
    >


  export type RosterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    position?: boolean
    isStarter?: boolean
    acquiredDate?: boolean
    weekAdded?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roster"]>

  export type RosterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    position?: boolean
    isStarter?: boolean
    acquiredDate?: boolean
    weekAdded?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roster"]>

  export type RosterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    position?: boolean
    isStarter?: boolean
    acquiredDate?: boolean
    weekAdded?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roster"]>

  export type RosterSelectScalar = {
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    position?: boolean
    isStarter?: boolean
    acquiredDate?: boolean
    weekAdded?: boolean
  }

  export type RosterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "playerId" | "position" | "isStarter" | "acquiredDate" | "weekAdded", ExtArgs["result"]["roster"]>
  export type RosterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type RosterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type RosterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $RosterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roster"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      playerId: string
      position: $Enums.RosterPosition
      isStarter: boolean
      acquiredDate: Date
      weekAdded: number | null
    }, ExtArgs["result"]["roster"]>
    composites: {}
  }

  type RosterGetPayload<S extends boolean | null | undefined | RosterDefaultArgs> = $Result.GetResult<Prisma.$RosterPayload, S>

  type RosterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RosterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RosterCountAggregateInputType | true
    }

  export interface RosterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roster'], meta: { name: 'Roster' } }
    /**
     * Find zero or one Roster that matches the filter.
     * @param {RosterFindUniqueArgs} args - Arguments to find a Roster
     * @example
     * // Get one Roster
     * const roster = await prisma.roster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RosterFindUniqueArgs>(args: SelectSubset<T, RosterFindUniqueArgs<ExtArgs>>): Prisma__RosterClient<$Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roster that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RosterFindUniqueOrThrowArgs} args - Arguments to find a Roster
     * @example
     * // Get one Roster
     * const roster = await prisma.roster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RosterFindUniqueOrThrowArgs>(args: SelectSubset<T, RosterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RosterClient<$Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterFindFirstArgs} args - Arguments to find a Roster
     * @example
     * // Get one Roster
     * const roster = await prisma.roster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RosterFindFirstArgs>(args?: SelectSubset<T, RosterFindFirstArgs<ExtArgs>>): Prisma__RosterClient<$Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterFindFirstOrThrowArgs} args - Arguments to find a Roster
     * @example
     * // Get one Roster
     * const roster = await prisma.roster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RosterFindFirstOrThrowArgs>(args?: SelectSubset<T, RosterFindFirstOrThrowArgs<ExtArgs>>): Prisma__RosterClient<$Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rosters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rosters
     * const rosters = await prisma.roster.findMany()
     * 
     * // Get first 10 Rosters
     * const rosters = await prisma.roster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rosterWithIdOnly = await prisma.roster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RosterFindManyArgs>(args?: SelectSubset<T, RosterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roster.
     * @param {RosterCreateArgs} args - Arguments to create a Roster.
     * @example
     * // Create one Roster
     * const Roster = await prisma.roster.create({
     *   data: {
     *     // ... data to create a Roster
     *   }
     * })
     * 
     */
    create<T extends RosterCreateArgs>(args: SelectSubset<T, RosterCreateArgs<ExtArgs>>): Prisma__RosterClient<$Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rosters.
     * @param {RosterCreateManyArgs} args - Arguments to create many Rosters.
     * @example
     * // Create many Rosters
     * const roster = await prisma.roster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RosterCreateManyArgs>(args?: SelectSubset<T, RosterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rosters and returns the data saved in the database.
     * @param {RosterCreateManyAndReturnArgs} args - Arguments to create many Rosters.
     * @example
     * // Create many Rosters
     * const roster = await prisma.roster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rosters and only return the `id`
     * const rosterWithIdOnly = await prisma.roster.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RosterCreateManyAndReturnArgs>(args?: SelectSubset<T, RosterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Roster.
     * @param {RosterDeleteArgs} args - Arguments to delete one Roster.
     * @example
     * // Delete one Roster
     * const Roster = await prisma.roster.delete({
     *   where: {
     *     // ... filter to delete one Roster
     *   }
     * })
     * 
     */
    delete<T extends RosterDeleteArgs>(args: SelectSubset<T, RosterDeleteArgs<ExtArgs>>): Prisma__RosterClient<$Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roster.
     * @param {RosterUpdateArgs} args - Arguments to update one Roster.
     * @example
     * // Update one Roster
     * const roster = await prisma.roster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RosterUpdateArgs>(args: SelectSubset<T, RosterUpdateArgs<ExtArgs>>): Prisma__RosterClient<$Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rosters.
     * @param {RosterDeleteManyArgs} args - Arguments to filter Rosters to delete.
     * @example
     * // Delete a few Rosters
     * const { count } = await prisma.roster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RosterDeleteManyArgs>(args?: SelectSubset<T, RosterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rosters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rosters
     * const roster = await prisma.roster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RosterUpdateManyArgs>(args: SelectSubset<T, RosterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rosters and returns the data updated in the database.
     * @param {RosterUpdateManyAndReturnArgs} args - Arguments to update many Rosters.
     * @example
     * // Update many Rosters
     * const roster = await prisma.roster.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rosters and only return the `id`
     * const rosterWithIdOnly = await prisma.roster.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RosterUpdateManyAndReturnArgs>(args: SelectSubset<T, RosterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Roster.
     * @param {RosterUpsertArgs} args - Arguments to update or create a Roster.
     * @example
     * // Update or create a Roster
     * const roster = await prisma.roster.upsert({
     *   create: {
     *     // ... data to create a Roster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roster we want to update
     *   }
     * })
     */
    upsert<T extends RosterUpsertArgs>(args: SelectSubset<T, RosterUpsertArgs<ExtArgs>>): Prisma__RosterClient<$Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rosters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterCountArgs} args - Arguments to filter Rosters to count.
     * @example
     * // Count the number of Rosters
     * const count = await prisma.roster.count({
     *   where: {
     *     // ... the filter for the Rosters we want to count
     *   }
     * })
    **/
    count<T extends RosterCountArgs>(
      args?: Subset<T, RosterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RosterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RosterAggregateArgs>(args: Subset<T, RosterAggregateArgs>): Prisma.PrismaPromise<GetRosterAggregateType<T>>

    /**
     * Group by Roster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RosterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RosterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RosterGroupByArgs['orderBy'] }
        : { orderBy?: RosterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RosterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRosterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roster model
   */
  readonly fields: RosterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RosterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roster model
   */
  interface RosterFieldRefs {
    readonly id: FieldRef<"Roster", 'String'>
    readonly teamId: FieldRef<"Roster", 'String'>
    readonly playerId: FieldRef<"Roster", 'String'>
    readonly position: FieldRef<"Roster", 'RosterPosition'>
    readonly isStarter: FieldRef<"Roster", 'Boolean'>
    readonly acquiredDate: FieldRef<"Roster", 'DateTime'>
    readonly weekAdded: FieldRef<"Roster", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Roster findUnique
   */
  export type RosterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roster
     */
    select?: RosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roster
     */
    omit?: RosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterInclude<ExtArgs> | null
    /**
     * Filter, which Roster to fetch.
     */
    where: RosterWhereUniqueInput
  }

  /**
   * Roster findUniqueOrThrow
   */
  export type RosterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roster
     */
    select?: RosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roster
     */
    omit?: RosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterInclude<ExtArgs> | null
    /**
     * Filter, which Roster to fetch.
     */
    where: RosterWhereUniqueInput
  }

  /**
   * Roster findFirst
   */
  export type RosterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roster
     */
    select?: RosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roster
     */
    omit?: RosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterInclude<ExtArgs> | null
    /**
     * Filter, which Roster to fetch.
     */
    where?: RosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rosters to fetch.
     */
    orderBy?: RosterOrderByWithRelationInput | RosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rosters.
     */
    cursor?: RosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rosters.
     */
    distinct?: RosterScalarFieldEnum | RosterScalarFieldEnum[]
  }

  /**
   * Roster findFirstOrThrow
   */
  export type RosterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roster
     */
    select?: RosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roster
     */
    omit?: RosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterInclude<ExtArgs> | null
    /**
     * Filter, which Roster to fetch.
     */
    where?: RosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rosters to fetch.
     */
    orderBy?: RosterOrderByWithRelationInput | RosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rosters.
     */
    cursor?: RosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rosters.
     */
    distinct?: RosterScalarFieldEnum | RosterScalarFieldEnum[]
  }

  /**
   * Roster findMany
   */
  export type RosterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roster
     */
    select?: RosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roster
     */
    omit?: RosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterInclude<ExtArgs> | null
    /**
     * Filter, which Rosters to fetch.
     */
    where?: RosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rosters to fetch.
     */
    orderBy?: RosterOrderByWithRelationInput | RosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rosters.
     */
    cursor?: RosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rosters.
     */
    skip?: number
    distinct?: RosterScalarFieldEnum | RosterScalarFieldEnum[]
  }

  /**
   * Roster create
   */
  export type RosterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roster
     */
    select?: RosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roster
     */
    omit?: RosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterInclude<ExtArgs> | null
    /**
     * The data needed to create a Roster.
     */
    data: XOR<RosterCreateInput, RosterUncheckedCreateInput>
  }

  /**
   * Roster createMany
   */
  export type RosterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rosters.
     */
    data: RosterCreateManyInput | RosterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roster createManyAndReturn
   */
  export type RosterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roster
     */
    select?: RosterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roster
     */
    omit?: RosterOmit<ExtArgs> | null
    /**
     * The data used to create many Rosters.
     */
    data: RosterCreateManyInput | RosterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Roster update
   */
  export type RosterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roster
     */
    select?: RosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roster
     */
    omit?: RosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterInclude<ExtArgs> | null
    /**
     * The data needed to update a Roster.
     */
    data: XOR<RosterUpdateInput, RosterUncheckedUpdateInput>
    /**
     * Choose, which Roster to update.
     */
    where: RosterWhereUniqueInput
  }

  /**
   * Roster updateMany
   */
  export type RosterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rosters.
     */
    data: XOR<RosterUpdateManyMutationInput, RosterUncheckedUpdateManyInput>
    /**
     * Filter which Rosters to update
     */
    where?: RosterWhereInput
    /**
     * Limit how many Rosters to update.
     */
    limit?: number
  }

  /**
   * Roster updateManyAndReturn
   */
  export type RosterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roster
     */
    select?: RosterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roster
     */
    omit?: RosterOmit<ExtArgs> | null
    /**
     * The data used to update Rosters.
     */
    data: XOR<RosterUpdateManyMutationInput, RosterUncheckedUpdateManyInput>
    /**
     * Filter which Rosters to update
     */
    where?: RosterWhereInput
    /**
     * Limit how many Rosters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Roster upsert
   */
  export type RosterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roster
     */
    select?: RosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roster
     */
    omit?: RosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterInclude<ExtArgs> | null
    /**
     * The filter to search for the Roster to update in case it exists.
     */
    where: RosterWhereUniqueInput
    /**
     * In case the Roster found by the `where` argument doesn't exist, create a new Roster with this data.
     */
    create: XOR<RosterCreateInput, RosterUncheckedCreateInput>
    /**
     * In case the Roster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RosterUpdateInput, RosterUncheckedUpdateInput>
  }

  /**
   * Roster delete
   */
  export type RosterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roster
     */
    select?: RosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roster
     */
    omit?: RosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterInclude<ExtArgs> | null
    /**
     * Filter which Roster to delete.
     */
    where: RosterWhereUniqueInput
  }

  /**
   * Roster deleteMany
   */
  export type RosterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rosters to delete
     */
    where?: RosterWhereInput
    /**
     * Limit how many Rosters to delete.
     */
    limit?: number
  }

  /**
   * Roster without action
   */
  export type RosterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roster
     */
    select?: RosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roster
     */
    omit?: RosterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RosterInclude<ExtArgs> | null
  }


  /**
   * Model Draft
   */

  export type AggregateDraft = {
    _count: DraftCountAggregateOutputType | null
    _avg: DraftAvgAggregateOutputType | null
    _sum: DraftSumAggregateOutputType | null
    _min: DraftMinAggregateOutputType | null
    _max: DraftMaxAggregateOutputType | null
  }

  export type DraftAvgAggregateOutputType = {
    currentRound: number | null
    currentPick: number | null
    timePerPick: number | null
  }

  export type DraftSumAggregateOutputType = {
    currentRound: number | null
    currentPick: number | null
    timePerPick: number | null
  }

  export type DraftMinAggregateOutputType = {
    id: string | null
    leagueId: string | null
    draftType: $Enums.DraftType | null
    draftDate: Date | null
    isComplete: boolean | null
    currentRound: number | null
    currentPick: number | null
    timePerPick: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DraftMaxAggregateOutputType = {
    id: string | null
    leagueId: string | null
    draftType: $Enums.DraftType | null
    draftDate: Date | null
    isComplete: boolean | null
    currentRound: number | null
    currentPick: number | null
    timePerPick: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DraftCountAggregateOutputType = {
    id: number
    leagueId: number
    draftType: number
    draftDate: number
    isComplete: number
    currentRound: number
    currentPick: number
    timePerPick: number
    draftOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DraftAvgAggregateInputType = {
    currentRound?: true
    currentPick?: true
    timePerPick?: true
  }

  export type DraftSumAggregateInputType = {
    currentRound?: true
    currentPick?: true
    timePerPick?: true
  }

  export type DraftMinAggregateInputType = {
    id?: true
    leagueId?: true
    draftType?: true
    draftDate?: true
    isComplete?: true
    currentRound?: true
    currentPick?: true
    timePerPick?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DraftMaxAggregateInputType = {
    id?: true
    leagueId?: true
    draftType?: true
    draftDate?: true
    isComplete?: true
    currentRound?: true
    currentPick?: true
    timePerPick?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DraftCountAggregateInputType = {
    id?: true
    leagueId?: true
    draftType?: true
    draftDate?: true
    isComplete?: true
    currentRound?: true
    currentPick?: true
    timePerPick?: true
    draftOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DraftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Draft to aggregate.
     */
    where?: DraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drafts to fetch.
     */
    orderBy?: DraftOrderByWithRelationInput | DraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drafts
    **/
    _count?: true | DraftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DraftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DraftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DraftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DraftMaxAggregateInputType
  }

  export type GetDraftAggregateType<T extends DraftAggregateArgs> = {
        [P in keyof T & keyof AggregateDraft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDraft[P]>
      : GetScalarType<T[P], AggregateDraft[P]>
  }




  export type DraftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftWhereInput
    orderBy?: DraftOrderByWithAggregationInput | DraftOrderByWithAggregationInput[]
    by: DraftScalarFieldEnum[] | DraftScalarFieldEnum
    having?: DraftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DraftCountAggregateInputType | true
    _avg?: DraftAvgAggregateInputType
    _sum?: DraftSumAggregateInputType
    _min?: DraftMinAggregateInputType
    _max?: DraftMaxAggregateInputType
  }

  export type DraftGroupByOutputType = {
    id: string
    leagueId: string
    draftType: $Enums.DraftType
    draftDate: Date | null
    isComplete: boolean
    currentRound: number
    currentPick: number
    timePerPick: number
    draftOrder: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DraftCountAggregateOutputType | null
    _avg: DraftAvgAggregateOutputType | null
    _sum: DraftSumAggregateOutputType | null
    _min: DraftMinAggregateOutputType | null
    _max: DraftMaxAggregateOutputType | null
  }

  type GetDraftGroupByPayload<T extends DraftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DraftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DraftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DraftGroupByOutputType[P]>
            : GetScalarType<T[P], DraftGroupByOutputType[P]>
        }
      >
    >


  export type DraftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    draftType?: boolean
    draftDate?: boolean
    isComplete?: boolean
    currentRound?: boolean
    currentPick?: boolean
    timePerPick?: boolean
    draftOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    picks?: boolean | Draft$picksArgs<ExtArgs>
    _count?: boolean | DraftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["draft"]>

  export type DraftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    draftType?: boolean
    draftDate?: boolean
    isComplete?: boolean
    currentRound?: boolean
    currentPick?: boolean
    timePerPick?: boolean
    draftOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["draft"]>

  export type DraftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    draftType?: boolean
    draftDate?: boolean
    isComplete?: boolean
    currentRound?: boolean
    currentPick?: boolean
    timePerPick?: boolean
    draftOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["draft"]>

  export type DraftSelectScalar = {
    id?: boolean
    leagueId?: boolean
    draftType?: boolean
    draftDate?: boolean
    isComplete?: boolean
    currentRound?: boolean
    currentPick?: boolean
    timePerPick?: boolean
    draftOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DraftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leagueId" | "draftType" | "draftDate" | "isComplete" | "currentRound" | "currentPick" | "timePerPick" | "draftOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["draft"]>
  export type DraftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    picks?: boolean | Draft$picksArgs<ExtArgs>
    _count?: boolean | DraftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DraftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }
  export type DraftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
  }

  export type $DraftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Draft"
    objects: {
      league: Prisma.$LeaguePayload<ExtArgs>
      picks: Prisma.$DraftPickPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leagueId: string
      draftType: $Enums.DraftType
      draftDate: Date | null
      isComplete: boolean
      currentRound: number
      currentPick: number
      timePerPick: number
      draftOrder: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["draft"]>
    composites: {}
  }

  type DraftGetPayload<S extends boolean | null | undefined | DraftDefaultArgs> = $Result.GetResult<Prisma.$DraftPayload, S>

  type DraftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DraftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DraftCountAggregateInputType | true
    }

  export interface DraftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Draft'], meta: { name: 'Draft' } }
    /**
     * Find zero or one Draft that matches the filter.
     * @param {DraftFindUniqueArgs} args - Arguments to find a Draft
     * @example
     * // Get one Draft
     * const draft = await prisma.draft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DraftFindUniqueArgs>(args: SelectSubset<T, DraftFindUniqueArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Draft that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DraftFindUniqueOrThrowArgs} args - Arguments to find a Draft
     * @example
     * // Get one Draft
     * const draft = await prisma.draft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DraftFindUniqueOrThrowArgs>(args: SelectSubset<T, DraftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Draft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftFindFirstArgs} args - Arguments to find a Draft
     * @example
     * // Get one Draft
     * const draft = await prisma.draft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DraftFindFirstArgs>(args?: SelectSubset<T, DraftFindFirstArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Draft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftFindFirstOrThrowArgs} args - Arguments to find a Draft
     * @example
     * // Get one Draft
     * const draft = await prisma.draft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DraftFindFirstOrThrowArgs>(args?: SelectSubset<T, DraftFindFirstOrThrowArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Drafts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drafts
     * const drafts = await prisma.draft.findMany()
     * 
     * // Get first 10 Drafts
     * const drafts = await prisma.draft.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const draftWithIdOnly = await prisma.draft.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DraftFindManyArgs>(args?: SelectSubset<T, DraftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Draft.
     * @param {DraftCreateArgs} args - Arguments to create a Draft.
     * @example
     * // Create one Draft
     * const Draft = await prisma.draft.create({
     *   data: {
     *     // ... data to create a Draft
     *   }
     * })
     * 
     */
    create<T extends DraftCreateArgs>(args: SelectSubset<T, DraftCreateArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Drafts.
     * @param {DraftCreateManyArgs} args - Arguments to create many Drafts.
     * @example
     * // Create many Drafts
     * const draft = await prisma.draft.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DraftCreateManyArgs>(args?: SelectSubset<T, DraftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drafts and returns the data saved in the database.
     * @param {DraftCreateManyAndReturnArgs} args - Arguments to create many Drafts.
     * @example
     * // Create many Drafts
     * const draft = await prisma.draft.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drafts and only return the `id`
     * const draftWithIdOnly = await prisma.draft.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DraftCreateManyAndReturnArgs>(args?: SelectSubset<T, DraftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Draft.
     * @param {DraftDeleteArgs} args - Arguments to delete one Draft.
     * @example
     * // Delete one Draft
     * const Draft = await prisma.draft.delete({
     *   where: {
     *     // ... filter to delete one Draft
     *   }
     * })
     * 
     */
    delete<T extends DraftDeleteArgs>(args: SelectSubset<T, DraftDeleteArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Draft.
     * @param {DraftUpdateArgs} args - Arguments to update one Draft.
     * @example
     * // Update one Draft
     * const draft = await prisma.draft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DraftUpdateArgs>(args: SelectSubset<T, DraftUpdateArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Drafts.
     * @param {DraftDeleteManyArgs} args - Arguments to filter Drafts to delete.
     * @example
     * // Delete a few Drafts
     * const { count } = await prisma.draft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DraftDeleteManyArgs>(args?: SelectSubset<T, DraftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drafts
     * const draft = await prisma.draft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DraftUpdateManyArgs>(args: SelectSubset<T, DraftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drafts and returns the data updated in the database.
     * @param {DraftUpdateManyAndReturnArgs} args - Arguments to update many Drafts.
     * @example
     * // Update many Drafts
     * const draft = await prisma.draft.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Drafts and only return the `id`
     * const draftWithIdOnly = await prisma.draft.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DraftUpdateManyAndReturnArgs>(args: SelectSubset<T, DraftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Draft.
     * @param {DraftUpsertArgs} args - Arguments to update or create a Draft.
     * @example
     * // Update or create a Draft
     * const draft = await prisma.draft.upsert({
     *   create: {
     *     // ... data to create a Draft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Draft we want to update
     *   }
     * })
     */
    upsert<T extends DraftUpsertArgs>(args: SelectSubset<T, DraftUpsertArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Drafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftCountArgs} args - Arguments to filter Drafts to count.
     * @example
     * // Count the number of Drafts
     * const count = await prisma.draft.count({
     *   where: {
     *     // ... the filter for the Drafts we want to count
     *   }
     * })
    **/
    count<T extends DraftCountArgs>(
      args?: Subset<T, DraftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DraftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Draft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DraftAggregateArgs>(args: Subset<T, DraftAggregateArgs>): Prisma.PrismaPromise<GetDraftAggregateType<T>>

    /**
     * Group by Draft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DraftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DraftGroupByArgs['orderBy'] }
        : { orderBy?: DraftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DraftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDraftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Draft model
   */
  readonly fields: DraftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Draft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DraftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    league<T extends LeagueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeagueDefaultArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    picks<T extends Draft$picksArgs<ExtArgs> = {}>(args?: Subset<T, Draft$picksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPickPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Draft model
   */
  interface DraftFieldRefs {
    readonly id: FieldRef<"Draft", 'String'>
    readonly leagueId: FieldRef<"Draft", 'String'>
    readonly draftType: FieldRef<"Draft", 'DraftType'>
    readonly draftDate: FieldRef<"Draft", 'DateTime'>
    readonly isComplete: FieldRef<"Draft", 'Boolean'>
    readonly currentRound: FieldRef<"Draft", 'Int'>
    readonly currentPick: FieldRef<"Draft", 'Int'>
    readonly timePerPick: FieldRef<"Draft", 'Int'>
    readonly draftOrder: FieldRef<"Draft", 'Json'>
    readonly createdAt: FieldRef<"Draft", 'DateTime'>
    readonly updatedAt: FieldRef<"Draft", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Draft findUnique
   */
  export type DraftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter, which Draft to fetch.
     */
    where: DraftWhereUniqueInput
  }

  /**
   * Draft findUniqueOrThrow
   */
  export type DraftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter, which Draft to fetch.
     */
    where: DraftWhereUniqueInput
  }

  /**
   * Draft findFirst
   */
  export type DraftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter, which Draft to fetch.
     */
    where?: DraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drafts to fetch.
     */
    orderBy?: DraftOrderByWithRelationInput | DraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drafts.
     */
    cursor?: DraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drafts.
     */
    distinct?: DraftScalarFieldEnum | DraftScalarFieldEnum[]
  }

  /**
   * Draft findFirstOrThrow
   */
  export type DraftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter, which Draft to fetch.
     */
    where?: DraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drafts to fetch.
     */
    orderBy?: DraftOrderByWithRelationInput | DraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drafts.
     */
    cursor?: DraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drafts.
     */
    distinct?: DraftScalarFieldEnum | DraftScalarFieldEnum[]
  }

  /**
   * Draft findMany
   */
  export type DraftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter, which Drafts to fetch.
     */
    where?: DraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drafts to fetch.
     */
    orderBy?: DraftOrderByWithRelationInput | DraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drafts.
     */
    cursor?: DraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drafts.
     */
    skip?: number
    distinct?: DraftScalarFieldEnum | DraftScalarFieldEnum[]
  }

  /**
   * Draft create
   */
  export type DraftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * The data needed to create a Draft.
     */
    data: XOR<DraftCreateInput, DraftUncheckedCreateInput>
  }

  /**
   * Draft createMany
   */
  export type DraftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drafts.
     */
    data: DraftCreateManyInput | DraftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Draft createManyAndReturn
   */
  export type DraftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * The data used to create many Drafts.
     */
    data: DraftCreateManyInput | DraftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Draft update
   */
  export type DraftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * The data needed to update a Draft.
     */
    data: XOR<DraftUpdateInput, DraftUncheckedUpdateInput>
    /**
     * Choose, which Draft to update.
     */
    where: DraftWhereUniqueInput
  }

  /**
   * Draft updateMany
   */
  export type DraftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drafts.
     */
    data: XOR<DraftUpdateManyMutationInput, DraftUncheckedUpdateManyInput>
    /**
     * Filter which Drafts to update
     */
    where?: DraftWhereInput
    /**
     * Limit how many Drafts to update.
     */
    limit?: number
  }

  /**
   * Draft updateManyAndReturn
   */
  export type DraftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * The data used to update Drafts.
     */
    data: XOR<DraftUpdateManyMutationInput, DraftUncheckedUpdateManyInput>
    /**
     * Filter which Drafts to update
     */
    where?: DraftWhereInput
    /**
     * Limit how many Drafts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Draft upsert
   */
  export type DraftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * The filter to search for the Draft to update in case it exists.
     */
    where: DraftWhereUniqueInput
    /**
     * In case the Draft found by the `where` argument doesn't exist, create a new Draft with this data.
     */
    create: XOR<DraftCreateInput, DraftUncheckedCreateInput>
    /**
     * In case the Draft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DraftUpdateInput, DraftUncheckedUpdateInput>
  }

  /**
   * Draft delete
   */
  export type DraftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter which Draft to delete.
     */
    where: DraftWhereUniqueInput
  }

  /**
   * Draft deleteMany
   */
  export type DraftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drafts to delete
     */
    where?: DraftWhereInput
    /**
     * Limit how many Drafts to delete.
     */
    limit?: number
  }

  /**
   * Draft.picks
   */
  export type Draft$picksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickInclude<ExtArgs> | null
    where?: DraftPickWhereInput
    orderBy?: DraftPickOrderByWithRelationInput | DraftPickOrderByWithRelationInput[]
    cursor?: DraftPickWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DraftPickScalarFieldEnum | DraftPickScalarFieldEnum[]
  }

  /**
   * Draft without action
   */
  export type DraftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
  }


  /**
   * Model DraftPick
   */

  export type AggregateDraftPick = {
    _count: DraftPickCountAggregateOutputType | null
    _avg: DraftPickAvgAggregateOutputType | null
    _sum: DraftPickSumAggregateOutputType | null
    _min: DraftPickMinAggregateOutputType | null
    _max: DraftPickMaxAggregateOutputType | null
  }

  export type DraftPickAvgAggregateOutputType = {
    round: number | null
    pick: number | null
    pickInRound: number | null
  }

  export type DraftPickSumAggregateOutputType = {
    round: number | null
    pick: number | null
    pickInRound: number | null
  }

  export type DraftPickMinAggregateOutputType = {
    id: string | null
    draftId: string | null
    teamId: string | null
    userId: string | null
    playerId: string | null
    round: number | null
    pick: number | null
    pickInRound: number | null
    pickTime: Date | null
    isKeeper: boolean | null
    createdAt: Date | null
  }

  export type DraftPickMaxAggregateOutputType = {
    id: string | null
    draftId: string | null
    teamId: string | null
    userId: string | null
    playerId: string | null
    round: number | null
    pick: number | null
    pickInRound: number | null
    pickTime: Date | null
    isKeeper: boolean | null
    createdAt: Date | null
  }

  export type DraftPickCountAggregateOutputType = {
    id: number
    draftId: number
    teamId: number
    userId: number
    playerId: number
    round: number
    pick: number
    pickInRound: number
    pickTime: number
    isKeeper: number
    createdAt: number
    _all: number
  }


  export type DraftPickAvgAggregateInputType = {
    round?: true
    pick?: true
    pickInRound?: true
  }

  export type DraftPickSumAggregateInputType = {
    round?: true
    pick?: true
    pickInRound?: true
  }

  export type DraftPickMinAggregateInputType = {
    id?: true
    draftId?: true
    teamId?: true
    userId?: true
    playerId?: true
    round?: true
    pick?: true
    pickInRound?: true
    pickTime?: true
    isKeeper?: true
    createdAt?: true
  }

  export type DraftPickMaxAggregateInputType = {
    id?: true
    draftId?: true
    teamId?: true
    userId?: true
    playerId?: true
    round?: true
    pick?: true
    pickInRound?: true
    pickTime?: true
    isKeeper?: true
    createdAt?: true
  }

  export type DraftPickCountAggregateInputType = {
    id?: true
    draftId?: true
    teamId?: true
    userId?: true
    playerId?: true
    round?: true
    pick?: true
    pickInRound?: true
    pickTime?: true
    isKeeper?: true
    createdAt?: true
    _all?: true
  }

  export type DraftPickAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DraftPick to aggregate.
     */
    where?: DraftPickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DraftPicks to fetch.
     */
    orderBy?: DraftPickOrderByWithRelationInput | DraftPickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DraftPickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DraftPicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DraftPicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DraftPicks
    **/
    _count?: true | DraftPickCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DraftPickAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DraftPickSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DraftPickMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DraftPickMaxAggregateInputType
  }

  export type GetDraftPickAggregateType<T extends DraftPickAggregateArgs> = {
        [P in keyof T & keyof AggregateDraftPick]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDraftPick[P]>
      : GetScalarType<T[P], AggregateDraftPick[P]>
  }




  export type DraftPickGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftPickWhereInput
    orderBy?: DraftPickOrderByWithAggregationInput | DraftPickOrderByWithAggregationInput[]
    by: DraftPickScalarFieldEnum[] | DraftPickScalarFieldEnum
    having?: DraftPickScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DraftPickCountAggregateInputType | true
    _avg?: DraftPickAvgAggregateInputType
    _sum?: DraftPickSumAggregateInputType
    _min?: DraftPickMinAggregateInputType
    _max?: DraftPickMaxAggregateInputType
  }

  export type DraftPickGroupByOutputType = {
    id: string
    draftId: string
    teamId: string
    userId: string
    playerId: string | null
    round: number
    pick: number
    pickInRound: number
    pickTime: Date | null
    isKeeper: boolean
    createdAt: Date
    _count: DraftPickCountAggregateOutputType | null
    _avg: DraftPickAvgAggregateOutputType | null
    _sum: DraftPickSumAggregateOutputType | null
    _min: DraftPickMinAggregateOutputType | null
    _max: DraftPickMaxAggregateOutputType | null
  }

  type GetDraftPickGroupByPayload<T extends DraftPickGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DraftPickGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DraftPickGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DraftPickGroupByOutputType[P]>
            : GetScalarType<T[P], DraftPickGroupByOutputType[P]>
        }
      >
    >


  export type DraftPickSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    teamId?: boolean
    userId?: boolean
    playerId?: boolean
    round?: boolean
    pick?: boolean
    pickInRound?: boolean
    pickTime?: boolean
    isKeeper?: boolean
    createdAt?: boolean
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    player?: boolean | DraftPick$playerArgs<ExtArgs>
  }, ExtArgs["result"]["draftPick"]>

  export type DraftPickSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    teamId?: boolean
    userId?: boolean
    playerId?: boolean
    round?: boolean
    pick?: boolean
    pickInRound?: boolean
    pickTime?: boolean
    isKeeper?: boolean
    createdAt?: boolean
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    player?: boolean | DraftPick$playerArgs<ExtArgs>
  }, ExtArgs["result"]["draftPick"]>

  export type DraftPickSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    draftId?: boolean
    teamId?: boolean
    userId?: boolean
    playerId?: boolean
    round?: boolean
    pick?: boolean
    pickInRound?: boolean
    pickTime?: boolean
    isKeeper?: boolean
    createdAt?: boolean
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    player?: boolean | DraftPick$playerArgs<ExtArgs>
  }, ExtArgs["result"]["draftPick"]>

  export type DraftPickSelectScalar = {
    id?: boolean
    draftId?: boolean
    teamId?: boolean
    userId?: boolean
    playerId?: boolean
    round?: boolean
    pick?: boolean
    pickInRound?: boolean
    pickTime?: boolean
    isKeeper?: boolean
    createdAt?: boolean
  }

  export type DraftPickOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "draftId" | "teamId" | "userId" | "playerId" | "round" | "pick" | "pickInRound" | "pickTime" | "isKeeper" | "createdAt", ExtArgs["result"]["draftPick"]>
  export type DraftPickInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    player?: boolean | DraftPick$playerArgs<ExtArgs>
  }
  export type DraftPickIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    player?: boolean | DraftPick$playerArgs<ExtArgs>
  }
  export type DraftPickIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    player?: boolean | DraftPick$playerArgs<ExtArgs>
  }

  export type $DraftPickPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DraftPick"
    objects: {
      draft: Prisma.$DraftPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      draftId: string
      teamId: string
      userId: string
      playerId: string | null
      round: number
      pick: number
      pickInRound: number
      pickTime: Date | null
      isKeeper: boolean
      createdAt: Date
    }, ExtArgs["result"]["draftPick"]>
    composites: {}
  }

  type DraftPickGetPayload<S extends boolean | null | undefined | DraftPickDefaultArgs> = $Result.GetResult<Prisma.$DraftPickPayload, S>

  type DraftPickCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DraftPickFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DraftPickCountAggregateInputType | true
    }

  export interface DraftPickDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DraftPick'], meta: { name: 'DraftPick' } }
    /**
     * Find zero or one DraftPick that matches the filter.
     * @param {DraftPickFindUniqueArgs} args - Arguments to find a DraftPick
     * @example
     * // Get one DraftPick
     * const draftPick = await prisma.draftPick.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DraftPickFindUniqueArgs>(args: SelectSubset<T, DraftPickFindUniqueArgs<ExtArgs>>): Prisma__DraftPickClient<$Result.GetResult<Prisma.$DraftPickPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DraftPick that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DraftPickFindUniqueOrThrowArgs} args - Arguments to find a DraftPick
     * @example
     * // Get one DraftPick
     * const draftPick = await prisma.draftPick.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DraftPickFindUniqueOrThrowArgs>(args: SelectSubset<T, DraftPickFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DraftPickClient<$Result.GetResult<Prisma.$DraftPickPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DraftPick that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftPickFindFirstArgs} args - Arguments to find a DraftPick
     * @example
     * // Get one DraftPick
     * const draftPick = await prisma.draftPick.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DraftPickFindFirstArgs>(args?: SelectSubset<T, DraftPickFindFirstArgs<ExtArgs>>): Prisma__DraftPickClient<$Result.GetResult<Prisma.$DraftPickPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DraftPick that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftPickFindFirstOrThrowArgs} args - Arguments to find a DraftPick
     * @example
     * // Get one DraftPick
     * const draftPick = await prisma.draftPick.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DraftPickFindFirstOrThrowArgs>(args?: SelectSubset<T, DraftPickFindFirstOrThrowArgs<ExtArgs>>): Prisma__DraftPickClient<$Result.GetResult<Prisma.$DraftPickPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DraftPicks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftPickFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DraftPicks
     * const draftPicks = await prisma.draftPick.findMany()
     * 
     * // Get first 10 DraftPicks
     * const draftPicks = await prisma.draftPick.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const draftPickWithIdOnly = await prisma.draftPick.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DraftPickFindManyArgs>(args?: SelectSubset<T, DraftPickFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPickPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DraftPick.
     * @param {DraftPickCreateArgs} args - Arguments to create a DraftPick.
     * @example
     * // Create one DraftPick
     * const DraftPick = await prisma.draftPick.create({
     *   data: {
     *     // ... data to create a DraftPick
     *   }
     * })
     * 
     */
    create<T extends DraftPickCreateArgs>(args: SelectSubset<T, DraftPickCreateArgs<ExtArgs>>): Prisma__DraftPickClient<$Result.GetResult<Prisma.$DraftPickPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DraftPicks.
     * @param {DraftPickCreateManyArgs} args - Arguments to create many DraftPicks.
     * @example
     * // Create many DraftPicks
     * const draftPick = await prisma.draftPick.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DraftPickCreateManyArgs>(args?: SelectSubset<T, DraftPickCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DraftPicks and returns the data saved in the database.
     * @param {DraftPickCreateManyAndReturnArgs} args - Arguments to create many DraftPicks.
     * @example
     * // Create many DraftPicks
     * const draftPick = await prisma.draftPick.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DraftPicks and only return the `id`
     * const draftPickWithIdOnly = await prisma.draftPick.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DraftPickCreateManyAndReturnArgs>(args?: SelectSubset<T, DraftPickCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPickPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DraftPick.
     * @param {DraftPickDeleteArgs} args - Arguments to delete one DraftPick.
     * @example
     * // Delete one DraftPick
     * const DraftPick = await prisma.draftPick.delete({
     *   where: {
     *     // ... filter to delete one DraftPick
     *   }
     * })
     * 
     */
    delete<T extends DraftPickDeleteArgs>(args: SelectSubset<T, DraftPickDeleteArgs<ExtArgs>>): Prisma__DraftPickClient<$Result.GetResult<Prisma.$DraftPickPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DraftPick.
     * @param {DraftPickUpdateArgs} args - Arguments to update one DraftPick.
     * @example
     * // Update one DraftPick
     * const draftPick = await prisma.draftPick.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DraftPickUpdateArgs>(args: SelectSubset<T, DraftPickUpdateArgs<ExtArgs>>): Prisma__DraftPickClient<$Result.GetResult<Prisma.$DraftPickPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DraftPicks.
     * @param {DraftPickDeleteManyArgs} args - Arguments to filter DraftPicks to delete.
     * @example
     * // Delete a few DraftPicks
     * const { count } = await prisma.draftPick.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DraftPickDeleteManyArgs>(args?: SelectSubset<T, DraftPickDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DraftPicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftPickUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DraftPicks
     * const draftPick = await prisma.draftPick.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DraftPickUpdateManyArgs>(args: SelectSubset<T, DraftPickUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DraftPicks and returns the data updated in the database.
     * @param {DraftPickUpdateManyAndReturnArgs} args - Arguments to update many DraftPicks.
     * @example
     * // Update many DraftPicks
     * const draftPick = await prisma.draftPick.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DraftPicks and only return the `id`
     * const draftPickWithIdOnly = await prisma.draftPick.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DraftPickUpdateManyAndReturnArgs>(args: SelectSubset<T, DraftPickUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPickPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DraftPick.
     * @param {DraftPickUpsertArgs} args - Arguments to update or create a DraftPick.
     * @example
     * // Update or create a DraftPick
     * const draftPick = await prisma.draftPick.upsert({
     *   create: {
     *     // ... data to create a DraftPick
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DraftPick we want to update
     *   }
     * })
     */
    upsert<T extends DraftPickUpsertArgs>(args: SelectSubset<T, DraftPickUpsertArgs<ExtArgs>>): Prisma__DraftPickClient<$Result.GetResult<Prisma.$DraftPickPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DraftPicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftPickCountArgs} args - Arguments to filter DraftPicks to count.
     * @example
     * // Count the number of DraftPicks
     * const count = await prisma.draftPick.count({
     *   where: {
     *     // ... the filter for the DraftPicks we want to count
     *   }
     * })
    **/
    count<T extends DraftPickCountArgs>(
      args?: Subset<T, DraftPickCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DraftPickCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DraftPick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftPickAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DraftPickAggregateArgs>(args: Subset<T, DraftPickAggregateArgs>): Prisma.PrismaPromise<GetDraftPickAggregateType<T>>

    /**
     * Group by DraftPick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftPickGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DraftPickGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DraftPickGroupByArgs['orderBy'] }
        : { orderBy?: DraftPickGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DraftPickGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDraftPickGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DraftPick model
   */
  readonly fields: DraftPickFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DraftPick.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DraftPickClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    draft<T extends DraftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DraftDefaultArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends DraftPick$playerArgs<ExtArgs> = {}>(args?: Subset<T, DraftPick$playerArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DraftPick model
   */
  interface DraftPickFieldRefs {
    readonly id: FieldRef<"DraftPick", 'String'>
    readonly draftId: FieldRef<"DraftPick", 'String'>
    readonly teamId: FieldRef<"DraftPick", 'String'>
    readonly userId: FieldRef<"DraftPick", 'String'>
    readonly playerId: FieldRef<"DraftPick", 'String'>
    readonly round: FieldRef<"DraftPick", 'Int'>
    readonly pick: FieldRef<"DraftPick", 'Int'>
    readonly pickInRound: FieldRef<"DraftPick", 'Int'>
    readonly pickTime: FieldRef<"DraftPick", 'DateTime'>
    readonly isKeeper: FieldRef<"DraftPick", 'Boolean'>
    readonly createdAt: FieldRef<"DraftPick", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DraftPick findUnique
   */
  export type DraftPickFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickInclude<ExtArgs> | null
    /**
     * Filter, which DraftPick to fetch.
     */
    where: DraftPickWhereUniqueInput
  }

  /**
   * DraftPick findUniqueOrThrow
   */
  export type DraftPickFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickInclude<ExtArgs> | null
    /**
     * Filter, which DraftPick to fetch.
     */
    where: DraftPickWhereUniqueInput
  }

  /**
   * DraftPick findFirst
   */
  export type DraftPickFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickInclude<ExtArgs> | null
    /**
     * Filter, which DraftPick to fetch.
     */
    where?: DraftPickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DraftPicks to fetch.
     */
    orderBy?: DraftPickOrderByWithRelationInput | DraftPickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DraftPicks.
     */
    cursor?: DraftPickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DraftPicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DraftPicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DraftPicks.
     */
    distinct?: DraftPickScalarFieldEnum | DraftPickScalarFieldEnum[]
  }

  /**
   * DraftPick findFirstOrThrow
   */
  export type DraftPickFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickInclude<ExtArgs> | null
    /**
     * Filter, which DraftPick to fetch.
     */
    where?: DraftPickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DraftPicks to fetch.
     */
    orderBy?: DraftPickOrderByWithRelationInput | DraftPickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DraftPicks.
     */
    cursor?: DraftPickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DraftPicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DraftPicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DraftPicks.
     */
    distinct?: DraftPickScalarFieldEnum | DraftPickScalarFieldEnum[]
  }

  /**
   * DraftPick findMany
   */
  export type DraftPickFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickInclude<ExtArgs> | null
    /**
     * Filter, which DraftPicks to fetch.
     */
    where?: DraftPickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DraftPicks to fetch.
     */
    orderBy?: DraftPickOrderByWithRelationInput | DraftPickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DraftPicks.
     */
    cursor?: DraftPickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DraftPicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DraftPicks.
     */
    skip?: number
    distinct?: DraftPickScalarFieldEnum | DraftPickScalarFieldEnum[]
  }

  /**
   * DraftPick create
   */
  export type DraftPickCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickInclude<ExtArgs> | null
    /**
     * The data needed to create a DraftPick.
     */
    data: XOR<DraftPickCreateInput, DraftPickUncheckedCreateInput>
  }

  /**
   * DraftPick createMany
   */
  export type DraftPickCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DraftPicks.
     */
    data: DraftPickCreateManyInput | DraftPickCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DraftPick createManyAndReturn
   */
  export type DraftPickCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * The data used to create many DraftPicks.
     */
    data: DraftPickCreateManyInput | DraftPickCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DraftPick update
   */
  export type DraftPickUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickInclude<ExtArgs> | null
    /**
     * The data needed to update a DraftPick.
     */
    data: XOR<DraftPickUpdateInput, DraftPickUncheckedUpdateInput>
    /**
     * Choose, which DraftPick to update.
     */
    where: DraftPickWhereUniqueInput
  }

  /**
   * DraftPick updateMany
   */
  export type DraftPickUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DraftPicks.
     */
    data: XOR<DraftPickUpdateManyMutationInput, DraftPickUncheckedUpdateManyInput>
    /**
     * Filter which DraftPicks to update
     */
    where?: DraftPickWhereInput
    /**
     * Limit how many DraftPicks to update.
     */
    limit?: number
  }

  /**
   * DraftPick updateManyAndReturn
   */
  export type DraftPickUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * The data used to update DraftPicks.
     */
    data: XOR<DraftPickUpdateManyMutationInput, DraftPickUncheckedUpdateManyInput>
    /**
     * Filter which DraftPicks to update
     */
    where?: DraftPickWhereInput
    /**
     * Limit how many DraftPicks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DraftPick upsert
   */
  export type DraftPickUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickInclude<ExtArgs> | null
    /**
     * The filter to search for the DraftPick to update in case it exists.
     */
    where: DraftPickWhereUniqueInput
    /**
     * In case the DraftPick found by the `where` argument doesn't exist, create a new DraftPick with this data.
     */
    create: XOR<DraftPickCreateInput, DraftPickUncheckedCreateInput>
    /**
     * In case the DraftPick was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DraftPickUpdateInput, DraftPickUncheckedUpdateInput>
  }

  /**
   * DraftPick delete
   */
  export type DraftPickDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickInclude<ExtArgs> | null
    /**
     * Filter which DraftPick to delete.
     */
    where: DraftPickWhereUniqueInput
  }

  /**
   * DraftPick deleteMany
   */
  export type DraftPickDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DraftPicks to delete
     */
    where?: DraftPickWhereInput
    /**
     * Limit how many DraftPicks to delete.
     */
    limit?: number
  }

  /**
   * DraftPick.player
   */
  export type DraftPick$playerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
  }

  /**
   * DraftPick without action
   */
  export type DraftPickDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftPick
     */
    select?: DraftPickSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftPick
     */
    omit?: DraftPickOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftPickInclude<ExtArgs> | null
  }


  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    week: number | null
    season: number | null
    homeScore: Decimal | null
    awayScore: Decimal | null
  }

  export type GameSumAggregateOutputType = {
    week: number | null
    season: number | null
    homeScore: Decimal | null
    awayScore: Decimal | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    leagueId: string | null
    homeTeamId: string | null
    awayTeamId: string | null
    week: number | null
    season: number | null
    homeScore: Decimal | null
    awayScore: Decimal | null
    isComplete: boolean | null
    isPlayoffs: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    leagueId: string | null
    homeTeamId: string | null
    awayTeamId: string | null
    week: number | null
    season: number | null
    homeScore: Decimal | null
    awayScore: Decimal | null
    isComplete: boolean | null
    isPlayoffs: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    leagueId: number
    homeTeamId: number
    awayTeamId: number
    week: number
    season: number
    homeScore: number
    awayScore: number
    isComplete: number
    isPlayoffs: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    week?: true
    season?: true
    homeScore?: true
    awayScore?: true
  }

  export type GameSumAggregateInputType = {
    week?: true
    season?: true
    homeScore?: true
    awayScore?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    leagueId?: true
    homeTeamId?: true
    awayTeamId?: true
    week?: true
    season?: true
    homeScore?: true
    awayScore?: true
    isComplete?: true
    isPlayoffs?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    leagueId?: true
    homeTeamId?: true
    awayTeamId?: true
    week?: true
    season?: true
    homeScore?: true
    awayScore?: true
    isComplete?: true
    isPlayoffs?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    leagueId?: true
    homeTeamId?: true
    awayTeamId?: true
    week?: true
    season?: true
    homeScore?: true
    awayScore?: true
    isComplete?: true
    isPlayoffs?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
    orderBy?: GameOrderByWithAggregationInput | GameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: string
    leagueId: string
    homeTeamId: string
    awayTeamId: string
    week: number
    season: number
    homeScore: Decimal
    awayScore: Decimal
    isComplete: boolean
    isPlayoffs: boolean
    createdAt: Date
    updatedAt: Date
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    week?: boolean
    season?: boolean
    homeScore?: boolean
    awayScore?: boolean
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    week?: boolean
    season?: boolean
    homeScore?: boolean
    awayScore?: boolean
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    week?: boolean
    season?: boolean
    homeScore?: boolean
    awayScore?: boolean
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectScalar = {
    id?: boolean
    leagueId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    week?: boolean
    season?: boolean
    homeScore?: boolean
    awayScore?: boolean
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leagueId" | "homeTeamId" | "awayTeamId" | "week" | "season" | "homeScore" | "awayScore" | "isComplete" | "isPlayoffs" | "createdAt" | "updatedAt", ExtArgs["result"]["game"]>
  export type GameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type GameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type GameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $GamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Game"
    objects: {
      league: Prisma.$LeaguePayload<ExtArgs>
      homeTeam: Prisma.$TeamPayload<ExtArgs>
      awayTeam: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leagueId: string
      homeTeamId: string
      awayTeamId: string
      week: number
      season: number
      homeScore: Prisma.Decimal
      awayScore: Prisma.Decimal
      isComplete: boolean
      isPlayoffs: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> = $Result.GetResult<Prisma.$GamePayload, S>

  type GameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Game'], meta: { name: 'Game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameFindUniqueArgs>(args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(args: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameFindFirstArgs>(args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameFindManyArgs>(args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends GameCreateArgs>(args: SelectSubset<T, GameCreateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Games.
     * @param {GameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCreateManyArgs>(args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {GameCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends GameDeleteArgs>(args: SelectSubset<T, GameDeleteArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUpdateArgs>(args: SelectSubset<T, GameUpdateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameDeleteManyArgs>(args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUpdateManyArgs>(args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games and returns the data updated in the database.
     * @param {GameUpdateManyAndReturnArgs} args - Arguments to update many Games.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameUpdateManyAndReturnArgs>(args: SelectSubset<T, GameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends GameUpsertArgs>(args: SelectSubset<T, GameUpsertArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Game model
   */
  readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    league<T extends LeagueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeagueDefaultArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    homeTeam<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    awayTeam<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Game model
   */
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", 'String'>
    readonly leagueId: FieldRef<"Game", 'String'>
    readonly homeTeamId: FieldRef<"Game", 'String'>
    readonly awayTeamId: FieldRef<"Game", 'String'>
    readonly week: FieldRef<"Game", 'Int'>
    readonly season: FieldRef<"Game", 'Int'>
    readonly homeScore: FieldRef<"Game", 'Decimal'>
    readonly awayScore: FieldRef<"Game", 'Decimal'>
    readonly isComplete: FieldRef<"Game", 'Boolean'>
    readonly isPlayoffs: FieldRef<"Game", 'Boolean'>
    readonly createdAt: FieldRef<"Game", 'DateTime'>
    readonly updatedAt: FieldRef<"Game", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findMany
   */
  export type GameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game create
   */
  export type GameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }

  /**
   * Game createMany
   */
  export type GameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game createManyAndReturn
   */
  export type GameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Game update
   */
  export type GameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
  }

  /**
   * Game updateManyAndReturn
   */
  export type GameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Game upsert
   */
  export type GameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }

  /**
   * Game delete
   */
  export type GameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to delete.
     */
    limit?: number
  }

  /**
   * Game without action
   */
  export type GameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    week: number | null
  }

  export type TransactionSumAggregateOutputType = {
    week: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    leagueId: string | null
    teamId: string | null
    userId: string | null
    playerId: string | null
    transactionType: $Enums.TransactionType | null
    week: number | null
    description: string | null
    isProcessed: boolean | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    leagueId: string | null
    teamId: string | null
    userId: string | null
    playerId: string | null
    transactionType: $Enums.TransactionType | null
    week: number | null
    description: string | null
    isProcessed: boolean | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    leagueId: number
    teamId: number
    userId: number
    playerId: number
    transactionType: number
    week: number
    description: number
    isProcessed: number
    processedAt: number
    createdAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    week?: true
  }

  export type TransactionSumAggregateInputType = {
    week?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    leagueId?: true
    teamId?: true
    userId?: true
    playerId?: true
    transactionType?: true
    week?: true
    description?: true
    isProcessed?: true
    processedAt?: true
    createdAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    leagueId?: true
    teamId?: true
    userId?: true
    playerId?: true
    transactionType?: true
    week?: true
    description?: true
    isProcessed?: true
    processedAt?: true
    createdAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    leagueId?: true
    teamId?: true
    userId?: true
    playerId?: true
    transactionType?: true
    week?: true
    description?: true
    isProcessed?: true
    processedAt?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    leagueId: string
    teamId: string
    userId: string
    playerId: string
    transactionType: $Enums.TransactionType
    week: number
    description: string | null
    isProcessed: boolean
    processedAt: Date | null
    createdAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    teamId?: boolean
    userId?: boolean
    playerId?: boolean
    transactionType?: boolean
    week?: boolean
    description?: boolean
    isProcessed?: boolean
    processedAt?: boolean
    createdAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    teamId?: boolean
    userId?: boolean
    playerId?: boolean
    transactionType?: boolean
    week?: boolean
    description?: boolean
    isProcessed?: boolean
    processedAt?: boolean
    createdAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    teamId?: boolean
    userId?: boolean
    playerId?: boolean
    transactionType?: boolean
    week?: boolean
    description?: boolean
    isProcessed?: boolean
    processedAt?: boolean
    createdAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    leagueId?: boolean
    teamId?: boolean
    userId?: boolean
    playerId?: boolean
    transactionType?: boolean
    week?: boolean
    description?: boolean
    isProcessed?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leagueId" | "teamId" | "userId" | "playerId" | "transactionType" | "week" | "description" | "isProcessed" | "processedAt" | "createdAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      league: Prisma.$LeaguePayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leagueId: string
      teamId: string
      userId: string
      playerId: string
      transactionType: $Enums.TransactionType
      week: number
      description: string | null
      isProcessed: boolean
      processedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    league<T extends LeagueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeagueDefaultArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly leagueId: FieldRef<"Transaction", 'String'>
    readonly teamId: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly playerId: FieldRef<"Transaction", 'String'>
    readonly transactionType: FieldRef<"Transaction", 'TransactionType'>
    readonly week: FieldRef<"Transaction", 'Int'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly isProcessed: FieldRef<"Transaction", 'Boolean'>
    readonly processedAt: FieldRef<"Transaction", 'DateTime'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model TradeOffer
   */

  export type AggregateTradeOffer = {
    _count: TradeOfferCountAggregateOutputType | null
    _min: TradeOfferMinAggregateOutputType | null
    _max: TradeOfferMaxAggregateOutputType | null
  }

  export type TradeOfferMinAggregateOutputType = {
    id: string | null
    leagueId: string | null
    offeringTeamId: string | null
    targetTeamId: string | null
    offererId: string | null
    targetId: string | null
    status: $Enums.TradeStatus | null
    note: string | null
    expiresAt: Date | null
    respondedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TradeOfferMaxAggregateOutputType = {
    id: string | null
    leagueId: string | null
    offeringTeamId: string | null
    targetTeamId: string | null
    offererId: string | null
    targetId: string | null
    status: $Enums.TradeStatus | null
    note: string | null
    expiresAt: Date | null
    respondedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TradeOfferCountAggregateOutputType = {
    id: number
    leagueId: number
    offeringTeamId: number
    targetTeamId: number
    offererId: number
    targetId: number
    status: number
    note: number
    expiresAt: number
    respondedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TradeOfferMinAggregateInputType = {
    id?: true
    leagueId?: true
    offeringTeamId?: true
    targetTeamId?: true
    offererId?: true
    targetId?: true
    status?: true
    note?: true
    expiresAt?: true
    respondedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TradeOfferMaxAggregateInputType = {
    id?: true
    leagueId?: true
    offeringTeamId?: true
    targetTeamId?: true
    offererId?: true
    targetId?: true
    status?: true
    note?: true
    expiresAt?: true
    respondedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TradeOfferCountAggregateInputType = {
    id?: true
    leagueId?: true
    offeringTeamId?: true
    targetTeamId?: true
    offererId?: true
    targetId?: true
    status?: true
    note?: true
    expiresAt?: true
    respondedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TradeOfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeOffer to aggregate.
     */
    where?: TradeOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeOffers to fetch.
     */
    orderBy?: TradeOfferOrderByWithRelationInput | TradeOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradeOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TradeOffers
    **/
    _count?: true | TradeOfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradeOfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradeOfferMaxAggregateInputType
  }

  export type GetTradeOfferAggregateType<T extends TradeOfferAggregateArgs> = {
        [P in keyof T & keyof AggregateTradeOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTradeOffer[P]>
      : GetScalarType<T[P], AggregateTradeOffer[P]>
  }




  export type TradeOfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeOfferWhereInput
    orderBy?: TradeOfferOrderByWithAggregationInput | TradeOfferOrderByWithAggregationInput[]
    by: TradeOfferScalarFieldEnum[] | TradeOfferScalarFieldEnum
    having?: TradeOfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradeOfferCountAggregateInputType | true
    _min?: TradeOfferMinAggregateInputType
    _max?: TradeOfferMaxAggregateInputType
  }

  export type TradeOfferGroupByOutputType = {
    id: string
    leagueId: string
    offeringTeamId: string
    targetTeamId: string
    offererId: string
    targetId: string
    status: $Enums.TradeStatus
    note: string | null
    expiresAt: Date | null
    respondedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TradeOfferCountAggregateOutputType | null
    _min: TradeOfferMinAggregateOutputType | null
    _max: TradeOfferMaxAggregateOutputType | null
  }

  type GetTradeOfferGroupByPayload<T extends TradeOfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradeOfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradeOfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradeOfferGroupByOutputType[P]>
            : GetScalarType<T[P], TradeOfferGroupByOutputType[P]>
        }
      >
    >


  export type TradeOfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    offeringTeamId?: boolean
    targetTeamId?: boolean
    offererId?: boolean
    targetId?: boolean
    status?: boolean
    note?: boolean
    expiresAt?: boolean
    respondedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    offeringTeam?: boolean | TeamDefaultArgs<ExtArgs>
    targetTeam?: boolean | TeamDefaultArgs<ExtArgs>
    offerer?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
    players?: boolean | TradeOffer$playersArgs<ExtArgs>
    _count?: boolean | TradeOfferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeOffer"]>

  export type TradeOfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    offeringTeamId?: boolean
    targetTeamId?: boolean
    offererId?: boolean
    targetId?: boolean
    status?: boolean
    note?: boolean
    expiresAt?: boolean
    respondedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    offeringTeam?: boolean | TeamDefaultArgs<ExtArgs>
    targetTeam?: boolean | TeamDefaultArgs<ExtArgs>
    offerer?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeOffer"]>

  export type TradeOfferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    offeringTeamId?: boolean
    targetTeamId?: boolean
    offererId?: boolean
    targetId?: boolean
    status?: boolean
    note?: boolean
    expiresAt?: boolean
    respondedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    offeringTeam?: boolean | TeamDefaultArgs<ExtArgs>
    targetTeam?: boolean | TeamDefaultArgs<ExtArgs>
    offerer?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeOffer"]>

  export type TradeOfferSelectScalar = {
    id?: boolean
    leagueId?: boolean
    offeringTeamId?: boolean
    targetTeamId?: boolean
    offererId?: boolean
    targetId?: boolean
    status?: boolean
    note?: boolean
    expiresAt?: boolean
    respondedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TradeOfferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leagueId" | "offeringTeamId" | "targetTeamId" | "offererId" | "targetId" | "status" | "note" | "expiresAt" | "respondedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["tradeOffer"]>
  export type TradeOfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    offeringTeam?: boolean | TeamDefaultArgs<ExtArgs>
    targetTeam?: boolean | TeamDefaultArgs<ExtArgs>
    offerer?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
    players?: boolean | TradeOffer$playersArgs<ExtArgs>
    _count?: boolean | TradeOfferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TradeOfferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    offeringTeam?: boolean | TeamDefaultArgs<ExtArgs>
    targetTeam?: boolean | TeamDefaultArgs<ExtArgs>
    offerer?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TradeOfferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | LeagueDefaultArgs<ExtArgs>
    offeringTeam?: boolean | TeamDefaultArgs<ExtArgs>
    targetTeam?: boolean | TeamDefaultArgs<ExtArgs>
    offerer?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TradeOfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TradeOffer"
    objects: {
      league: Prisma.$LeaguePayload<ExtArgs>
      offeringTeam: Prisma.$TeamPayload<ExtArgs>
      targetTeam: Prisma.$TeamPayload<ExtArgs>
      offerer: Prisma.$UserPayload<ExtArgs>
      target: Prisma.$UserPayload<ExtArgs>
      players: Prisma.$TradeOfferPlayerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leagueId: string
      offeringTeamId: string
      targetTeamId: string
      offererId: string
      targetId: string
      status: $Enums.TradeStatus
      note: string | null
      expiresAt: Date | null
      respondedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tradeOffer"]>
    composites: {}
  }

  type TradeOfferGetPayload<S extends boolean | null | undefined | TradeOfferDefaultArgs> = $Result.GetResult<Prisma.$TradeOfferPayload, S>

  type TradeOfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TradeOfferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TradeOfferCountAggregateInputType | true
    }

  export interface TradeOfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TradeOffer'], meta: { name: 'TradeOffer' } }
    /**
     * Find zero or one TradeOffer that matches the filter.
     * @param {TradeOfferFindUniqueArgs} args - Arguments to find a TradeOffer
     * @example
     * // Get one TradeOffer
     * const tradeOffer = await prisma.tradeOffer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TradeOfferFindUniqueArgs>(args: SelectSubset<T, TradeOfferFindUniqueArgs<ExtArgs>>): Prisma__TradeOfferClient<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TradeOffer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TradeOfferFindUniqueOrThrowArgs} args - Arguments to find a TradeOffer
     * @example
     * // Get one TradeOffer
     * const tradeOffer = await prisma.tradeOffer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TradeOfferFindUniqueOrThrowArgs>(args: SelectSubset<T, TradeOfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TradeOfferClient<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TradeOffer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeOfferFindFirstArgs} args - Arguments to find a TradeOffer
     * @example
     * // Get one TradeOffer
     * const tradeOffer = await prisma.tradeOffer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TradeOfferFindFirstArgs>(args?: SelectSubset<T, TradeOfferFindFirstArgs<ExtArgs>>): Prisma__TradeOfferClient<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TradeOffer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeOfferFindFirstOrThrowArgs} args - Arguments to find a TradeOffer
     * @example
     * // Get one TradeOffer
     * const tradeOffer = await prisma.tradeOffer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TradeOfferFindFirstOrThrowArgs>(args?: SelectSubset<T, TradeOfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__TradeOfferClient<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TradeOffers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeOfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TradeOffers
     * const tradeOffers = await prisma.tradeOffer.findMany()
     * 
     * // Get first 10 TradeOffers
     * const tradeOffers = await prisma.tradeOffer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradeOfferWithIdOnly = await prisma.tradeOffer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TradeOfferFindManyArgs>(args?: SelectSubset<T, TradeOfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TradeOffer.
     * @param {TradeOfferCreateArgs} args - Arguments to create a TradeOffer.
     * @example
     * // Create one TradeOffer
     * const TradeOffer = await prisma.tradeOffer.create({
     *   data: {
     *     // ... data to create a TradeOffer
     *   }
     * })
     * 
     */
    create<T extends TradeOfferCreateArgs>(args: SelectSubset<T, TradeOfferCreateArgs<ExtArgs>>): Prisma__TradeOfferClient<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TradeOffers.
     * @param {TradeOfferCreateManyArgs} args - Arguments to create many TradeOffers.
     * @example
     * // Create many TradeOffers
     * const tradeOffer = await prisma.tradeOffer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TradeOfferCreateManyArgs>(args?: SelectSubset<T, TradeOfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TradeOffers and returns the data saved in the database.
     * @param {TradeOfferCreateManyAndReturnArgs} args - Arguments to create many TradeOffers.
     * @example
     * // Create many TradeOffers
     * const tradeOffer = await prisma.tradeOffer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TradeOffers and only return the `id`
     * const tradeOfferWithIdOnly = await prisma.tradeOffer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TradeOfferCreateManyAndReturnArgs>(args?: SelectSubset<T, TradeOfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TradeOffer.
     * @param {TradeOfferDeleteArgs} args - Arguments to delete one TradeOffer.
     * @example
     * // Delete one TradeOffer
     * const TradeOffer = await prisma.tradeOffer.delete({
     *   where: {
     *     // ... filter to delete one TradeOffer
     *   }
     * })
     * 
     */
    delete<T extends TradeOfferDeleteArgs>(args: SelectSubset<T, TradeOfferDeleteArgs<ExtArgs>>): Prisma__TradeOfferClient<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TradeOffer.
     * @param {TradeOfferUpdateArgs} args - Arguments to update one TradeOffer.
     * @example
     * // Update one TradeOffer
     * const tradeOffer = await prisma.tradeOffer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TradeOfferUpdateArgs>(args: SelectSubset<T, TradeOfferUpdateArgs<ExtArgs>>): Prisma__TradeOfferClient<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TradeOffers.
     * @param {TradeOfferDeleteManyArgs} args - Arguments to filter TradeOffers to delete.
     * @example
     * // Delete a few TradeOffers
     * const { count } = await prisma.tradeOffer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TradeOfferDeleteManyArgs>(args?: SelectSubset<T, TradeOfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradeOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeOfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TradeOffers
     * const tradeOffer = await prisma.tradeOffer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TradeOfferUpdateManyArgs>(args: SelectSubset<T, TradeOfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradeOffers and returns the data updated in the database.
     * @param {TradeOfferUpdateManyAndReturnArgs} args - Arguments to update many TradeOffers.
     * @example
     * // Update many TradeOffers
     * const tradeOffer = await prisma.tradeOffer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TradeOffers and only return the `id`
     * const tradeOfferWithIdOnly = await prisma.tradeOffer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TradeOfferUpdateManyAndReturnArgs>(args: SelectSubset<T, TradeOfferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TradeOffer.
     * @param {TradeOfferUpsertArgs} args - Arguments to update or create a TradeOffer.
     * @example
     * // Update or create a TradeOffer
     * const tradeOffer = await prisma.tradeOffer.upsert({
     *   create: {
     *     // ... data to create a TradeOffer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TradeOffer we want to update
     *   }
     * })
     */
    upsert<T extends TradeOfferUpsertArgs>(args: SelectSubset<T, TradeOfferUpsertArgs<ExtArgs>>): Prisma__TradeOfferClient<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TradeOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeOfferCountArgs} args - Arguments to filter TradeOffers to count.
     * @example
     * // Count the number of TradeOffers
     * const count = await prisma.tradeOffer.count({
     *   where: {
     *     // ... the filter for the TradeOffers we want to count
     *   }
     * })
    **/
    count<T extends TradeOfferCountArgs>(
      args?: Subset<T, TradeOfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradeOfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TradeOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeOfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradeOfferAggregateArgs>(args: Subset<T, TradeOfferAggregateArgs>): Prisma.PrismaPromise<GetTradeOfferAggregateType<T>>

    /**
     * Group by TradeOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeOfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradeOfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradeOfferGroupByArgs['orderBy'] }
        : { orderBy?: TradeOfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradeOfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradeOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TradeOffer model
   */
  readonly fields: TradeOfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TradeOffer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradeOfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    league<T extends LeagueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeagueDefaultArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeringTeam<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    targetTeam<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offerer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    target<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    players<T extends TradeOffer$playersArgs<ExtArgs> = {}>(args?: Subset<T, TradeOffer$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeOfferPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TradeOffer model
   */
  interface TradeOfferFieldRefs {
    readonly id: FieldRef<"TradeOffer", 'String'>
    readonly leagueId: FieldRef<"TradeOffer", 'String'>
    readonly offeringTeamId: FieldRef<"TradeOffer", 'String'>
    readonly targetTeamId: FieldRef<"TradeOffer", 'String'>
    readonly offererId: FieldRef<"TradeOffer", 'String'>
    readonly targetId: FieldRef<"TradeOffer", 'String'>
    readonly status: FieldRef<"TradeOffer", 'TradeStatus'>
    readonly note: FieldRef<"TradeOffer", 'String'>
    readonly expiresAt: FieldRef<"TradeOffer", 'DateTime'>
    readonly respondedAt: FieldRef<"TradeOffer", 'DateTime'>
    readonly createdAt: FieldRef<"TradeOffer", 'DateTime'>
    readonly updatedAt: FieldRef<"TradeOffer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TradeOffer findUnique
   */
  export type TradeOfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferInclude<ExtArgs> | null
    /**
     * Filter, which TradeOffer to fetch.
     */
    where: TradeOfferWhereUniqueInput
  }

  /**
   * TradeOffer findUniqueOrThrow
   */
  export type TradeOfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferInclude<ExtArgs> | null
    /**
     * Filter, which TradeOffer to fetch.
     */
    where: TradeOfferWhereUniqueInput
  }

  /**
   * TradeOffer findFirst
   */
  export type TradeOfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferInclude<ExtArgs> | null
    /**
     * Filter, which TradeOffer to fetch.
     */
    where?: TradeOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeOffers to fetch.
     */
    orderBy?: TradeOfferOrderByWithRelationInput | TradeOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeOffers.
     */
    cursor?: TradeOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeOffers.
     */
    distinct?: TradeOfferScalarFieldEnum | TradeOfferScalarFieldEnum[]
  }

  /**
   * TradeOffer findFirstOrThrow
   */
  export type TradeOfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferInclude<ExtArgs> | null
    /**
     * Filter, which TradeOffer to fetch.
     */
    where?: TradeOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeOffers to fetch.
     */
    orderBy?: TradeOfferOrderByWithRelationInput | TradeOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeOffers.
     */
    cursor?: TradeOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeOffers.
     */
    distinct?: TradeOfferScalarFieldEnum | TradeOfferScalarFieldEnum[]
  }

  /**
   * TradeOffer findMany
   */
  export type TradeOfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferInclude<ExtArgs> | null
    /**
     * Filter, which TradeOffers to fetch.
     */
    where?: TradeOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeOffers to fetch.
     */
    orderBy?: TradeOfferOrderByWithRelationInput | TradeOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TradeOffers.
     */
    cursor?: TradeOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeOffers.
     */
    skip?: number
    distinct?: TradeOfferScalarFieldEnum | TradeOfferScalarFieldEnum[]
  }

  /**
   * TradeOffer create
   */
  export type TradeOfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferInclude<ExtArgs> | null
    /**
     * The data needed to create a TradeOffer.
     */
    data: XOR<TradeOfferCreateInput, TradeOfferUncheckedCreateInput>
  }

  /**
   * TradeOffer createMany
   */
  export type TradeOfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TradeOffers.
     */
    data: TradeOfferCreateManyInput | TradeOfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TradeOffer createManyAndReturn
   */
  export type TradeOfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * The data used to create many TradeOffers.
     */
    data: TradeOfferCreateManyInput | TradeOfferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TradeOffer update
   */
  export type TradeOfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferInclude<ExtArgs> | null
    /**
     * The data needed to update a TradeOffer.
     */
    data: XOR<TradeOfferUpdateInput, TradeOfferUncheckedUpdateInput>
    /**
     * Choose, which TradeOffer to update.
     */
    where: TradeOfferWhereUniqueInput
  }

  /**
   * TradeOffer updateMany
   */
  export type TradeOfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TradeOffers.
     */
    data: XOR<TradeOfferUpdateManyMutationInput, TradeOfferUncheckedUpdateManyInput>
    /**
     * Filter which TradeOffers to update
     */
    where?: TradeOfferWhereInput
    /**
     * Limit how many TradeOffers to update.
     */
    limit?: number
  }

  /**
   * TradeOffer updateManyAndReturn
   */
  export type TradeOfferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * The data used to update TradeOffers.
     */
    data: XOR<TradeOfferUpdateManyMutationInput, TradeOfferUncheckedUpdateManyInput>
    /**
     * Filter which TradeOffers to update
     */
    where?: TradeOfferWhereInput
    /**
     * Limit how many TradeOffers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TradeOffer upsert
   */
  export type TradeOfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferInclude<ExtArgs> | null
    /**
     * The filter to search for the TradeOffer to update in case it exists.
     */
    where: TradeOfferWhereUniqueInput
    /**
     * In case the TradeOffer found by the `where` argument doesn't exist, create a new TradeOffer with this data.
     */
    create: XOR<TradeOfferCreateInput, TradeOfferUncheckedCreateInput>
    /**
     * In case the TradeOffer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradeOfferUpdateInput, TradeOfferUncheckedUpdateInput>
  }

  /**
   * TradeOffer delete
   */
  export type TradeOfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferInclude<ExtArgs> | null
    /**
     * Filter which TradeOffer to delete.
     */
    where: TradeOfferWhereUniqueInput
  }

  /**
   * TradeOffer deleteMany
   */
  export type TradeOfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeOffers to delete
     */
    where?: TradeOfferWhereInput
    /**
     * Limit how many TradeOffers to delete.
     */
    limit?: number
  }

  /**
   * TradeOffer.players
   */
  export type TradeOffer$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOfferPlayer
     */
    select?: TradeOfferPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOfferPlayer
     */
    omit?: TradeOfferPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferPlayerInclude<ExtArgs> | null
    where?: TradeOfferPlayerWhereInput
    orderBy?: TradeOfferPlayerOrderByWithRelationInput | TradeOfferPlayerOrderByWithRelationInput[]
    cursor?: TradeOfferPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeOfferPlayerScalarFieldEnum | TradeOfferPlayerScalarFieldEnum[]
  }

  /**
   * TradeOffer without action
   */
  export type TradeOfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOffer
     */
    select?: TradeOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOffer
     */
    omit?: TradeOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferInclude<ExtArgs> | null
  }


  /**
   * Model TradeOfferPlayer
   */

  export type AggregateTradeOfferPlayer = {
    _count: TradeOfferPlayerCountAggregateOutputType | null
    _min: TradeOfferPlayerMinAggregateOutputType | null
    _max: TradeOfferPlayerMaxAggregateOutputType | null
  }

  export type TradeOfferPlayerMinAggregateOutputType = {
    id: string | null
    tradeOfferId: string | null
    playerId: string | null
    fromTeam: boolean | null
  }

  export type TradeOfferPlayerMaxAggregateOutputType = {
    id: string | null
    tradeOfferId: string | null
    playerId: string | null
    fromTeam: boolean | null
  }

  export type TradeOfferPlayerCountAggregateOutputType = {
    id: number
    tradeOfferId: number
    playerId: number
    fromTeam: number
    _all: number
  }


  export type TradeOfferPlayerMinAggregateInputType = {
    id?: true
    tradeOfferId?: true
    playerId?: true
    fromTeam?: true
  }

  export type TradeOfferPlayerMaxAggregateInputType = {
    id?: true
    tradeOfferId?: true
    playerId?: true
    fromTeam?: true
  }

  export type TradeOfferPlayerCountAggregateInputType = {
    id?: true
    tradeOfferId?: true
    playerId?: true
    fromTeam?: true
    _all?: true
  }

  export type TradeOfferPlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeOfferPlayer to aggregate.
     */
    where?: TradeOfferPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeOfferPlayers to fetch.
     */
    orderBy?: TradeOfferPlayerOrderByWithRelationInput | TradeOfferPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradeOfferPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeOfferPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeOfferPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TradeOfferPlayers
    **/
    _count?: true | TradeOfferPlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradeOfferPlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradeOfferPlayerMaxAggregateInputType
  }

  export type GetTradeOfferPlayerAggregateType<T extends TradeOfferPlayerAggregateArgs> = {
        [P in keyof T & keyof AggregateTradeOfferPlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTradeOfferPlayer[P]>
      : GetScalarType<T[P], AggregateTradeOfferPlayer[P]>
  }




  export type TradeOfferPlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeOfferPlayerWhereInput
    orderBy?: TradeOfferPlayerOrderByWithAggregationInput | TradeOfferPlayerOrderByWithAggregationInput[]
    by: TradeOfferPlayerScalarFieldEnum[] | TradeOfferPlayerScalarFieldEnum
    having?: TradeOfferPlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradeOfferPlayerCountAggregateInputType | true
    _min?: TradeOfferPlayerMinAggregateInputType
    _max?: TradeOfferPlayerMaxAggregateInputType
  }

  export type TradeOfferPlayerGroupByOutputType = {
    id: string
    tradeOfferId: string
    playerId: string
    fromTeam: boolean
    _count: TradeOfferPlayerCountAggregateOutputType | null
    _min: TradeOfferPlayerMinAggregateOutputType | null
    _max: TradeOfferPlayerMaxAggregateOutputType | null
  }

  type GetTradeOfferPlayerGroupByPayload<T extends TradeOfferPlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradeOfferPlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradeOfferPlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradeOfferPlayerGroupByOutputType[P]>
            : GetScalarType<T[P], TradeOfferPlayerGroupByOutputType[P]>
        }
      >
    >


  export type TradeOfferPlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tradeOfferId?: boolean
    playerId?: boolean
    fromTeam?: boolean
    tradeOffer?: boolean | TradeOfferDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeOfferPlayer"]>

  export type TradeOfferPlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tradeOfferId?: boolean
    playerId?: boolean
    fromTeam?: boolean
    tradeOffer?: boolean | TradeOfferDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeOfferPlayer"]>

  export type TradeOfferPlayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tradeOfferId?: boolean
    playerId?: boolean
    fromTeam?: boolean
    tradeOffer?: boolean | TradeOfferDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeOfferPlayer"]>

  export type TradeOfferPlayerSelectScalar = {
    id?: boolean
    tradeOfferId?: boolean
    playerId?: boolean
    fromTeam?: boolean
  }

  export type TradeOfferPlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tradeOfferId" | "playerId" | "fromTeam", ExtArgs["result"]["tradeOfferPlayer"]>
  export type TradeOfferPlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tradeOffer?: boolean | TradeOfferDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type TradeOfferPlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tradeOffer?: boolean | TradeOfferDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type TradeOfferPlayerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tradeOffer?: boolean | TradeOfferDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $TradeOfferPlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TradeOfferPlayer"
    objects: {
      tradeOffer: Prisma.$TradeOfferPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tradeOfferId: string
      playerId: string
      fromTeam: boolean
    }, ExtArgs["result"]["tradeOfferPlayer"]>
    composites: {}
  }

  type TradeOfferPlayerGetPayload<S extends boolean | null | undefined | TradeOfferPlayerDefaultArgs> = $Result.GetResult<Prisma.$TradeOfferPlayerPayload, S>

  type TradeOfferPlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TradeOfferPlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TradeOfferPlayerCountAggregateInputType | true
    }

  export interface TradeOfferPlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TradeOfferPlayer'], meta: { name: 'TradeOfferPlayer' } }
    /**
     * Find zero or one TradeOfferPlayer that matches the filter.
     * @param {TradeOfferPlayerFindUniqueArgs} args - Arguments to find a TradeOfferPlayer
     * @example
     * // Get one TradeOfferPlayer
     * const tradeOfferPlayer = await prisma.tradeOfferPlayer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TradeOfferPlayerFindUniqueArgs>(args: SelectSubset<T, TradeOfferPlayerFindUniqueArgs<ExtArgs>>): Prisma__TradeOfferPlayerClient<$Result.GetResult<Prisma.$TradeOfferPlayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TradeOfferPlayer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TradeOfferPlayerFindUniqueOrThrowArgs} args - Arguments to find a TradeOfferPlayer
     * @example
     * // Get one TradeOfferPlayer
     * const tradeOfferPlayer = await prisma.tradeOfferPlayer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TradeOfferPlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, TradeOfferPlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TradeOfferPlayerClient<$Result.GetResult<Prisma.$TradeOfferPlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TradeOfferPlayer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeOfferPlayerFindFirstArgs} args - Arguments to find a TradeOfferPlayer
     * @example
     * // Get one TradeOfferPlayer
     * const tradeOfferPlayer = await prisma.tradeOfferPlayer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TradeOfferPlayerFindFirstArgs>(args?: SelectSubset<T, TradeOfferPlayerFindFirstArgs<ExtArgs>>): Prisma__TradeOfferPlayerClient<$Result.GetResult<Prisma.$TradeOfferPlayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TradeOfferPlayer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeOfferPlayerFindFirstOrThrowArgs} args - Arguments to find a TradeOfferPlayer
     * @example
     * // Get one TradeOfferPlayer
     * const tradeOfferPlayer = await prisma.tradeOfferPlayer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TradeOfferPlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, TradeOfferPlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__TradeOfferPlayerClient<$Result.GetResult<Prisma.$TradeOfferPlayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TradeOfferPlayers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeOfferPlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TradeOfferPlayers
     * const tradeOfferPlayers = await prisma.tradeOfferPlayer.findMany()
     * 
     * // Get first 10 TradeOfferPlayers
     * const tradeOfferPlayers = await prisma.tradeOfferPlayer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradeOfferPlayerWithIdOnly = await prisma.tradeOfferPlayer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TradeOfferPlayerFindManyArgs>(args?: SelectSubset<T, TradeOfferPlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeOfferPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TradeOfferPlayer.
     * @param {TradeOfferPlayerCreateArgs} args - Arguments to create a TradeOfferPlayer.
     * @example
     * // Create one TradeOfferPlayer
     * const TradeOfferPlayer = await prisma.tradeOfferPlayer.create({
     *   data: {
     *     // ... data to create a TradeOfferPlayer
     *   }
     * })
     * 
     */
    create<T extends TradeOfferPlayerCreateArgs>(args: SelectSubset<T, TradeOfferPlayerCreateArgs<ExtArgs>>): Prisma__TradeOfferPlayerClient<$Result.GetResult<Prisma.$TradeOfferPlayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TradeOfferPlayers.
     * @param {TradeOfferPlayerCreateManyArgs} args - Arguments to create many TradeOfferPlayers.
     * @example
     * // Create many TradeOfferPlayers
     * const tradeOfferPlayer = await prisma.tradeOfferPlayer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TradeOfferPlayerCreateManyArgs>(args?: SelectSubset<T, TradeOfferPlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TradeOfferPlayers and returns the data saved in the database.
     * @param {TradeOfferPlayerCreateManyAndReturnArgs} args - Arguments to create many TradeOfferPlayers.
     * @example
     * // Create many TradeOfferPlayers
     * const tradeOfferPlayer = await prisma.tradeOfferPlayer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TradeOfferPlayers and only return the `id`
     * const tradeOfferPlayerWithIdOnly = await prisma.tradeOfferPlayer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TradeOfferPlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, TradeOfferPlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeOfferPlayerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TradeOfferPlayer.
     * @param {TradeOfferPlayerDeleteArgs} args - Arguments to delete one TradeOfferPlayer.
     * @example
     * // Delete one TradeOfferPlayer
     * const TradeOfferPlayer = await prisma.tradeOfferPlayer.delete({
     *   where: {
     *     // ... filter to delete one TradeOfferPlayer
     *   }
     * })
     * 
     */
    delete<T extends TradeOfferPlayerDeleteArgs>(args: SelectSubset<T, TradeOfferPlayerDeleteArgs<ExtArgs>>): Prisma__TradeOfferPlayerClient<$Result.GetResult<Prisma.$TradeOfferPlayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TradeOfferPlayer.
     * @param {TradeOfferPlayerUpdateArgs} args - Arguments to update one TradeOfferPlayer.
     * @example
     * // Update one TradeOfferPlayer
     * const tradeOfferPlayer = await prisma.tradeOfferPlayer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TradeOfferPlayerUpdateArgs>(args: SelectSubset<T, TradeOfferPlayerUpdateArgs<ExtArgs>>): Prisma__TradeOfferPlayerClient<$Result.GetResult<Prisma.$TradeOfferPlayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TradeOfferPlayers.
     * @param {TradeOfferPlayerDeleteManyArgs} args - Arguments to filter TradeOfferPlayers to delete.
     * @example
     * // Delete a few TradeOfferPlayers
     * const { count } = await prisma.tradeOfferPlayer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TradeOfferPlayerDeleteManyArgs>(args?: SelectSubset<T, TradeOfferPlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradeOfferPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeOfferPlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TradeOfferPlayers
     * const tradeOfferPlayer = await prisma.tradeOfferPlayer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TradeOfferPlayerUpdateManyArgs>(args: SelectSubset<T, TradeOfferPlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradeOfferPlayers and returns the data updated in the database.
     * @param {TradeOfferPlayerUpdateManyAndReturnArgs} args - Arguments to update many TradeOfferPlayers.
     * @example
     * // Update many TradeOfferPlayers
     * const tradeOfferPlayer = await prisma.tradeOfferPlayer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TradeOfferPlayers and only return the `id`
     * const tradeOfferPlayerWithIdOnly = await prisma.tradeOfferPlayer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TradeOfferPlayerUpdateManyAndReturnArgs>(args: SelectSubset<T, TradeOfferPlayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeOfferPlayerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TradeOfferPlayer.
     * @param {TradeOfferPlayerUpsertArgs} args - Arguments to update or create a TradeOfferPlayer.
     * @example
     * // Update or create a TradeOfferPlayer
     * const tradeOfferPlayer = await prisma.tradeOfferPlayer.upsert({
     *   create: {
     *     // ... data to create a TradeOfferPlayer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TradeOfferPlayer we want to update
     *   }
     * })
     */
    upsert<T extends TradeOfferPlayerUpsertArgs>(args: SelectSubset<T, TradeOfferPlayerUpsertArgs<ExtArgs>>): Prisma__TradeOfferPlayerClient<$Result.GetResult<Prisma.$TradeOfferPlayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TradeOfferPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeOfferPlayerCountArgs} args - Arguments to filter TradeOfferPlayers to count.
     * @example
     * // Count the number of TradeOfferPlayers
     * const count = await prisma.tradeOfferPlayer.count({
     *   where: {
     *     // ... the filter for the TradeOfferPlayers we want to count
     *   }
     * })
    **/
    count<T extends TradeOfferPlayerCountArgs>(
      args?: Subset<T, TradeOfferPlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradeOfferPlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TradeOfferPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeOfferPlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradeOfferPlayerAggregateArgs>(args: Subset<T, TradeOfferPlayerAggregateArgs>): Prisma.PrismaPromise<GetTradeOfferPlayerAggregateType<T>>

    /**
     * Group by TradeOfferPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeOfferPlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradeOfferPlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradeOfferPlayerGroupByArgs['orderBy'] }
        : { orderBy?: TradeOfferPlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradeOfferPlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradeOfferPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TradeOfferPlayer model
   */
  readonly fields: TradeOfferPlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TradeOfferPlayer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradeOfferPlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tradeOffer<T extends TradeOfferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TradeOfferDefaultArgs<ExtArgs>>): Prisma__TradeOfferClient<$Result.GetResult<Prisma.$TradeOfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TradeOfferPlayer model
   */
  interface TradeOfferPlayerFieldRefs {
    readonly id: FieldRef<"TradeOfferPlayer", 'String'>
    readonly tradeOfferId: FieldRef<"TradeOfferPlayer", 'String'>
    readonly playerId: FieldRef<"TradeOfferPlayer", 'String'>
    readonly fromTeam: FieldRef<"TradeOfferPlayer", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TradeOfferPlayer findUnique
   */
  export type TradeOfferPlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOfferPlayer
     */
    select?: TradeOfferPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOfferPlayer
     */
    omit?: TradeOfferPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferPlayerInclude<ExtArgs> | null
    /**
     * Filter, which TradeOfferPlayer to fetch.
     */
    where: TradeOfferPlayerWhereUniqueInput
  }

  /**
   * TradeOfferPlayer findUniqueOrThrow
   */
  export type TradeOfferPlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOfferPlayer
     */
    select?: TradeOfferPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOfferPlayer
     */
    omit?: TradeOfferPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferPlayerInclude<ExtArgs> | null
    /**
     * Filter, which TradeOfferPlayer to fetch.
     */
    where: TradeOfferPlayerWhereUniqueInput
  }

  /**
   * TradeOfferPlayer findFirst
   */
  export type TradeOfferPlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOfferPlayer
     */
    select?: TradeOfferPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOfferPlayer
     */
    omit?: TradeOfferPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferPlayerInclude<ExtArgs> | null
    /**
     * Filter, which TradeOfferPlayer to fetch.
     */
    where?: TradeOfferPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeOfferPlayers to fetch.
     */
    orderBy?: TradeOfferPlayerOrderByWithRelationInput | TradeOfferPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeOfferPlayers.
     */
    cursor?: TradeOfferPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeOfferPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeOfferPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeOfferPlayers.
     */
    distinct?: TradeOfferPlayerScalarFieldEnum | TradeOfferPlayerScalarFieldEnum[]
  }

  /**
   * TradeOfferPlayer findFirstOrThrow
   */
  export type TradeOfferPlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOfferPlayer
     */
    select?: TradeOfferPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOfferPlayer
     */
    omit?: TradeOfferPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferPlayerInclude<ExtArgs> | null
    /**
     * Filter, which TradeOfferPlayer to fetch.
     */
    where?: TradeOfferPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeOfferPlayers to fetch.
     */
    orderBy?: TradeOfferPlayerOrderByWithRelationInput | TradeOfferPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeOfferPlayers.
     */
    cursor?: TradeOfferPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeOfferPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeOfferPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeOfferPlayers.
     */
    distinct?: TradeOfferPlayerScalarFieldEnum | TradeOfferPlayerScalarFieldEnum[]
  }

  /**
   * TradeOfferPlayer findMany
   */
  export type TradeOfferPlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOfferPlayer
     */
    select?: TradeOfferPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOfferPlayer
     */
    omit?: TradeOfferPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferPlayerInclude<ExtArgs> | null
    /**
     * Filter, which TradeOfferPlayers to fetch.
     */
    where?: TradeOfferPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeOfferPlayers to fetch.
     */
    orderBy?: TradeOfferPlayerOrderByWithRelationInput | TradeOfferPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TradeOfferPlayers.
     */
    cursor?: TradeOfferPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeOfferPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeOfferPlayers.
     */
    skip?: number
    distinct?: TradeOfferPlayerScalarFieldEnum | TradeOfferPlayerScalarFieldEnum[]
  }

  /**
   * TradeOfferPlayer create
   */
  export type TradeOfferPlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOfferPlayer
     */
    select?: TradeOfferPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOfferPlayer
     */
    omit?: TradeOfferPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferPlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a TradeOfferPlayer.
     */
    data: XOR<TradeOfferPlayerCreateInput, TradeOfferPlayerUncheckedCreateInput>
  }

  /**
   * TradeOfferPlayer createMany
   */
  export type TradeOfferPlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TradeOfferPlayers.
     */
    data: TradeOfferPlayerCreateManyInput | TradeOfferPlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TradeOfferPlayer createManyAndReturn
   */
  export type TradeOfferPlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOfferPlayer
     */
    select?: TradeOfferPlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOfferPlayer
     */
    omit?: TradeOfferPlayerOmit<ExtArgs> | null
    /**
     * The data used to create many TradeOfferPlayers.
     */
    data: TradeOfferPlayerCreateManyInput | TradeOfferPlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferPlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TradeOfferPlayer update
   */
  export type TradeOfferPlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOfferPlayer
     */
    select?: TradeOfferPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOfferPlayer
     */
    omit?: TradeOfferPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferPlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a TradeOfferPlayer.
     */
    data: XOR<TradeOfferPlayerUpdateInput, TradeOfferPlayerUncheckedUpdateInput>
    /**
     * Choose, which TradeOfferPlayer to update.
     */
    where: TradeOfferPlayerWhereUniqueInput
  }

  /**
   * TradeOfferPlayer updateMany
   */
  export type TradeOfferPlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TradeOfferPlayers.
     */
    data: XOR<TradeOfferPlayerUpdateManyMutationInput, TradeOfferPlayerUncheckedUpdateManyInput>
    /**
     * Filter which TradeOfferPlayers to update
     */
    where?: TradeOfferPlayerWhereInput
    /**
     * Limit how many TradeOfferPlayers to update.
     */
    limit?: number
  }

  /**
   * TradeOfferPlayer updateManyAndReturn
   */
  export type TradeOfferPlayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOfferPlayer
     */
    select?: TradeOfferPlayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOfferPlayer
     */
    omit?: TradeOfferPlayerOmit<ExtArgs> | null
    /**
     * The data used to update TradeOfferPlayers.
     */
    data: XOR<TradeOfferPlayerUpdateManyMutationInput, TradeOfferPlayerUncheckedUpdateManyInput>
    /**
     * Filter which TradeOfferPlayers to update
     */
    where?: TradeOfferPlayerWhereInput
    /**
     * Limit how many TradeOfferPlayers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferPlayerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TradeOfferPlayer upsert
   */
  export type TradeOfferPlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOfferPlayer
     */
    select?: TradeOfferPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOfferPlayer
     */
    omit?: TradeOfferPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferPlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the TradeOfferPlayer to update in case it exists.
     */
    where: TradeOfferPlayerWhereUniqueInput
    /**
     * In case the TradeOfferPlayer found by the `where` argument doesn't exist, create a new TradeOfferPlayer with this data.
     */
    create: XOR<TradeOfferPlayerCreateInput, TradeOfferPlayerUncheckedCreateInput>
    /**
     * In case the TradeOfferPlayer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradeOfferPlayerUpdateInput, TradeOfferPlayerUncheckedUpdateInput>
  }

  /**
   * TradeOfferPlayer delete
   */
  export type TradeOfferPlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOfferPlayer
     */
    select?: TradeOfferPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOfferPlayer
     */
    omit?: TradeOfferPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferPlayerInclude<ExtArgs> | null
    /**
     * Filter which TradeOfferPlayer to delete.
     */
    where: TradeOfferPlayerWhereUniqueInput
  }

  /**
   * TradeOfferPlayer deleteMany
   */
  export type TradeOfferPlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeOfferPlayers to delete
     */
    where?: TradeOfferPlayerWhereInput
    /**
     * Limit how many TradeOfferPlayers to delete.
     */
    limit?: number
  }

  /**
   * TradeOfferPlayer without action
   */
  export type TradeOfferPlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeOfferPlayer
     */
    select?: TradeOfferPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TradeOfferPlayer
     */
    omit?: TradeOfferPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeOfferPlayerInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    leagueId: string | null
    senderId: string | null
    recipientId: string | null
    subject: string | null
    content: string | null
    messageType: $Enums.MessageType | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    leagueId: string | null
    senderId: string | null
    recipientId: string | null
    subject: string | null
    content: string | null
    messageType: $Enums.MessageType | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    leagueId: number
    senderId: number
    recipientId: number
    subject: number
    content: number
    messageType: number
    isRead: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    leagueId?: true
    senderId?: true
    recipientId?: true
    subject?: true
    content?: true
    messageType?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    leagueId?: true
    senderId?: true
    recipientId?: true
    subject?: true
    content?: true
    messageType?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    leagueId?: true
    senderId?: true
    recipientId?: true
    subject?: true
    content?: true
    messageType?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    leagueId: string | null
    senderId: string
    recipientId: string | null
    subject: string | null
    content: string
    messageType: $Enums.MessageType
    isRead: boolean
    readAt: Date | null
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    senderId?: boolean
    recipientId?: boolean
    subject?: boolean
    content?: boolean
    messageType?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    league?: boolean | Message$leagueArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    senderId?: boolean
    recipientId?: boolean
    subject?: boolean
    content?: boolean
    messageType?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    league?: boolean | Message$leagueArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    senderId?: boolean
    recipientId?: boolean
    subject?: boolean
    content?: boolean
    messageType?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    league?: boolean | Message$leagueArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    leagueId?: boolean
    senderId?: boolean
    recipientId?: boolean
    subject?: boolean
    content?: boolean
    messageType?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leagueId" | "senderId" | "recipientId" | "subject" | "content" | "messageType" | "isRead" | "readAt" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | Message$leagueArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | Message$leagueArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    league?: boolean | Message$leagueArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      league: Prisma.$LeaguePayload<ExtArgs> | null
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leagueId: string | null
      senderId: string
      recipientId: string | null
      subject: string | null
      content: string
      messageType: $Enums.MessageType
      isRead: boolean
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    league<T extends Message$leagueArgs<ExtArgs> = {}>(args?: Subset<T, Message$leagueArgs<ExtArgs>>): Prisma__LeagueClient<$Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly leagueId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly recipientId: FieldRef<"Message", 'String'>
    readonly subject: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly messageType: FieldRef<"Message", 'MessageType'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly readAt: FieldRef<"Message", 'DateTime'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.league
   */
  export type Message$leagueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the League
     */
    select?: LeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the League
     */
    omit?: LeagueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeagueInclude<ExtArgs> | null
    where?: LeagueWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model GameStats
   */

  export type AggregateGameStats = {
    _count: GameStatsCountAggregateOutputType | null
    _avg: GameStatsAvgAggregateOutputType | null
    _sum: GameStatsSumAggregateOutputType | null
    _min: GameStatsMinAggregateOutputType | null
    _max: GameStatsMaxAggregateOutputType | null
  }

  export type GameStatsAvgAggregateOutputType = {
    week: number | null
    season: number | null
    passingYards: number | null
    passingTds: number | null
    passingInts: number | null
    passingAttempts: number | null
    rushingYards: number | null
    rushingTds: number | null
    rushingAttempts: number | null
    receptions: number | null
    receivingYards: number | null
    receivingTds: number | null
    targets: number | null
    fumbles: number | null
    fumblesLost: number | null
    fieldGoalsMade: number | null
    fieldGoalsAttempted: number | null
    extraPointsMade: number | null
    extraPointsAttempted: number | null
    sacks: Decimal | null
    interceptions: number | null
    fumbleRecoveries: number | null
    safeties: number | null
    defensiveTds: number | null
    pointsAllowed: number | null
    fantasyPoints: Decimal | null
  }

  export type GameStatsSumAggregateOutputType = {
    week: number | null
    season: number | null
    passingYards: number | null
    passingTds: number | null
    passingInts: number | null
    passingAttempts: number | null
    rushingYards: number | null
    rushingTds: number | null
    rushingAttempts: number | null
    receptions: number | null
    receivingYards: number | null
    receivingTds: number | null
    targets: number | null
    fumbles: number | null
    fumblesLost: number | null
    fieldGoalsMade: number | null
    fieldGoalsAttempted: number | null
    extraPointsMade: number | null
    extraPointsAttempted: number | null
    sacks: Decimal | null
    interceptions: number | null
    fumbleRecoveries: number | null
    safeties: number | null
    defensiveTds: number | null
    pointsAllowed: number | null
    fantasyPoints: Decimal | null
  }

  export type GameStatsMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    week: number | null
    season: number | null
    passingYards: number | null
    passingTds: number | null
    passingInts: number | null
    passingAttempts: number | null
    rushingYards: number | null
    rushingTds: number | null
    rushingAttempts: number | null
    receptions: number | null
    receivingYards: number | null
    receivingTds: number | null
    targets: number | null
    fumbles: number | null
    fumblesLost: number | null
    fieldGoalsMade: number | null
    fieldGoalsAttempted: number | null
    extraPointsMade: number | null
    extraPointsAttempted: number | null
    sacks: Decimal | null
    interceptions: number | null
    fumbleRecoveries: number | null
    safeties: number | null
    defensiveTds: number | null
    pointsAllowed: number | null
    fantasyPoints: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameStatsMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    week: number | null
    season: number | null
    passingYards: number | null
    passingTds: number | null
    passingInts: number | null
    passingAttempts: number | null
    rushingYards: number | null
    rushingTds: number | null
    rushingAttempts: number | null
    receptions: number | null
    receivingYards: number | null
    receivingTds: number | null
    targets: number | null
    fumbles: number | null
    fumblesLost: number | null
    fieldGoalsMade: number | null
    fieldGoalsAttempted: number | null
    extraPointsMade: number | null
    extraPointsAttempted: number | null
    sacks: Decimal | null
    interceptions: number | null
    fumbleRecoveries: number | null
    safeties: number | null
    defensiveTds: number | null
    pointsAllowed: number | null
    fantasyPoints: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameStatsCountAggregateOutputType = {
    id: number
    playerId: number
    week: number
    season: number
    passingYards: number
    passingTds: number
    passingInts: number
    passingAttempts: number
    rushingYards: number
    rushingTds: number
    rushingAttempts: number
    receptions: number
    receivingYards: number
    receivingTds: number
    targets: number
    fumbles: number
    fumblesLost: number
    fieldGoalsMade: number
    fieldGoalsAttempted: number
    extraPointsMade: number
    extraPointsAttempted: number
    sacks: number
    interceptions: number
    fumbleRecoveries: number
    safeties: number
    defensiveTds: number
    pointsAllowed: number
    fantasyPoints: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameStatsAvgAggregateInputType = {
    week?: true
    season?: true
    passingYards?: true
    passingTds?: true
    passingInts?: true
    passingAttempts?: true
    rushingYards?: true
    rushingTds?: true
    rushingAttempts?: true
    receptions?: true
    receivingYards?: true
    receivingTds?: true
    targets?: true
    fumbles?: true
    fumblesLost?: true
    fieldGoalsMade?: true
    fieldGoalsAttempted?: true
    extraPointsMade?: true
    extraPointsAttempted?: true
    sacks?: true
    interceptions?: true
    fumbleRecoveries?: true
    safeties?: true
    defensiveTds?: true
    pointsAllowed?: true
    fantasyPoints?: true
  }

  export type GameStatsSumAggregateInputType = {
    week?: true
    season?: true
    passingYards?: true
    passingTds?: true
    passingInts?: true
    passingAttempts?: true
    rushingYards?: true
    rushingTds?: true
    rushingAttempts?: true
    receptions?: true
    receivingYards?: true
    receivingTds?: true
    targets?: true
    fumbles?: true
    fumblesLost?: true
    fieldGoalsMade?: true
    fieldGoalsAttempted?: true
    extraPointsMade?: true
    extraPointsAttempted?: true
    sacks?: true
    interceptions?: true
    fumbleRecoveries?: true
    safeties?: true
    defensiveTds?: true
    pointsAllowed?: true
    fantasyPoints?: true
  }

  export type GameStatsMinAggregateInputType = {
    id?: true
    playerId?: true
    week?: true
    season?: true
    passingYards?: true
    passingTds?: true
    passingInts?: true
    passingAttempts?: true
    rushingYards?: true
    rushingTds?: true
    rushingAttempts?: true
    receptions?: true
    receivingYards?: true
    receivingTds?: true
    targets?: true
    fumbles?: true
    fumblesLost?: true
    fieldGoalsMade?: true
    fieldGoalsAttempted?: true
    extraPointsMade?: true
    extraPointsAttempted?: true
    sacks?: true
    interceptions?: true
    fumbleRecoveries?: true
    safeties?: true
    defensiveTds?: true
    pointsAllowed?: true
    fantasyPoints?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameStatsMaxAggregateInputType = {
    id?: true
    playerId?: true
    week?: true
    season?: true
    passingYards?: true
    passingTds?: true
    passingInts?: true
    passingAttempts?: true
    rushingYards?: true
    rushingTds?: true
    rushingAttempts?: true
    receptions?: true
    receivingYards?: true
    receivingTds?: true
    targets?: true
    fumbles?: true
    fumblesLost?: true
    fieldGoalsMade?: true
    fieldGoalsAttempted?: true
    extraPointsMade?: true
    extraPointsAttempted?: true
    sacks?: true
    interceptions?: true
    fumbleRecoveries?: true
    safeties?: true
    defensiveTds?: true
    pointsAllowed?: true
    fantasyPoints?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameStatsCountAggregateInputType = {
    id?: true
    playerId?: true
    week?: true
    season?: true
    passingYards?: true
    passingTds?: true
    passingInts?: true
    passingAttempts?: true
    rushingYards?: true
    rushingTds?: true
    rushingAttempts?: true
    receptions?: true
    receivingYards?: true
    receivingTds?: true
    targets?: true
    fumbles?: true
    fumblesLost?: true
    fieldGoalsMade?: true
    fieldGoalsAttempted?: true
    extraPointsMade?: true
    extraPointsAttempted?: true
    sacks?: true
    interceptions?: true
    fumbleRecoveries?: true
    safeties?: true
    defensiveTds?: true
    pointsAllowed?: true
    fantasyPoints?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameStats to aggregate.
     */
    where?: GameStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameStats to fetch.
     */
    orderBy?: GameStatsOrderByWithRelationInput | GameStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameStats
    **/
    _count?: true | GameStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameStatsMaxAggregateInputType
  }

  export type GetGameStatsAggregateType<T extends GameStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateGameStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameStats[P]>
      : GetScalarType<T[P], AggregateGameStats[P]>
  }




  export type GameStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameStatsWhereInput
    orderBy?: GameStatsOrderByWithAggregationInput | GameStatsOrderByWithAggregationInput[]
    by: GameStatsScalarFieldEnum[] | GameStatsScalarFieldEnum
    having?: GameStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameStatsCountAggregateInputType | true
    _avg?: GameStatsAvgAggregateInputType
    _sum?: GameStatsSumAggregateInputType
    _min?: GameStatsMinAggregateInputType
    _max?: GameStatsMaxAggregateInputType
  }

  export type GameStatsGroupByOutputType = {
    id: string
    playerId: string
    week: number
    season: number
    passingYards: number
    passingTds: number
    passingInts: number
    passingAttempts: number
    rushingYards: number
    rushingTds: number
    rushingAttempts: number
    receptions: number
    receivingYards: number
    receivingTds: number
    targets: number
    fumbles: number
    fumblesLost: number
    fieldGoalsMade: number
    fieldGoalsAttempted: number
    extraPointsMade: number
    extraPointsAttempted: number
    sacks: Decimal
    interceptions: number
    fumbleRecoveries: number
    safeties: number
    defensiveTds: number
    pointsAllowed: number
    fantasyPoints: Decimal
    createdAt: Date
    updatedAt: Date
    _count: GameStatsCountAggregateOutputType | null
    _avg: GameStatsAvgAggregateOutputType | null
    _sum: GameStatsSumAggregateOutputType | null
    _min: GameStatsMinAggregateOutputType | null
    _max: GameStatsMaxAggregateOutputType | null
  }

  type GetGameStatsGroupByPayload<T extends GameStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameStatsGroupByOutputType[P]>
            : GetScalarType<T[P], GameStatsGroupByOutputType[P]>
        }
      >
    >


  export type GameStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    week?: boolean
    season?: boolean
    passingYards?: boolean
    passingTds?: boolean
    passingInts?: boolean
    passingAttempts?: boolean
    rushingYards?: boolean
    rushingTds?: boolean
    rushingAttempts?: boolean
    receptions?: boolean
    receivingYards?: boolean
    receivingTds?: boolean
    targets?: boolean
    fumbles?: boolean
    fumblesLost?: boolean
    fieldGoalsMade?: boolean
    fieldGoalsAttempted?: boolean
    extraPointsMade?: boolean
    extraPointsAttempted?: boolean
    sacks?: boolean
    interceptions?: boolean
    fumbleRecoveries?: boolean
    safeties?: boolean
    defensiveTds?: boolean
    pointsAllowed?: boolean
    fantasyPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameStats"]>

  export type GameStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    week?: boolean
    season?: boolean
    passingYards?: boolean
    passingTds?: boolean
    passingInts?: boolean
    passingAttempts?: boolean
    rushingYards?: boolean
    rushingTds?: boolean
    rushingAttempts?: boolean
    receptions?: boolean
    receivingYards?: boolean
    receivingTds?: boolean
    targets?: boolean
    fumbles?: boolean
    fumblesLost?: boolean
    fieldGoalsMade?: boolean
    fieldGoalsAttempted?: boolean
    extraPointsMade?: boolean
    extraPointsAttempted?: boolean
    sacks?: boolean
    interceptions?: boolean
    fumbleRecoveries?: boolean
    safeties?: boolean
    defensiveTds?: boolean
    pointsAllowed?: boolean
    fantasyPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameStats"]>

  export type GameStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    week?: boolean
    season?: boolean
    passingYards?: boolean
    passingTds?: boolean
    passingInts?: boolean
    passingAttempts?: boolean
    rushingYards?: boolean
    rushingTds?: boolean
    rushingAttempts?: boolean
    receptions?: boolean
    receivingYards?: boolean
    receivingTds?: boolean
    targets?: boolean
    fumbles?: boolean
    fumblesLost?: boolean
    fieldGoalsMade?: boolean
    fieldGoalsAttempted?: boolean
    extraPointsMade?: boolean
    extraPointsAttempted?: boolean
    sacks?: boolean
    interceptions?: boolean
    fumbleRecoveries?: boolean
    safeties?: boolean
    defensiveTds?: boolean
    pointsAllowed?: boolean
    fantasyPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameStats"]>

  export type GameStatsSelectScalar = {
    id?: boolean
    playerId?: boolean
    week?: boolean
    season?: boolean
    passingYards?: boolean
    passingTds?: boolean
    passingInts?: boolean
    passingAttempts?: boolean
    rushingYards?: boolean
    rushingTds?: boolean
    rushingAttempts?: boolean
    receptions?: boolean
    receivingYards?: boolean
    receivingTds?: boolean
    targets?: boolean
    fumbles?: boolean
    fumblesLost?: boolean
    fieldGoalsMade?: boolean
    fieldGoalsAttempted?: boolean
    extraPointsMade?: boolean
    extraPointsAttempted?: boolean
    sacks?: boolean
    interceptions?: boolean
    fumbleRecoveries?: boolean
    safeties?: boolean
    defensiveTds?: boolean
    pointsAllowed?: boolean
    fantasyPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "week" | "season" | "passingYards" | "passingTds" | "passingInts" | "passingAttempts" | "rushingYards" | "rushingTds" | "rushingAttempts" | "receptions" | "receivingYards" | "receivingTds" | "targets" | "fumbles" | "fumblesLost" | "fieldGoalsMade" | "fieldGoalsAttempted" | "extraPointsMade" | "extraPointsAttempted" | "sacks" | "interceptions" | "fumbleRecoveries" | "safeties" | "defensiveTds" | "pointsAllowed" | "fantasyPoints" | "createdAt" | "updatedAt", ExtArgs["result"]["gameStats"]>
  export type GameStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type GameStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type GameStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $GameStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameStats"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      week: number
      season: number
      passingYards: number
      passingTds: number
      passingInts: number
      passingAttempts: number
      rushingYards: number
      rushingTds: number
      rushingAttempts: number
      receptions: number
      receivingYards: number
      receivingTds: number
      targets: number
      fumbles: number
      fumblesLost: number
      fieldGoalsMade: number
      fieldGoalsAttempted: number
      extraPointsMade: number
      extraPointsAttempted: number
      sacks: Prisma.Decimal
      interceptions: number
      fumbleRecoveries: number
      safeties: number
      defensiveTds: number
      pointsAllowed: number
      fantasyPoints: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gameStats"]>
    composites: {}
  }

  type GameStatsGetPayload<S extends boolean | null | undefined | GameStatsDefaultArgs> = $Result.GetResult<Prisma.$GameStatsPayload, S>

  type GameStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameStatsCountAggregateInputType | true
    }

  export interface GameStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameStats'], meta: { name: 'GameStats' } }
    /**
     * Find zero or one GameStats that matches the filter.
     * @param {GameStatsFindUniqueArgs} args - Arguments to find a GameStats
     * @example
     * // Get one GameStats
     * const gameStats = await prisma.gameStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameStatsFindUniqueArgs>(args: SelectSubset<T, GameStatsFindUniqueArgs<ExtArgs>>): Prisma__GameStatsClient<$Result.GetResult<Prisma.$GameStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameStatsFindUniqueOrThrowArgs} args - Arguments to find a GameStats
     * @example
     * // Get one GameStats
     * const gameStats = await prisma.gameStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, GameStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameStatsClient<$Result.GetResult<Prisma.$GameStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatsFindFirstArgs} args - Arguments to find a GameStats
     * @example
     * // Get one GameStats
     * const gameStats = await prisma.gameStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameStatsFindFirstArgs>(args?: SelectSubset<T, GameStatsFindFirstArgs<ExtArgs>>): Prisma__GameStatsClient<$Result.GetResult<Prisma.$GameStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatsFindFirstOrThrowArgs} args - Arguments to find a GameStats
     * @example
     * // Get one GameStats
     * const gameStats = await prisma.gameStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, GameStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameStatsClient<$Result.GetResult<Prisma.$GameStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameStats
     * const gameStats = await prisma.gameStats.findMany()
     * 
     * // Get first 10 GameStats
     * const gameStats = await prisma.gameStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameStatsWithIdOnly = await prisma.gameStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameStatsFindManyArgs>(args?: SelectSubset<T, GameStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameStats.
     * @param {GameStatsCreateArgs} args - Arguments to create a GameStats.
     * @example
     * // Create one GameStats
     * const GameStats = await prisma.gameStats.create({
     *   data: {
     *     // ... data to create a GameStats
     *   }
     * })
     * 
     */
    create<T extends GameStatsCreateArgs>(args: SelectSubset<T, GameStatsCreateArgs<ExtArgs>>): Prisma__GameStatsClient<$Result.GetResult<Prisma.$GameStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameStats.
     * @param {GameStatsCreateManyArgs} args - Arguments to create many GameStats.
     * @example
     * // Create many GameStats
     * const gameStats = await prisma.gameStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameStatsCreateManyArgs>(args?: SelectSubset<T, GameStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameStats and returns the data saved in the database.
     * @param {GameStatsCreateManyAndReturnArgs} args - Arguments to create many GameStats.
     * @example
     * // Create many GameStats
     * const gameStats = await prisma.gameStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameStats and only return the `id`
     * const gameStatsWithIdOnly = await prisma.gameStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, GameStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameStats.
     * @param {GameStatsDeleteArgs} args - Arguments to delete one GameStats.
     * @example
     * // Delete one GameStats
     * const GameStats = await prisma.gameStats.delete({
     *   where: {
     *     // ... filter to delete one GameStats
     *   }
     * })
     * 
     */
    delete<T extends GameStatsDeleteArgs>(args: SelectSubset<T, GameStatsDeleteArgs<ExtArgs>>): Prisma__GameStatsClient<$Result.GetResult<Prisma.$GameStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameStats.
     * @param {GameStatsUpdateArgs} args - Arguments to update one GameStats.
     * @example
     * // Update one GameStats
     * const gameStats = await prisma.gameStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameStatsUpdateArgs>(args: SelectSubset<T, GameStatsUpdateArgs<ExtArgs>>): Prisma__GameStatsClient<$Result.GetResult<Prisma.$GameStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameStats.
     * @param {GameStatsDeleteManyArgs} args - Arguments to filter GameStats to delete.
     * @example
     * // Delete a few GameStats
     * const { count } = await prisma.gameStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameStatsDeleteManyArgs>(args?: SelectSubset<T, GameStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameStats
     * const gameStats = await prisma.gameStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameStatsUpdateManyArgs>(args: SelectSubset<T, GameStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameStats and returns the data updated in the database.
     * @param {GameStatsUpdateManyAndReturnArgs} args - Arguments to update many GameStats.
     * @example
     * // Update many GameStats
     * const gameStats = await prisma.gameStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameStats and only return the `id`
     * const gameStatsWithIdOnly = await prisma.gameStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, GameStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameStats.
     * @param {GameStatsUpsertArgs} args - Arguments to update or create a GameStats.
     * @example
     * // Update or create a GameStats
     * const gameStats = await prisma.gameStats.upsert({
     *   create: {
     *     // ... data to create a GameStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameStats we want to update
     *   }
     * })
     */
    upsert<T extends GameStatsUpsertArgs>(args: SelectSubset<T, GameStatsUpsertArgs<ExtArgs>>): Prisma__GameStatsClient<$Result.GetResult<Prisma.$GameStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatsCountArgs} args - Arguments to filter GameStats to count.
     * @example
     * // Count the number of GameStats
     * const count = await prisma.gameStats.count({
     *   where: {
     *     // ... the filter for the GameStats we want to count
     *   }
     * })
    **/
    count<T extends GameStatsCountArgs>(
      args?: Subset<T, GameStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameStatsAggregateArgs>(args: Subset<T, GameStatsAggregateArgs>): Prisma.PrismaPromise<GetGameStatsAggregateType<T>>

    /**
     * Group by GameStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameStatsGroupByArgs['orderBy'] }
        : { orderBy?: GameStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameStats model
   */
  readonly fields: GameStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameStats model
   */
  interface GameStatsFieldRefs {
    readonly id: FieldRef<"GameStats", 'String'>
    readonly playerId: FieldRef<"GameStats", 'String'>
    readonly week: FieldRef<"GameStats", 'Int'>
    readonly season: FieldRef<"GameStats", 'Int'>
    readonly passingYards: FieldRef<"GameStats", 'Int'>
    readonly passingTds: FieldRef<"GameStats", 'Int'>
    readonly passingInts: FieldRef<"GameStats", 'Int'>
    readonly passingAttempts: FieldRef<"GameStats", 'Int'>
    readonly rushingYards: FieldRef<"GameStats", 'Int'>
    readonly rushingTds: FieldRef<"GameStats", 'Int'>
    readonly rushingAttempts: FieldRef<"GameStats", 'Int'>
    readonly receptions: FieldRef<"GameStats", 'Int'>
    readonly receivingYards: FieldRef<"GameStats", 'Int'>
    readonly receivingTds: FieldRef<"GameStats", 'Int'>
    readonly targets: FieldRef<"GameStats", 'Int'>
    readonly fumbles: FieldRef<"GameStats", 'Int'>
    readonly fumblesLost: FieldRef<"GameStats", 'Int'>
    readonly fieldGoalsMade: FieldRef<"GameStats", 'Int'>
    readonly fieldGoalsAttempted: FieldRef<"GameStats", 'Int'>
    readonly extraPointsMade: FieldRef<"GameStats", 'Int'>
    readonly extraPointsAttempted: FieldRef<"GameStats", 'Int'>
    readonly sacks: FieldRef<"GameStats", 'Decimal'>
    readonly interceptions: FieldRef<"GameStats", 'Int'>
    readonly fumbleRecoveries: FieldRef<"GameStats", 'Int'>
    readonly safeties: FieldRef<"GameStats", 'Int'>
    readonly defensiveTds: FieldRef<"GameStats", 'Int'>
    readonly pointsAllowed: FieldRef<"GameStats", 'Int'>
    readonly fantasyPoints: FieldRef<"GameStats", 'Decimal'>
    readonly createdAt: FieldRef<"GameStats", 'DateTime'>
    readonly updatedAt: FieldRef<"GameStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameStats findUnique
   */
  export type GameStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStats
     */
    select?: GameStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStats
     */
    omit?: GameStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatsInclude<ExtArgs> | null
    /**
     * Filter, which GameStats to fetch.
     */
    where: GameStatsWhereUniqueInput
  }

  /**
   * GameStats findUniqueOrThrow
   */
  export type GameStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStats
     */
    select?: GameStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStats
     */
    omit?: GameStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatsInclude<ExtArgs> | null
    /**
     * Filter, which GameStats to fetch.
     */
    where: GameStatsWhereUniqueInput
  }

  /**
   * GameStats findFirst
   */
  export type GameStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStats
     */
    select?: GameStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStats
     */
    omit?: GameStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatsInclude<ExtArgs> | null
    /**
     * Filter, which GameStats to fetch.
     */
    where?: GameStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameStats to fetch.
     */
    orderBy?: GameStatsOrderByWithRelationInput | GameStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameStats.
     */
    cursor?: GameStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameStats.
     */
    distinct?: GameStatsScalarFieldEnum | GameStatsScalarFieldEnum[]
  }

  /**
   * GameStats findFirstOrThrow
   */
  export type GameStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStats
     */
    select?: GameStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStats
     */
    omit?: GameStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatsInclude<ExtArgs> | null
    /**
     * Filter, which GameStats to fetch.
     */
    where?: GameStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameStats to fetch.
     */
    orderBy?: GameStatsOrderByWithRelationInput | GameStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameStats.
     */
    cursor?: GameStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameStats.
     */
    distinct?: GameStatsScalarFieldEnum | GameStatsScalarFieldEnum[]
  }

  /**
   * GameStats findMany
   */
  export type GameStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStats
     */
    select?: GameStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStats
     */
    omit?: GameStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatsInclude<ExtArgs> | null
    /**
     * Filter, which GameStats to fetch.
     */
    where?: GameStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameStats to fetch.
     */
    orderBy?: GameStatsOrderByWithRelationInput | GameStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameStats.
     */
    cursor?: GameStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameStats.
     */
    skip?: number
    distinct?: GameStatsScalarFieldEnum | GameStatsScalarFieldEnum[]
  }

  /**
   * GameStats create
   */
  export type GameStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStats
     */
    select?: GameStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStats
     */
    omit?: GameStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a GameStats.
     */
    data: XOR<GameStatsCreateInput, GameStatsUncheckedCreateInput>
  }

  /**
   * GameStats createMany
   */
  export type GameStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameStats.
     */
    data: GameStatsCreateManyInput | GameStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameStats createManyAndReturn
   */
  export type GameStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStats
     */
    select?: GameStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameStats
     */
    omit?: GameStatsOmit<ExtArgs> | null
    /**
     * The data used to create many GameStats.
     */
    data: GameStatsCreateManyInput | GameStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameStats update
   */
  export type GameStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStats
     */
    select?: GameStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStats
     */
    omit?: GameStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a GameStats.
     */
    data: XOR<GameStatsUpdateInput, GameStatsUncheckedUpdateInput>
    /**
     * Choose, which GameStats to update.
     */
    where: GameStatsWhereUniqueInput
  }

  /**
   * GameStats updateMany
   */
  export type GameStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameStats.
     */
    data: XOR<GameStatsUpdateManyMutationInput, GameStatsUncheckedUpdateManyInput>
    /**
     * Filter which GameStats to update
     */
    where?: GameStatsWhereInput
    /**
     * Limit how many GameStats to update.
     */
    limit?: number
  }

  /**
   * GameStats updateManyAndReturn
   */
  export type GameStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStats
     */
    select?: GameStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameStats
     */
    omit?: GameStatsOmit<ExtArgs> | null
    /**
     * The data used to update GameStats.
     */
    data: XOR<GameStatsUpdateManyMutationInput, GameStatsUncheckedUpdateManyInput>
    /**
     * Filter which GameStats to update
     */
    where?: GameStatsWhereInput
    /**
     * Limit how many GameStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameStats upsert
   */
  export type GameStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStats
     */
    select?: GameStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStats
     */
    omit?: GameStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the GameStats to update in case it exists.
     */
    where: GameStatsWhereUniqueInput
    /**
     * In case the GameStats found by the `where` argument doesn't exist, create a new GameStats with this data.
     */
    create: XOR<GameStatsCreateInput, GameStatsUncheckedCreateInput>
    /**
     * In case the GameStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameStatsUpdateInput, GameStatsUncheckedUpdateInput>
  }

  /**
   * GameStats delete
   */
  export type GameStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStats
     */
    select?: GameStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStats
     */
    omit?: GameStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatsInclude<ExtArgs> | null
    /**
     * Filter which GameStats to delete.
     */
    where: GameStatsWhereUniqueInput
  }

  /**
   * GameStats deleteMany
   */
  export type GameStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameStats to delete
     */
    where?: GameStatsWhereInput
    /**
     * Limit how many GameStats to delete.
     */
    limit?: number
  }

  /**
   * GameStats without action
   */
  export type GameStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameStats
     */
    select?: GameStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameStats
     */
    omit?: GameStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameStatsInclude<ExtArgs> | null
  }


  /**
   * Model WeeklyProjection
   */

  export type AggregateWeeklyProjection = {
    _count: WeeklyProjectionCountAggregateOutputType | null
    _avg: WeeklyProjectionAvgAggregateOutputType | null
    _sum: WeeklyProjectionSumAggregateOutputType | null
    _min: WeeklyProjectionMinAggregateOutputType | null
    _max: WeeklyProjectionMaxAggregateOutputType | null
  }

  export type WeeklyProjectionAvgAggregateOutputType = {
    week: number | null
    season: number | null
    projectedPoints: Decimal | null
    confidence: Decimal | null
    projPassingYards: Decimal | null
    projPassingTds: Decimal | null
    projRushingYards: Decimal | null
    projRushingTds: Decimal | null
    projReceptions: Decimal | null
    projReceivingYards: Decimal | null
    projReceivingTds: Decimal | null
  }

  export type WeeklyProjectionSumAggregateOutputType = {
    week: number | null
    season: number | null
    projectedPoints: Decimal | null
    confidence: Decimal | null
    projPassingYards: Decimal | null
    projPassingTds: Decimal | null
    projRushingYards: Decimal | null
    projRushingTds: Decimal | null
    projReceptions: Decimal | null
    projReceivingYards: Decimal | null
    projReceivingTds: Decimal | null
  }

  export type WeeklyProjectionMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    week: number | null
    season: number | null
    projectedPoints: Decimal | null
    confidence: Decimal | null
    projPassingYards: Decimal | null
    projPassingTds: Decimal | null
    projRushingYards: Decimal | null
    projRushingTds: Decimal | null
    projReceptions: Decimal | null
    projReceivingYards: Decimal | null
    projReceivingTds: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeeklyProjectionMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    week: number | null
    season: number | null
    projectedPoints: Decimal | null
    confidence: Decimal | null
    projPassingYards: Decimal | null
    projPassingTds: Decimal | null
    projRushingYards: Decimal | null
    projRushingTds: Decimal | null
    projReceptions: Decimal | null
    projReceivingYards: Decimal | null
    projReceivingTds: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeeklyProjectionCountAggregateOutputType = {
    id: number
    playerId: number
    week: number
    season: number
    projectedPoints: number
    confidence: number
    projPassingYards: number
    projPassingTds: number
    projRushingYards: number
    projRushingTds: number
    projReceptions: number
    projReceivingYards: number
    projReceivingTds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WeeklyProjectionAvgAggregateInputType = {
    week?: true
    season?: true
    projectedPoints?: true
    confidence?: true
    projPassingYards?: true
    projPassingTds?: true
    projRushingYards?: true
    projRushingTds?: true
    projReceptions?: true
    projReceivingYards?: true
    projReceivingTds?: true
  }

  export type WeeklyProjectionSumAggregateInputType = {
    week?: true
    season?: true
    projectedPoints?: true
    confidence?: true
    projPassingYards?: true
    projPassingTds?: true
    projRushingYards?: true
    projRushingTds?: true
    projReceptions?: true
    projReceivingYards?: true
    projReceivingTds?: true
  }

  export type WeeklyProjectionMinAggregateInputType = {
    id?: true
    playerId?: true
    week?: true
    season?: true
    projectedPoints?: true
    confidence?: true
    projPassingYards?: true
    projPassingTds?: true
    projRushingYards?: true
    projRushingTds?: true
    projReceptions?: true
    projReceivingYards?: true
    projReceivingTds?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeeklyProjectionMaxAggregateInputType = {
    id?: true
    playerId?: true
    week?: true
    season?: true
    projectedPoints?: true
    confidence?: true
    projPassingYards?: true
    projPassingTds?: true
    projRushingYards?: true
    projRushingTds?: true
    projReceptions?: true
    projReceivingYards?: true
    projReceivingTds?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeeklyProjectionCountAggregateInputType = {
    id?: true
    playerId?: true
    week?: true
    season?: true
    projectedPoints?: true
    confidence?: true
    projPassingYards?: true
    projPassingTds?: true
    projRushingYards?: true
    projRushingTds?: true
    projReceptions?: true
    projReceivingYards?: true
    projReceivingTds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WeeklyProjectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyProjection to aggregate.
     */
    where?: WeeklyProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyProjections to fetch.
     */
    orderBy?: WeeklyProjectionOrderByWithRelationInput | WeeklyProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeeklyProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyProjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeeklyProjections
    **/
    _count?: true | WeeklyProjectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeeklyProjectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeeklyProjectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeeklyProjectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeeklyProjectionMaxAggregateInputType
  }

  export type GetWeeklyProjectionAggregateType<T extends WeeklyProjectionAggregateArgs> = {
        [P in keyof T & keyof AggregateWeeklyProjection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeeklyProjection[P]>
      : GetScalarType<T[P], AggregateWeeklyProjection[P]>
  }




  export type WeeklyProjectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyProjectionWhereInput
    orderBy?: WeeklyProjectionOrderByWithAggregationInput | WeeklyProjectionOrderByWithAggregationInput[]
    by: WeeklyProjectionScalarFieldEnum[] | WeeklyProjectionScalarFieldEnum
    having?: WeeklyProjectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeeklyProjectionCountAggregateInputType | true
    _avg?: WeeklyProjectionAvgAggregateInputType
    _sum?: WeeklyProjectionSumAggregateInputType
    _min?: WeeklyProjectionMinAggregateInputType
    _max?: WeeklyProjectionMaxAggregateInputType
  }

  export type WeeklyProjectionGroupByOutputType = {
    id: string
    playerId: string
    week: number
    season: number
    projectedPoints: Decimal
    confidence: Decimal
    projPassingYards: Decimal
    projPassingTds: Decimal
    projRushingYards: Decimal
    projRushingTds: Decimal
    projReceptions: Decimal
    projReceivingYards: Decimal
    projReceivingTds: Decimal
    createdAt: Date
    updatedAt: Date
    _count: WeeklyProjectionCountAggregateOutputType | null
    _avg: WeeklyProjectionAvgAggregateOutputType | null
    _sum: WeeklyProjectionSumAggregateOutputType | null
    _min: WeeklyProjectionMinAggregateOutputType | null
    _max: WeeklyProjectionMaxAggregateOutputType | null
  }

  type GetWeeklyProjectionGroupByPayload<T extends WeeklyProjectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeeklyProjectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeeklyProjectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeeklyProjectionGroupByOutputType[P]>
            : GetScalarType<T[P], WeeklyProjectionGroupByOutputType[P]>
        }
      >
    >


  export type WeeklyProjectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    week?: boolean
    season?: boolean
    projectedPoints?: boolean
    confidence?: boolean
    projPassingYards?: boolean
    projPassingTds?: boolean
    projRushingYards?: boolean
    projRushingTds?: boolean
    projReceptions?: boolean
    projReceivingYards?: boolean
    projReceivingTds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyProjection"]>

  export type WeeklyProjectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    week?: boolean
    season?: boolean
    projectedPoints?: boolean
    confidence?: boolean
    projPassingYards?: boolean
    projPassingTds?: boolean
    projRushingYards?: boolean
    projRushingTds?: boolean
    projReceptions?: boolean
    projReceivingYards?: boolean
    projReceivingTds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyProjection"]>

  export type WeeklyProjectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    week?: boolean
    season?: boolean
    projectedPoints?: boolean
    confidence?: boolean
    projPassingYards?: boolean
    projPassingTds?: boolean
    projRushingYards?: boolean
    projRushingTds?: boolean
    projReceptions?: boolean
    projReceivingYards?: boolean
    projReceivingTds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyProjection"]>

  export type WeeklyProjectionSelectScalar = {
    id?: boolean
    playerId?: boolean
    week?: boolean
    season?: boolean
    projectedPoints?: boolean
    confidence?: boolean
    projPassingYards?: boolean
    projPassingTds?: boolean
    projRushingYards?: boolean
    projRushingTds?: boolean
    projReceptions?: boolean
    projReceivingYards?: boolean
    projReceivingTds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WeeklyProjectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "week" | "season" | "projectedPoints" | "confidence" | "projPassingYards" | "projPassingTds" | "projRushingYards" | "projRushingTds" | "projReceptions" | "projReceivingYards" | "projReceivingTds" | "createdAt" | "updatedAt", ExtArgs["result"]["weeklyProjection"]>
  export type WeeklyProjectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type WeeklyProjectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type WeeklyProjectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $WeeklyProjectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeeklyProjection"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      week: number
      season: number
      projectedPoints: Prisma.Decimal
      confidence: Prisma.Decimal
      projPassingYards: Prisma.Decimal
      projPassingTds: Prisma.Decimal
      projRushingYards: Prisma.Decimal
      projRushingTds: Prisma.Decimal
      projReceptions: Prisma.Decimal
      projReceivingYards: Prisma.Decimal
      projReceivingTds: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["weeklyProjection"]>
    composites: {}
  }

  type WeeklyProjectionGetPayload<S extends boolean | null | undefined | WeeklyProjectionDefaultArgs> = $Result.GetResult<Prisma.$WeeklyProjectionPayload, S>

  type WeeklyProjectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeeklyProjectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeeklyProjectionCountAggregateInputType | true
    }

  export interface WeeklyProjectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeeklyProjection'], meta: { name: 'WeeklyProjection' } }
    /**
     * Find zero or one WeeklyProjection that matches the filter.
     * @param {WeeklyProjectionFindUniqueArgs} args - Arguments to find a WeeklyProjection
     * @example
     * // Get one WeeklyProjection
     * const weeklyProjection = await prisma.weeklyProjection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeeklyProjectionFindUniqueArgs>(args: SelectSubset<T, WeeklyProjectionFindUniqueArgs<ExtArgs>>): Prisma__WeeklyProjectionClient<$Result.GetResult<Prisma.$WeeklyProjectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WeeklyProjection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeeklyProjectionFindUniqueOrThrowArgs} args - Arguments to find a WeeklyProjection
     * @example
     * // Get one WeeklyProjection
     * const weeklyProjection = await prisma.weeklyProjection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeeklyProjectionFindUniqueOrThrowArgs>(args: SelectSubset<T, WeeklyProjectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeeklyProjectionClient<$Result.GetResult<Prisma.$WeeklyProjectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeeklyProjection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyProjectionFindFirstArgs} args - Arguments to find a WeeklyProjection
     * @example
     * // Get one WeeklyProjection
     * const weeklyProjection = await prisma.weeklyProjection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeeklyProjectionFindFirstArgs>(args?: SelectSubset<T, WeeklyProjectionFindFirstArgs<ExtArgs>>): Prisma__WeeklyProjectionClient<$Result.GetResult<Prisma.$WeeklyProjectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeeklyProjection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyProjectionFindFirstOrThrowArgs} args - Arguments to find a WeeklyProjection
     * @example
     * // Get one WeeklyProjection
     * const weeklyProjection = await prisma.weeklyProjection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeeklyProjectionFindFirstOrThrowArgs>(args?: SelectSubset<T, WeeklyProjectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeeklyProjectionClient<$Result.GetResult<Prisma.$WeeklyProjectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WeeklyProjections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyProjectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeeklyProjections
     * const weeklyProjections = await prisma.weeklyProjection.findMany()
     * 
     * // Get first 10 WeeklyProjections
     * const weeklyProjections = await prisma.weeklyProjection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weeklyProjectionWithIdOnly = await prisma.weeklyProjection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeeklyProjectionFindManyArgs>(args?: SelectSubset<T, WeeklyProjectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyProjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WeeklyProjection.
     * @param {WeeklyProjectionCreateArgs} args - Arguments to create a WeeklyProjection.
     * @example
     * // Create one WeeklyProjection
     * const WeeklyProjection = await prisma.weeklyProjection.create({
     *   data: {
     *     // ... data to create a WeeklyProjection
     *   }
     * })
     * 
     */
    create<T extends WeeklyProjectionCreateArgs>(args: SelectSubset<T, WeeklyProjectionCreateArgs<ExtArgs>>): Prisma__WeeklyProjectionClient<$Result.GetResult<Prisma.$WeeklyProjectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WeeklyProjections.
     * @param {WeeklyProjectionCreateManyArgs} args - Arguments to create many WeeklyProjections.
     * @example
     * // Create many WeeklyProjections
     * const weeklyProjection = await prisma.weeklyProjection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeeklyProjectionCreateManyArgs>(args?: SelectSubset<T, WeeklyProjectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeeklyProjections and returns the data saved in the database.
     * @param {WeeklyProjectionCreateManyAndReturnArgs} args - Arguments to create many WeeklyProjections.
     * @example
     * // Create many WeeklyProjections
     * const weeklyProjection = await prisma.weeklyProjection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeeklyProjections and only return the `id`
     * const weeklyProjectionWithIdOnly = await prisma.weeklyProjection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeeklyProjectionCreateManyAndReturnArgs>(args?: SelectSubset<T, WeeklyProjectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyProjectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WeeklyProjection.
     * @param {WeeklyProjectionDeleteArgs} args - Arguments to delete one WeeklyProjection.
     * @example
     * // Delete one WeeklyProjection
     * const WeeklyProjection = await prisma.weeklyProjection.delete({
     *   where: {
     *     // ... filter to delete one WeeklyProjection
     *   }
     * })
     * 
     */
    delete<T extends WeeklyProjectionDeleteArgs>(args: SelectSubset<T, WeeklyProjectionDeleteArgs<ExtArgs>>): Prisma__WeeklyProjectionClient<$Result.GetResult<Prisma.$WeeklyProjectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WeeklyProjection.
     * @param {WeeklyProjectionUpdateArgs} args - Arguments to update one WeeklyProjection.
     * @example
     * // Update one WeeklyProjection
     * const weeklyProjection = await prisma.weeklyProjection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeeklyProjectionUpdateArgs>(args: SelectSubset<T, WeeklyProjectionUpdateArgs<ExtArgs>>): Prisma__WeeklyProjectionClient<$Result.GetResult<Prisma.$WeeklyProjectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WeeklyProjections.
     * @param {WeeklyProjectionDeleteManyArgs} args - Arguments to filter WeeklyProjections to delete.
     * @example
     * // Delete a few WeeklyProjections
     * const { count } = await prisma.weeklyProjection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeeklyProjectionDeleteManyArgs>(args?: SelectSubset<T, WeeklyProjectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeeklyProjections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyProjectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeeklyProjections
     * const weeklyProjection = await prisma.weeklyProjection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeeklyProjectionUpdateManyArgs>(args: SelectSubset<T, WeeklyProjectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeeklyProjections and returns the data updated in the database.
     * @param {WeeklyProjectionUpdateManyAndReturnArgs} args - Arguments to update many WeeklyProjections.
     * @example
     * // Update many WeeklyProjections
     * const weeklyProjection = await prisma.weeklyProjection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WeeklyProjections and only return the `id`
     * const weeklyProjectionWithIdOnly = await prisma.weeklyProjection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeeklyProjectionUpdateManyAndReturnArgs>(args: SelectSubset<T, WeeklyProjectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyProjectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WeeklyProjection.
     * @param {WeeklyProjectionUpsertArgs} args - Arguments to update or create a WeeklyProjection.
     * @example
     * // Update or create a WeeklyProjection
     * const weeklyProjection = await prisma.weeklyProjection.upsert({
     *   create: {
     *     // ... data to create a WeeklyProjection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeeklyProjection we want to update
     *   }
     * })
     */
    upsert<T extends WeeklyProjectionUpsertArgs>(args: SelectSubset<T, WeeklyProjectionUpsertArgs<ExtArgs>>): Prisma__WeeklyProjectionClient<$Result.GetResult<Prisma.$WeeklyProjectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WeeklyProjections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyProjectionCountArgs} args - Arguments to filter WeeklyProjections to count.
     * @example
     * // Count the number of WeeklyProjections
     * const count = await prisma.weeklyProjection.count({
     *   where: {
     *     // ... the filter for the WeeklyProjections we want to count
     *   }
     * })
    **/
    count<T extends WeeklyProjectionCountArgs>(
      args?: Subset<T, WeeklyProjectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeeklyProjectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeeklyProjection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyProjectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeeklyProjectionAggregateArgs>(args: Subset<T, WeeklyProjectionAggregateArgs>): Prisma.PrismaPromise<GetWeeklyProjectionAggregateType<T>>

    /**
     * Group by WeeklyProjection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyProjectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeeklyProjectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeeklyProjectionGroupByArgs['orderBy'] }
        : { orderBy?: WeeklyProjectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeeklyProjectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeeklyProjectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeeklyProjection model
   */
  readonly fields: WeeklyProjectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeeklyProjection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeeklyProjectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeeklyProjection model
   */
  interface WeeklyProjectionFieldRefs {
    readonly id: FieldRef<"WeeklyProjection", 'String'>
    readonly playerId: FieldRef<"WeeklyProjection", 'String'>
    readonly week: FieldRef<"WeeklyProjection", 'Int'>
    readonly season: FieldRef<"WeeklyProjection", 'Int'>
    readonly projectedPoints: FieldRef<"WeeklyProjection", 'Decimal'>
    readonly confidence: FieldRef<"WeeklyProjection", 'Decimal'>
    readonly projPassingYards: FieldRef<"WeeklyProjection", 'Decimal'>
    readonly projPassingTds: FieldRef<"WeeklyProjection", 'Decimal'>
    readonly projRushingYards: FieldRef<"WeeklyProjection", 'Decimal'>
    readonly projRushingTds: FieldRef<"WeeklyProjection", 'Decimal'>
    readonly projReceptions: FieldRef<"WeeklyProjection", 'Decimal'>
    readonly projReceivingYards: FieldRef<"WeeklyProjection", 'Decimal'>
    readonly projReceivingTds: FieldRef<"WeeklyProjection", 'Decimal'>
    readonly createdAt: FieldRef<"WeeklyProjection", 'DateTime'>
    readonly updatedAt: FieldRef<"WeeklyProjection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeeklyProjection findUnique
   */
  export type WeeklyProjectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyProjection
     */
    select?: WeeklyProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyProjection
     */
    omit?: WeeklyProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyProjectionInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyProjection to fetch.
     */
    where: WeeklyProjectionWhereUniqueInput
  }

  /**
   * WeeklyProjection findUniqueOrThrow
   */
  export type WeeklyProjectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyProjection
     */
    select?: WeeklyProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyProjection
     */
    omit?: WeeklyProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyProjectionInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyProjection to fetch.
     */
    where: WeeklyProjectionWhereUniqueInput
  }

  /**
   * WeeklyProjection findFirst
   */
  export type WeeklyProjectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyProjection
     */
    select?: WeeklyProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyProjection
     */
    omit?: WeeklyProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyProjectionInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyProjection to fetch.
     */
    where?: WeeklyProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyProjections to fetch.
     */
    orderBy?: WeeklyProjectionOrderByWithRelationInput | WeeklyProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyProjections.
     */
    cursor?: WeeklyProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyProjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyProjections.
     */
    distinct?: WeeklyProjectionScalarFieldEnum | WeeklyProjectionScalarFieldEnum[]
  }

  /**
   * WeeklyProjection findFirstOrThrow
   */
  export type WeeklyProjectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyProjection
     */
    select?: WeeklyProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyProjection
     */
    omit?: WeeklyProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyProjectionInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyProjection to fetch.
     */
    where?: WeeklyProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyProjections to fetch.
     */
    orderBy?: WeeklyProjectionOrderByWithRelationInput | WeeklyProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyProjections.
     */
    cursor?: WeeklyProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyProjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyProjections.
     */
    distinct?: WeeklyProjectionScalarFieldEnum | WeeklyProjectionScalarFieldEnum[]
  }

  /**
   * WeeklyProjection findMany
   */
  export type WeeklyProjectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyProjection
     */
    select?: WeeklyProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyProjection
     */
    omit?: WeeklyProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyProjectionInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyProjections to fetch.
     */
    where?: WeeklyProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyProjections to fetch.
     */
    orderBy?: WeeklyProjectionOrderByWithRelationInput | WeeklyProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeeklyProjections.
     */
    cursor?: WeeklyProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyProjections.
     */
    skip?: number
    distinct?: WeeklyProjectionScalarFieldEnum | WeeklyProjectionScalarFieldEnum[]
  }

  /**
   * WeeklyProjection create
   */
  export type WeeklyProjectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyProjection
     */
    select?: WeeklyProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyProjection
     */
    omit?: WeeklyProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyProjectionInclude<ExtArgs> | null
    /**
     * The data needed to create a WeeklyProjection.
     */
    data: XOR<WeeklyProjectionCreateInput, WeeklyProjectionUncheckedCreateInput>
  }

  /**
   * WeeklyProjection createMany
   */
  export type WeeklyProjectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeeklyProjections.
     */
    data: WeeklyProjectionCreateManyInput | WeeklyProjectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeeklyProjection createManyAndReturn
   */
  export type WeeklyProjectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyProjection
     */
    select?: WeeklyProjectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyProjection
     */
    omit?: WeeklyProjectionOmit<ExtArgs> | null
    /**
     * The data used to create many WeeklyProjections.
     */
    data: WeeklyProjectionCreateManyInput | WeeklyProjectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyProjectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeeklyProjection update
   */
  export type WeeklyProjectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyProjection
     */
    select?: WeeklyProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyProjection
     */
    omit?: WeeklyProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyProjectionInclude<ExtArgs> | null
    /**
     * The data needed to update a WeeklyProjection.
     */
    data: XOR<WeeklyProjectionUpdateInput, WeeklyProjectionUncheckedUpdateInput>
    /**
     * Choose, which WeeklyProjection to update.
     */
    where: WeeklyProjectionWhereUniqueInput
  }

  /**
   * WeeklyProjection updateMany
   */
  export type WeeklyProjectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeeklyProjections.
     */
    data: XOR<WeeklyProjectionUpdateManyMutationInput, WeeklyProjectionUncheckedUpdateManyInput>
    /**
     * Filter which WeeklyProjections to update
     */
    where?: WeeklyProjectionWhereInput
    /**
     * Limit how many WeeklyProjections to update.
     */
    limit?: number
  }

  /**
   * WeeklyProjection updateManyAndReturn
   */
  export type WeeklyProjectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyProjection
     */
    select?: WeeklyProjectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyProjection
     */
    omit?: WeeklyProjectionOmit<ExtArgs> | null
    /**
     * The data used to update WeeklyProjections.
     */
    data: XOR<WeeklyProjectionUpdateManyMutationInput, WeeklyProjectionUncheckedUpdateManyInput>
    /**
     * Filter which WeeklyProjections to update
     */
    where?: WeeklyProjectionWhereInput
    /**
     * Limit how many WeeklyProjections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyProjectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeeklyProjection upsert
   */
  export type WeeklyProjectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyProjection
     */
    select?: WeeklyProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyProjection
     */
    omit?: WeeklyProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyProjectionInclude<ExtArgs> | null
    /**
     * The filter to search for the WeeklyProjection to update in case it exists.
     */
    where: WeeklyProjectionWhereUniqueInput
    /**
     * In case the WeeklyProjection found by the `where` argument doesn't exist, create a new WeeklyProjection with this data.
     */
    create: XOR<WeeklyProjectionCreateInput, WeeklyProjectionUncheckedCreateInput>
    /**
     * In case the WeeklyProjection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeeklyProjectionUpdateInput, WeeklyProjectionUncheckedUpdateInput>
  }

  /**
   * WeeklyProjection delete
   */
  export type WeeklyProjectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyProjection
     */
    select?: WeeklyProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyProjection
     */
    omit?: WeeklyProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyProjectionInclude<ExtArgs> | null
    /**
     * Filter which WeeklyProjection to delete.
     */
    where: WeeklyProjectionWhereUniqueInput
  }

  /**
   * WeeklyProjection deleteMany
   */
  export type WeeklyProjectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyProjections to delete
     */
    where?: WeeklyProjectionWhereInput
    /**
     * Limit how many WeeklyProjections to delete.
     */
    limit?: number
  }

  /**
   * WeeklyProjection without action
   */
  export type WeeklyProjectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyProjection
     */
    select?: WeeklyProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeeklyProjection
     */
    omit?: WeeklyProjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyProjectionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    profileImage: 'profileImage',
    timezone: 'timezone',
    isActive: 'isActive',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LeagueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    password: 'password',
    customUrl: 'customUrl',
    commissionerId: 'commissionerId',
    maxTeams: 'maxTeams',
    isActive: 'isActive',
    isPaid: 'isPaid',
    entryFee: 'entryFee',
    prizeAmount: 'prizeAmount',
    draftType: 'draftType',
    draftDate: 'draftDate',
    seasonStartWeek: 'seasonStartWeek',
    leagueStartDate: 'leagueStartDate',
    rosterDeadline: 'rosterDeadline',
    maxAddsPerSeason: 'maxAddsPerSeason',
    maxAddsPerWeek: 'maxAddsPerWeek',
    tradeRejectTime: 'tradeRejectTime',
    tradeEndDate: 'tradeEndDate',
    waiverTime: 'waiverTime',
    commissionerMessage: 'commissionerMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeagueScalarFieldEnum = (typeof LeagueScalarFieldEnum)[keyof typeof LeagueScalarFieldEnum]


  export const LeagueSettingsScalarFieldEnum: {
    id: 'id',
    leagueId: 'leagueId',
    scoringType: 'scoringType',
    hasDivisions: 'hasDivisions',
    playoffTeams: 'playoffTeams',
    playoffStartWeek: 'playoffStartWeek',
    canTradeDraftPicks: 'canTradeDraftPicks',
    tradeReviewType: 'tradeReviewType',
    waiverType: 'waiverType',
    cantCutList: 'cantCutList',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeagueSettingsScalarFieldEnum = (typeof LeagueSettingsScalarFieldEnum)[keyof typeof LeagueSettingsScalarFieldEnum]


  export const ScoringSettingsScalarFieldEnum: {
    id: 'id',
    leagueId: 'leagueId',
    passingYards: 'passingYards',
    passingTds: 'passingTds',
    passingInts: 'passingInts',
    rushingYards: 'rushingYards',
    rushingTds: 'rushingTds',
    receivingYards: 'receivingYards',
    receivingTds: 'receivingTds',
    receptions: 'receptions',
    fumbles: 'fumbles',
    fieldGoals: 'fieldGoals',
    extraPoints: 'extraPoints',
    sacks: 'sacks',
    interceptions: 'interceptions',
    fumbleRecoveries: 'fumbleRecoveries',
    safeties: 'safeties',
    defensiveTds: 'defensiveTds',
    pointsAllowed0: 'pointsAllowed0',
    pointsAllowed1to6: 'pointsAllowed1to6',
    pointsAllowed7to13: 'pointsAllowed7to13',
    pointsAllowed14to20: 'pointsAllowed14to20',
    pointsAllowed21to27: 'pointsAllowed21to27',
    pointsAllowed28plus: 'pointsAllowed28plus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScoringSettingsScalarFieldEnum = (typeof ScoringSettingsScalarFieldEnum)[keyof typeof ScoringSettingsScalarFieldEnum]


  export const RosterSettingsScalarFieldEnum: {
    id: 'id',
    leagueId: 'leagueId',
    qbSlots: 'qbSlots',
    rbSlots: 'rbSlots',
    wrSlots: 'wrSlots',
    teSlots: 'teSlots',
    flexSlots: 'flexSlots',
    kSlots: 'kSlots',
    defSlots: 'defSlots',
    benchSlots: 'benchSlots',
    irSlots: 'irSlots',
    maxRosterSize: 'maxRosterSize',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RosterSettingsScalarFieldEnum = (typeof RosterSettingsScalarFieldEnum)[keyof typeof RosterSettingsScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    leagueId: 'leagueId',
    ownerId: 'ownerId',
    name: 'name',
    logoUrl: 'logoUrl',
    wins: 'wins',
    losses: 'losses',
    ties: 'ties',
    totalPoints: 'totalPoints',
    isActive: 'isActive',
    waiverPriority: 'waiverPriority',
    transactionCount: 'transactionCount',
    paidEntry: 'paidEntry',
    amountOwed: 'amountOwed',
    amountPaid: 'amountPaid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const PlayerScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    firstName: 'firstName',
    lastName: 'lastName',
    position: 'position',
    team: 'team',
    number: 'number',
    byeWeek: 'byeWeek',
    isActive: 'isActive',
    injuryStatus: 'injuryStatus',
    injuryNote: 'injuryNote',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerScalarFieldEnum = (typeof PlayerScalarFieldEnum)[keyof typeof PlayerScalarFieldEnum]


  export const RosterScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    playerId: 'playerId',
    position: 'position',
    isStarter: 'isStarter',
    acquiredDate: 'acquiredDate',
    weekAdded: 'weekAdded'
  };

  export type RosterScalarFieldEnum = (typeof RosterScalarFieldEnum)[keyof typeof RosterScalarFieldEnum]


  export const DraftScalarFieldEnum: {
    id: 'id',
    leagueId: 'leagueId',
    draftType: 'draftType',
    draftDate: 'draftDate',
    isComplete: 'isComplete',
    currentRound: 'currentRound',
    currentPick: 'currentPick',
    timePerPick: 'timePerPick',
    draftOrder: 'draftOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DraftScalarFieldEnum = (typeof DraftScalarFieldEnum)[keyof typeof DraftScalarFieldEnum]


  export const DraftPickScalarFieldEnum: {
    id: 'id',
    draftId: 'draftId',
    teamId: 'teamId',
    userId: 'userId',
    playerId: 'playerId',
    round: 'round',
    pick: 'pick',
    pickInRound: 'pickInRound',
    pickTime: 'pickTime',
    isKeeper: 'isKeeper',
    createdAt: 'createdAt'
  };

  export type DraftPickScalarFieldEnum = (typeof DraftPickScalarFieldEnum)[keyof typeof DraftPickScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    leagueId: 'leagueId',
    homeTeamId: 'homeTeamId',
    awayTeamId: 'awayTeamId',
    week: 'week',
    season: 'season',
    homeScore: 'homeScore',
    awayScore: 'awayScore',
    isComplete: 'isComplete',
    isPlayoffs: 'isPlayoffs',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    leagueId: 'leagueId',
    teamId: 'teamId',
    userId: 'userId',
    playerId: 'playerId',
    transactionType: 'transactionType',
    week: 'week',
    description: 'description',
    isProcessed: 'isProcessed',
    processedAt: 'processedAt',
    createdAt: 'createdAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const TradeOfferScalarFieldEnum: {
    id: 'id',
    leagueId: 'leagueId',
    offeringTeamId: 'offeringTeamId',
    targetTeamId: 'targetTeamId',
    offererId: 'offererId',
    targetId: 'targetId',
    status: 'status',
    note: 'note',
    expiresAt: 'expiresAt',
    respondedAt: 'respondedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TradeOfferScalarFieldEnum = (typeof TradeOfferScalarFieldEnum)[keyof typeof TradeOfferScalarFieldEnum]


  export const TradeOfferPlayerScalarFieldEnum: {
    id: 'id',
    tradeOfferId: 'tradeOfferId',
    playerId: 'playerId',
    fromTeam: 'fromTeam'
  };

  export type TradeOfferPlayerScalarFieldEnum = (typeof TradeOfferPlayerScalarFieldEnum)[keyof typeof TradeOfferPlayerScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    leagueId: 'leagueId',
    senderId: 'senderId',
    recipientId: 'recipientId',
    subject: 'subject',
    content: 'content',
    messageType: 'messageType',
    isRead: 'isRead',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const GameStatsScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    week: 'week',
    season: 'season',
    passingYards: 'passingYards',
    passingTds: 'passingTds',
    passingInts: 'passingInts',
    passingAttempts: 'passingAttempts',
    rushingYards: 'rushingYards',
    rushingTds: 'rushingTds',
    rushingAttempts: 'rushingAttempts',
    receptions: 'receptions',
    receivingYards: 'receivingYards',
    receivingTds: 'receivingTds',
    targets: 'targets',
    fumbles: 'fumbles',
    fumblesLost: 'fumblesLost',
    fieldGoalsMade: 'fieldGoalsMade',
    fieldGoalsAttempted: 'fieldGoalsAttempted',
    extraPointsMade: 'extraPointsMade',
    extraPointsAttempted: 'extraPointsAttempted',
    sacks: 'sacks',
    interceptions: 'interceptions',
    fumbleRecoveries: 'fumbleRecoveries',
    safeties: 'safeties',
    defensiveTds: 'defensiveTds',
    pointsAllowed: 'pointsAllowed',
    fantasyPoints: 'fantasyPoints',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameStatsScalarFieldEnum = (typeof GameStatsScalarFieldEnum)[keyof typeof GameStatsScalarFieldEnum]


  export const WeeklyProjectionScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    week: 'week',
    season: 'season',
    projectedPoints: 'projectedPoints',
    confidence: 'confidence',
    projPassingYards: 'projPassingYards',
    projPassingTds: 'projPassingTds',
    projRushingYards: 'projRushingYards',
    projRushingTds: 'projRushingTds',
    projReceptions: 'projReceptions',
    projReceivingYards: 'projReceivingYards',
    projReceivingTds: 'projReceivingTds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WeeklyProjectionScalarFieldEnum = (typeof WeeklyProjectionScalarFieldEnum)[keyof typeof WeeklyProjectionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'DraftType'
   */
  export type EnumDraftTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DraftType'>
    


  /**
   * Reference to a field of type 'DraftType[]'
   */
  export type ListEnumDraftTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DraftType[]'>
    


  /**
   * Reference to a field of type 'ScoringType'
   */
  export type EnumScoringTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScoringType'>
    


  /**
   * Reference to a field of type 'ScoringType[]'
   */
  export type ListEnumScoringTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScoringType[]'>
    


  /**
   * Reference to a field of type 'TradeReviewType'
   */
  export type EnumTradeReviewTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TradeReviewType'>
    


  /**
   * Reference to a field of type 'TradeReviewType[]'
   */
  export type ListEnumTradeReviewTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TradeReviewType[]'>
    


  /**
   * Reference to a field of type 'WaiverType'
   */
  export type EnumWaiverTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WaiverType'>
    


  /**
   * Reference to a field of type 'WaiverType[]'
   */
  export type ListEnumWaiverTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WaiverType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Position'
   */
  export type EnumPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Position'>
    


  /**
   * Reference to a field of type 'Position[]'
   */
  export type ListEnumPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Position[]'>
    


  /**
   * Reference to a field of type 'InjuryStatus'
   */
  export type EnumInjuryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InjuryStatus'>
    


  /**
   * Reference to a field of type 'InjuryStatus[]'
   */
  export type ListEnumInjuryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InjuryStatus[]'>
    


  /**
   * Reference to a field of type 'RosterPosition'
   */
  export type EnumRosterPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RosterPosition'>
    


  /**
   * Reference to a field of type 'RosterPosition[]'
   */
  export type ListEnumRosterPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RosterPosition[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'TradeStatus'
   */
  export type EnumTradeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TradeStatus'>
    


  /**
   * Reference to a field of type 'TradeStatus[]'
   */
  export type ListEnumTradeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TradeStatus[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    teamsOwned?: TeamListRelationFilter
    leaguesCommissioned?: LeagueListRelationFilter
    transactions?: TransactionListRelationFilter
    messages?: MessageListRelationFilter
    draftPicks?: DraftPickListRelationFilter
    tradeOffers?: TradeOfferListRelationFilter
    tradeTargets?: TradeOfferListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamsOwned?: TeamOrderByRelationAggregateInput
    leaguesCommissioned?: LeagueOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    draftPicks?: DraftPickOrderByRelationAggregateInput
    tradeOffers?: TradeOfferOrderByRelationAggregateInput
    tradeTargets?: TradeOfferOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    teamsOwned?: TeamListRelationFilter
    leaguesCommissioned?: LeagueListRelationFilter
    transactions?: TransactionListRelationFilter
    messages?: MessageListRelationFilter
    draftPicks?: DraftPickListRelationFilter
    tradeOffers?: TradeOfferListRelationFilter
    tradeTargets?: TradeOfferListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    timezone?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type LeagueWhereInput = {
    AND?: LeagueWhereInput | LeagueWhereInput[]
    OR?: LeagueWhereInput[]
    NOT?: LeagueWhereInput | LeagueWhereInput[]
    id?: StringFilter<"League"> | string
    name?: StringFilter<"League"> | string
    password?: StringNullableFilter<"League"> | string | null
    customUrl?: StringNullableFilter<"League"> | string | null
    commissionerId?: StringFilter<"League"> | string
    maxTeams?: IntFilter<"League"> | number
    isActive?: BoolFilter<"League"> | boolean
    isPaid?: BoolFilter<"League"> | boolean
    entryFee?: DecimalNullableFilter<"League"> | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: DecimalNullableFilter<"League"> | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFilter<"League"> | $Enums.DraftType
    draftDate?: DateTimeNullableFilter<"League"> | Date | string | null
    seasonStartWeek?: IntFilter<"League"> | number
    leagueStartDate?: DateTimeNullableFilter<"League"> | Date | string | null
    rosterDeadline?: DateTimeNullableFilter<"League"> | Date | string | null
    maxAddsPerSeason?: IntNullableFilter<"League"> | number | null
    maxAddsPerWeek?: IntNullableFilter<"League"> | number | null
    tradeRejectTime?: IntFilter<"League"> | number
    tradeEndDate?: DateTimeNullableFilter<"League"> | Date | string | null
    waiverTime?: IntFilter<"League"> | number
    commissionerMessage?: StringNullableFilter<"League"> | string | null
    createdAt?: DateTimeFilter<"League"> | Date | string
    updatedAt?: DateTimeFilter<"League"> | Date | string
    commissioner?: XOR<UserScalarRelationFilter, UserWhereInput>
    teams?: TeamListRelationFilter
    leagueSettings?: XOR<LeagueSettingsNullableScalarRelationFilter, LeagueSettingsWhereInput> | null
    scoringSettings?: XOR<ScoringSettingsNullableScalarRelationFilter, ScoringSettingsWhereInput> | null
    rosterSettings?: XOR<RosterSettingsNullableScalarRelationFilter, RosterSettingsWhereInput> | null
    draft?: XOR<DraftNullableScalarRelationFilter, DraftWhereInput> | null
    games?: GameListRelationFilter
    transactions?: TransactionListRelationFilter
    messages?: MessageListRelationFilter
    tradeOffers?: TradeOfferListRelationFilter
  }

  export type LeagueOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrderInput | SortOrder
    customUrl?: SortOrderInput | SortOrder
    commissionerId?: SortOrder
    maxTeams?: SortOrder
    isActive?: SortOrder
    isPaid?: SortOrder
    entryFee?: SortOrderInput | SortOrder
    prizeAmount?: SortOrderInput | SortOrder
    draftType?: SortOrder
    draftDate?: SortOrderInput | SortOrder
    seasonStartWeek?: SortOrder
    leagueStartDate?: SortOrderInput | SortOrder
    rosterDeadline?: SortOrderInput | SortOrder
    maxAddsPerSeason?: SortOrderInput | SortOrder
    maxAddsPerWeek?: SortOrderInput | SortOrder
    tradeRejectTime?: SortOrder
    tradeEndDate?: SortOrderInput | SortOrder
    waiverTime?: SortOrder
    commissionerMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commissioner?: UserOrderByWithRelationInput
    teams?: TeamOrderByRelationAggregateInput
    leagueSettings?: LeagueSettingsOrderByWithRelationInput
    scoringSettings?: ScoringSettingsOrderByWithRelationInput
    rosterSettings?: RosterSettingsOrderByWithRelationInput
    draft?: DraftOrderByWithRelationInput
    games?: GameOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    tradeOffers?: TradeOfferOrderByRelationAggregateInput
  }

  export type LeagueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customUrl?: string
    AND?: LeagueWhereInput | LeagueWhereInput[]
    OR?: LeagueWhereInput[]
    NOT?: LeagueWhereInput | LeagueWhereInput[]
    name?: StringFilter<"League"> | string
    password?: StringNullableFilter<"League"> | string | null
    commissionerId?: StringFilter<"League"> | string
    maxTeams?: IntFilter<"League"> | number
    isActive?: BoolFilter<"League"> | boolean
    isPaid?: BoolFilter<"League"> | boolean
    entryFee?: DecimalNullableFilter<"League"> | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: DecimalNullableFilter<"League"> | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFilter<"League"> | $Enums.DraftType
    draftDate?: DateTimeNullableFilter<"League"> | Date | string | null
    seasonStartWeek?: IntFilter<"League"> | number
    leagueStartDate?: DateTimeNullableFilter<"League"> | Date | string | null
    rosterDeadline?: DateTimeNullableFilter<"League"> | Date | string | null
    maxAddsPerSeason?: IntNullableFilter<"League"> | number | null
    maxAddsPerWeek?: IntNullableFilter<"League"> | number | null
    tradeRejectTime?: IntFilter<"League"> | number
    tradeEndDate?: DateTimeNullableFilter<"League"> | Date | string | null
    waiverTime?: IntFilter<"League"> | number
    commissionerMessage?: StringNullableFilter<"League"> | string | null
    createdAt?: DateTimeFilter<"League"> | Date | string
    updatedAt?: DateTimeFilter<"League"> | Date | string
    commissioner?: XOR<UserScalarRelationFilter, UserWhereInput>
    teams?: TeamListRelationFilter
    leagueSettings?: XOR<LeagueSettingsNullableScalarRelationFilter, LeagueSettingsWhereInput> | null
    scoringSettings?: XOR<ScoringSettingsNullableScalarRelationFilter, ScoringSettingsWhereInput> | null
    rosterSettings?: XOR<RosterSettingsNullableScalarRelationFilter, RosterSettingsWhereInput> | null
    draft?: XOR<DraftNullableScalarRelationFilter, DraftWhereInput> | null
    games?: GameListRelationFilter
    transactions?: TransactionListRelationFilter
    messages?: MessageListRelationFilter
    tradeOffers?: TradeOfferListRelationFilter
  }, "id" | "customUrl">

  export type LeagueOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrderInput | SortOrder
    customUrl?: SortOrderInput | SortOrder
    commissionerId?: SortOrder
    maxTeams?: SortOrder
    isActive?: SortOrder
    isPaid?: SortOrder
    entryFee?: SortOrderInput | SortOrder
    prizeAmount?: SortOrderInput | SortOrder
    draftType?: SortOrder
    draftDate?: SortOrderInput | SortOrder
    seasonStartWeek?: SortOrder
    leagueStartDate?: SortOrderInput | SortOrder
    rosterDeadline?: SortOrderInput | SortOrder
    maxAddsPerSeason?: SortOrderInput | SortOrder
    maxAddsPerWeek?: SortOrderInput | SortOrder
    tradeRejectTime?: SortOrder
    tradeEndDate?: SortOrderInput | SortOrder
    waiverTime?: SortOrder
    commissionerMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeagueCountOrderByAggregateInput
    _avg?: LeagueAvgOrderByAggregateInput
    _max?: LeagueMaxOrderByAggregateInput
    _min?: LeagueMinOrderByAggregateInput
    _sum?: LeagueSumOrderByAggregateInput
  }

  export type LeagueScalarWhereWithAggregatesInput = {
    AND?: LeagueScalarWhereWithAggregatesInput | LeagueScalarWhereWithAggregatesInput[]
    OR?: LeagueScalarWhereWithAggregatesInput[]
    NOT?: LeagueScalarWhereWithAggregatesInput | LeagueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"League"> | string
    name?: StringWithAggregatesFilter<"League"> | string
    password?: StringNullableWithAggregatesFilter<"League"> | string | null
    customUrl?: StringNullableWithAggregatesFilter<"League"> | string | null
    commissionerId?: StringWithAggregatesFilter<"League"> | string
    maxTeams?: IntWithAggregatesFilter<"League"> | number
    isActive?: BoolWithAggregatesFilter<"League"> | boolean
    isPaid?: BoolWithAggregatesFilter<"League"> | boolean
    entryFee?: DecimalNullableWithAggregatesFilter<"League"> | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: DecimalNullableWithAggregatesFilter<"League"> | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeWithAggregatesFilter<"League"> | $Enums.DraftType
    draftDate?: DateTimeNullableWithAggregatesFilter<"League"> | Date | string | null
    seasonStartWeek?: IntWithAggregatesFilter<"League"> | number
    leagueStartDate?: DateTimeNullableWithAggregatesFilter<"League"> | Date | string | null
    rosterDeadline?: DateTimeNullableWithAggregatesFilter<"League"> | Date | string | null
    maxAddsPerSeason?: IntNullableWithAggregatesFilter<"League"> | number | null
    maxAddsPerWeek?: IntNullableWithAggregatesFilter<"League"> | number | null
    tradeRejectTime?: IntWithAggregatesFilter<"League"> | number
    tradeEndDate?: DateTimeNullableWithAggregatesFilter<"League"> | Date | string | null
    waiverTime?: IntWithAggregatesFilter<"League"> | number
    commissionerMessage?: StringNullableWithAggregatesFilter<"League"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"League"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"League"> | Date | string
  }

  export type LeagueSettingsWhereInput = {
    AND?: LeagueSettingsWhereInput | LeagueSettingsWhereInput[]
    OR?: LeagueSettingsWhereInput[]
    NOT?: LeagueSettingsWhereInput | LeagueSettingsWhereInput[]
    id?: StringFilter<"LeagueSettings"> | string
    leagueId?: StringFilter<"LeagueSettings"> | string
    scoringType?: EnumScoringTypeFilter<"LeagueSettings"> | $Enums.ScoringType
    hasDivisions?: BoolFilter<"LeagueSettings"> | boolean
    playoffTeams?: IntFilter<"LeagueSettings"> | number
    playoffStartWeek?: IntFilter<"LeagueSettings"> | number
    canTradeDraftPicks?: BoolFilter<"LeagueSettings"> | boolean
    tradeReviewType?: EnumTradeReviewTypeFilter<"LeagueSettings"> | $Enums.TradeReviewType
    waiverType?: EnumWaiverTypeFilter<"LeagueSettings"> | $Enums.WaiverType
    cantCutList?: JsonNullableFilter<"LeagueSettings">
    createdAt?: DateTimeFilter<"LeagueSettings"> | Date | string
    updatedAt?: DateTimeFilter<"LeagueSettings"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
  }

  export type LeagueSettingsOrderByWithRelationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    scoringType?: SortOrder
    hasDivisions?: SortOrder
    playoffTeams?: SortOrder
    playoffStartWeek?: SortOrder
    canTradeDraftPicks?: SortOrder
    tradeReviewType?: SortOrder
    waiverType?: SortOrder
    cantCutList?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    league?: LeagueOrderByWithRelationInput
  }

  export type LeagueSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    leagueId?: string
    AND?: LeagueSettingsWhereInput | LeagueSettingsWhereInput[]
    OR?: LeagueSettingsWhereInput[]
    NOT?: LeagueSettingsWhereInput | LeagueSettingsWhereInput[]
    scoringType?: EnumScoringTypeFilter<"LeagueSettings"> | $Enums.ScoringType
    hasDivisions?: BoolFilter<"LeagueSettings"> | boolean
    playoffTeams?: IntFilter<"LeagueSettings"> | number
    playoffStartWeek?: IntFilter<"LeagueSettings"> | number
    canTradeDraftPicks?: BoolFilter<"LeagueSettings"> | boolean
    tradeReviewType?: EnumTradeReviewTypeFilter<"LeagueSettings"> | $Enums.TradeReviewType
    waiverType?: EnumWaiverTypeFilter<"LeagueSettings"> | $Enums.WaiverType
    cantCutList?: JsonNullableFilter<"LeagueSettings">
    createdAt?: DateTimeFilter<"LeagueSettings"> | Date | string
    updatedAt?: DateTimeFilter<"LeagueSettings"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
  }, "id" | "leagueId">

  export type LeagueSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    scoringType?: SortOrder
    hasDivisions?: SortOrder
    playoffTeams?: SortOrder
    playoffStartWeek?: SortOrder
    canTradeDraftPicks?: SortOrder
    tradeReviewType?: SortOrder
    waiverType?: SortOrder
    cantCutList?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeagueSettingsCountOrderByAggregateInput
    _avg?: LeagueSettingsAvgOrderByAggregateInput
    _max?: LeagueSettingsMaxOrderByAggregateInput
    _min?: LeagueSettingsMinOrderByAggregateInput
    _sum?: LeagueSettingsSumOrderByAggregateInput
  }

  export type LeagueSettingsScalarWhereWithAggregatesInput = {
    AND?: LeagueSettingsScalarWhereWithAggregatesInput | LeagueSettingsScalarWhereWithAggregatesInput[]
    OR?: LeagueSettingsScalarWhereWithAggregatesInput[]
    NOT?: LeagueSettingsScalarWhereWithAggregatesInput | LeagueSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeagueSettings"> | string
    leagueId?: StringWithAggregatesFilter<"LeagueSettings"> | string
    scoringType?: EnumScoringTypeWithAggregatesFilter<"LeagueSettings"> | $Enums.ScoringType
    hasDivisions?: BoolWithAggregatesFilter<"LeagueSettings"> | boolean
    playoffTeams?: IntWithAggregatesFilter<"LeagueSettings"> | number
    playoffStartWeek?: IntWithAggregatesFilter<"LeagueSettings"> | number
    canTradeDraftPicks?: BoolWithAggregatesFilter<"LeagueSettings"> | boolean
    tradeReviewType?: EnumTradeReviewTypeWithAggregatesFilter<"LeagueSettings"> | $Enums.TradeReviewType
    waiverType?: EnumWaiverTypeWithAggregatesFilter<"LeagueSettings"> | $Enums.WaiverType
    cantCutList?: JsonNullableWithAggregatesFilter<"LeagueSettings">
    createdAt?: DateTimeWithAggregatesFilter<"LeagueSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeagueSettings"> | Date | string
  }

  export type ScoringSettingsWhereInput = {
    AND?: ScoringSettingsWhereInput | ScoringSettingsWhereInput[]
    OR?: ScoringSettingsWhereInput[]
    NOT?: ScoringSettingsWhereInput | ScoringSettingsWhereInput[]
    id?: StringFilter<"ScoringSettings"> | string
    leagueId?: StringFilter<"ScoringSettings"> | string
    passingYards?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    passingTds?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    passingInts?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    rushingYards?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    rushingTds?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    receivingYards?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    receivingTds?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    receptions?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    fumbles?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    fieldGoals?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    extraPoints?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    sacks?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    interceptions?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    fumbleRecoveries?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    safeties?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    defensiveTds?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed0?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed1to6?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed7to13?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed14to20?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed21to27?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed28plus?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ScoringSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ScoringSettings"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
  }

  export type ScoringSettingsOrderByWithRelationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    passingYards?: SortOrder
    passingTds?: SortOrder
    passingInts?: SortOrder
    rushingYards?: SortOrder
    rushingTds?: SortOrder
    receivingYards?: SortOrder
    receivingTds?: SortOrder
    receptions?: SortOrder
    fumbles?: SortOrder
    fieldGoals?: SortOrder
    extraPoints?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
    fumbleRecoveries?: SortOrder
    safeties?: SortOrder
    defensiveTds?: SortOrder
    pointsAllowed0?: SortOrder
    pointsAllowed1to6?: SortOrder
    pointsAllowed7to13?: SortOrder
    pointsAllowed14to20?: SortOrder
    pointsAllowed21to27?: SortOrder
    pointsAllowed28plus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    league?: LeagueOrderByWithRelationInput
  }

  export type ScoringSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    leagueId?: string
    AND?: ScoringSettingsWhereInput | ScoringSettingsWhereInput[]
    OR?: ScoringSettingsWhereInput[]
    NOT?: ScoringSettingsWhereInput | ScoringSettingsWhereInput[]
    passingYards?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    passingTds?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    passingInts?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    rushingYards?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    rushingTds?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    receivingYards?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    receivingTds?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    receptions?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    fumbles?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    fieldGoals?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    extraPoints?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    sacks?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    interceptions?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    fumbleRecoveries?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    safeties?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    defensiveTds?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed0?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed1to6?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed7to13?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed14to20?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed21to27?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed28plus?: DecimalFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ScoringSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ScoringSettings"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
  }, "id" | "leagueId">

  export type ScoringSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    passingYards?: SortOrder
    passingTds?: SortOrder
    passingInts?: SortOrder
    rushingYards?: SortOrder
    rushingTds?: SortOrder
    receivingYards?: SortOrder
    receivingTds?: SortOrder
    receptions?: SortOrder
    fumbles?: SortOrder
    fieldGoals?: SortOrder
    extraPoints?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
    fumbleRecoveries?: SortOrder
    safeties?: SortOrder
    defensiveTds?: SortOrder
    pointsAllowed0?: SortOrder
    pointsAllowed1to6?: SortOrder
    pointsAllowed7to13?: SortOrder
    pointsAllowed14to20?: SortOrder
    pointsAllowed21to27?: SortOrder
    pointsAllowed28plus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScoringSettingsCountOrderByAggregateInput
    _avg?: ScoringSettingsAvgOrderByAggregateInput
    _max?: ScoringSettingsMaxOrderByAggregateInput
    _min?: ScoringSettingsMinOrderByAggregateInput
    _sum?: ScoringSettingsSumOrderByAggregateInput
  }

  export type ScoringSettingsScalarWhereWithAggregatesInput = {
    AND?: ScoringSettingsScalarWhereWithAggregatesInput | ScoringSettingsScalarWhereWithAggregatesInput[]
    OR?: ScoringSettingsScalarWhereWithAggregatesInput[]
    NOT?: ScoringSettingsScalarWhereWithAggregatesInput | ScoringSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScoringSettings"> | string
    leagueId?: StringWithAggregatesFilter<"ScoringSettings"> | string
    passingYards?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    passingTds?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    passingInts?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    rushingYards?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    rushingTds?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    receivingYards?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    receivingTds?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    receptions?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    fumbles?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    fieldGoals?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    extraPoints?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    sacks?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    interceptions?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    fumbleRecoveries?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    safeties?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    defensiveTds?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed0?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed1to6?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed7to13?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed14to20?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed21to27?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    pointsAllowed28plus?: DecimalWithAggregatesFilter<"ScoringSettings"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"ScoringSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScoringSettings"> | Date | string
  }

  export type RosterSettingsWhereInput = {
    AND?: RosterSettingsWhereInput | RosterSettingsWhereInput[]
    OR?: RosterSettingsWhereInput[]
    NOT?: RosterSettingsWhereInput | RosterSettingsWhereInput[]
    id?: StringFilter<"RosterSettings"> | string
    leagueId?: StringFilter<"RosterSettings"> | string
    qbSlots?: IntFilter<"RosterSettings"> | number
    rbSlots?: IntFilter<"RosterSettings"> | number
    wrSlots?: IntFilter<"RosterSettings"> | number
    teSlots?: IntFilter<"RosterSettings"> | number
    flexSlots?: IntFilter<"RosterSettings"> | number
    kSlots?: IntFilter<"RosterSettings"> | number
    defSlots?: IntFilter<"RosterSettings"> | number
    benchSlots?: IntFilter<"RosterSettings"> | number
    irSlots?: IntFilter<"RosterSettings"> | number
    maxRosterSize?: IntFilter<"RosterSettings"> | number
    createdAt?: DateTimeFilter<"RosterSettings"> | Date | string
    updatedAt?: DateTimeFilter<"RosterSettings"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
  }

  export type RosterSettingsOrderByWithRelationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    qbSlots?: SortOrder
    rbSlots?: SortOrder
    wrSlots?: SortOrder
    teSlots?: SortOrder
    flexSlots?: SortOrder
    kSlots?: SortOrder
    defSlots?: SortOrder
    benchSlots?: SortOrder
    irSlots?: SortOrder
    maxRosterSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    league?: LeagueOrderByWithRelationInput
  }

  export type RosterSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    leagueId?: string
    AND?: RosterSettingsWhereInput | RosterSettingsWhereInput[]
    OR?: RosterSettingsWhereInput[]
    NOT?: RosterSettingsWhereInput | RosterSettingsWhereInput[]
    qbSlots?: IntFilter<"RosterSettings"> | number
    rbSlots?: IntFilter<"RosterSettings"> | number
    wrSlots?: IntFilter<"RosterSettings"> | number
    teSlots?: IntFilter<"RosterSettings"> | number
    flexSlots?: IntFilter<"RosterSettings"> | number
    kSlots?: IntFilter<"RosterSettings"> | number
    defSlots?: IntFilter<"RosterSettings"> | number
    benchSlots?: IntFilter<"RosterSettings"> | number
    irSlots?: IntFilter<"RosterSettings"> | number
    maxRosterSize?: IntFilter<"RosterSettings"> | number
    createdAt?: DateTimeFilter<"RosterSettings"> | Date | string
    updatedAt?: DateTimeFilter<"RosterSettings"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
  }, "id" | "leagueId">

  export type RosterSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    qbSlots?: SortOrder
    rbSlots?: SortOrder
    wrSlots?: SortOrder
    teSlots?: SortOrder
    flexSlots?: SortOrder
    kSlots?: SortOrder
    defSlots?: SortOrder
    benchSlots?: SortOrder
    irSlots?: SortOrder
    maxRosterSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RosterSettingsCountOrderByAggregateInput
    _avg?: RosterSettingsAvgOrderByAggregateInput
    _max?: RosterSettingsMaxOrderByAggregateInput
    _min?: RosterSettingsMinOrderByAggregateInput
    _sum?: RosterSettingsSumOrderByAggregateInput
  }

  export type RosterSettingsScalarWhereWithAggregatesInput = {
    AND?: RosterSettingsScalarWhereWithAggregatesInput | RosterSettingsScalarWhereWithAggregatesInput[]
    OR?: RosterSettingsScalarWhereWithAggregatesInput[]
    NOT?: RosterSettingsScalarWhereWithAggregatesInput | RosterSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RosterSettings"> | string
    leagueId?: StringWithAggregatesFilter<"RosterSettings"> | string
    qbSlots?: IntWithAggregatesFilter<"RosterSettings"> | number
    rbSlots?: IntWithAggregatesFilter<"RosterSettings"> | number
    wrSlots?: IntWithAggregatesFilter<"RosterSettings"> | number
    teSlots?: IntWithAggregatesFilter<"RosterSettings"> | number
    flexSlots?: IntWithAggregatesFilter<"RosterSettings"> | number
    kSlots?: IntWithAggregatesFilter<"RosterSettings"> | number
    defSlots?: IntWithAggregatesFilter<"RosterSettings"> | number
    benchSlots?: IntWithAggregatesFilter<"RosterSettings"> | number
    irSlots?: IntWithAggregatesFilter<"RosterSettings"> | number
    maxRosterSize?: IntWithAggregatesFilter<"RosterSettings"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RosterSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RosterSettings"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    leagueId?: StringFilter<"Team"> | string
    ownerId?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    logoUrl?: StringNullableFilter<"Team"> | string | null
    wins?: IntFilter<"Team"> | number
    losses?: IntFilter<"Team"> | number
    ties?: IntFilter<"Team"> | number
    totalPoints?: DecimalFilter<"Team"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"Team"> | boolean
    waiverPriority?: IntFilter<"Team"> | number
    transactionCount?: IntFilter<"Team"> | number
    paidEntry?: BoolFilter<"Team"> | boolean
    amountOwed?: DecimalFilter<"Team"> | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFilter<"Team"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    roster?: RosterListRelationFilter
    draftPicks?: DraftPickListRelationFilter
    homeGames?: GameListRelationFilter
    awayGames?: GameListRelationFilter
    transactions?: TransactionListRelationFilter
    offeredTrades?: TradeOfferListRelationFilter
    targetedTrades?: TradeOfferListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    totalPoints?: SortOrder
    isActive?: SortOrder
    waiverPriority?: SortOrder
    transactionCount?: SortOrder
    paidEntry?: SortOrder
    amountOwed?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    league?: LeagueOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    roster?: RosterOrderByRelationAggregateInput
    draftPicks?: DraftPickOrderByRelationAggregateInput
    homeGames?: GameOrderByRelationAggregateInput
    awayGames?: GameOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    offeredTrades?: TradeOfferOrderByRelationAggregateInput
    targetedTrades?: TradeOfferOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    leagueId_ownerId?: TeamLeagueIdOwnerIdCompoundUniqueInput
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    leagueId?: StringFilter<"Team"> | string
    ownerId?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    logoUrl?: StringNullableFilter<"Team"> | string | null
    wins?: IntFilter<"Team"> | number
    losses?: IntFilter<"Team"> | number
    ties?: IntFilter<"Team"> | number
    totalPoints?: DecimalFilter<"Team"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"Team"> | boolean
    waiverPriority?: IntFilter<"Team"> | number
    transactionCount?: IntFilter<"Team"> | number
    paidEntry?: BoolFilter<"Team"> | boolean
    amountOwed?: DecimalFilter<"Team"> | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFilter<"Team"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    roster?: RosterListRelationFilter
    draftPicks?: DraftPickListRelationFilter
    homeGames?: GameListRelationFilter
    awayGames?: GameListRelationFilter
    transactions?: TransactionListRelationFilter
    offeredTrades?: TradeOfferListRelationFilter
    targetedTrades?: TradeOfferListRelationFilter
  }, "id" | "leagueId_ownerId">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    totalPoints?: SortOrder
    isActive?: SortOrder
    waiverPriority?: SortOrder
    transactionCount?: SortOrder
    paidEntry?: SortOrder
    amountOwed?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    leagueId?: StringWithAggregatesFilter<"Team"> | string
    ownerId?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"Team"> | string | null
    wins?: IntWithAggregatesFilter<"Team"> | number
    losses?: IntWithAggregatesFilter<"Team"> | number
    ties?: IntWithAggregatesFilter<"Team"> | number
    totalPoints?: DecimalWithAggregatesFilter<"Team"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"Team"> | boolean
    waiverPriority?: IntWithAggregatesFilter<"Team"> | number
    transactionCount?: IntWithAggregatesFilter<"Team"> | number
    paidEntry?: BoolWithAggregatesFilter<"Team"> | boolean
    amountOwed?: DecimalWithAggregatesFilter<"Team"> | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalWithAggregatesFilter<"Team"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type PlayerWhereInput = {
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    id?: StringFilter<"Player"> | string
    externalId?: StringNullableFilter<"Player"> | string | null
    firstName?: StringFilter<"Player"> | string
    lastName?: StringFilter<"Player"> | string
    position?: EnumPositionFilter<"Player"> | $Enums.Position
    team?: StringFilter<"Player"> | string
    number?: IntNullableFilter<"Player"> | number | null
    byeWeek?: IntNullableFilter<"Player"> | number | null
    isActive?: BoolFilter<"Player"> | boolean
    injuryStatus?: EnumInjuryStatusFilter<"Player"> | $Enums.InjuryStatus
    injuryNote?: StringNullableFilter<"Player"> | string | null
    imageUrl?: StringNullableFilter<"Player"> | string | null
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    roster?: RosterListRelationFilter
    draftPicks?: DraftPickListRelationFilter
    transactions?: TransactionListRelationFilter
    gameStats?: GameStatsListRelationFilter
    weeklyProjections?: WeeklyProjectionListRelationFilter
    tradeOfferPlayers?: TradeOfferPlayerListRelationFilter
  }

  export type PlayerOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    position?: SortOrder
    team?: SortOrder
    number?: SortOrderInput | SortOrder
    byeWeek?: SortOrderInput | SortOrder
    isActive?: SortOrder
    injuryStatus?: SortOrder
    injuryNote?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roster?: RosterOrderByRelationAggregateInput
    draftPicks?: DraftPickOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    gameStats?: GameStatsOrderByRelationAggregateInput
    weeklyProjections?: WeeklyProjectionOrderByRelationAggregateInput
    tradeOfferPlayers?: TradeOfferPlayerOrderByRelationAggregateInput
  }

  export type PlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId?: string
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    firstName?: StringFilter<"Player"> | string
    lastName?: StringFilter<"Player"> | string
    position?: EnumPositionFilter<"Player"> | $Enums.Position
    team?: StringFilter<"Player"> | string
    number?: IntNullableFilter<"Player"> | number | null
    byeWeek?: IntNullableFilter<"Player"> | number | null
    isActive?: BoolFilter<"Player"> | boolean
    injuryStatus?: EnumInjuryStatusFilter<"Player"> | $Enums.InjuryStatus
    injuryNote?: StringNullableFilter<"Player"> | string | null
    imageUrl?: StringNullableFilter<"Player"> | string | null
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    roster?: RosterListRelationFilter
    draftPicks?: DraftPickListRelationFilter
    transactions?: TransactionListRelationFilter
    gameStats?: GameStatsListRelationFilter
    weeklyProjections?: WeeklyProjectionListRelationFilter
    tradeOfferPlayers?: TradeOfferPlayerListRelationFilter
  }, "id" | "externalId">

  export type PlayerOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    position?: SortOrder
    team?: SortOrder
    number?: SortOrderInput | SortOrder
    byeWeek?: SortOrderInput | SortOrder
    isActive?: SortOrder
    injuryStatus?: SortOrder
    injuryNote?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerCountOrderByAggregateInput
    _avg?: PlayerAvgOrderByAggregateInput
    _max?: PlayerMaxOrderByAggregateInput
    _min?: PlayerMinOrderByAggregateInput
    _sum?: PlayerSumOrderByAggregateInput
  }

  export type PlayerScalarWhereWithAggregatesInput = {
    AND?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    OR?: PlayerScalarWhereWithAggregatesInput[]
    NOT?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Player"> | string
    externalId?: StringNullableWithAggregatesFilter<"Player"> | string | null
    firstName?: StringWithAggregatesFilter<"Player"> | string
    lastName?: StringWithAggregatesFilter<"Player"> | string
    position?: EnumPositionWithAggregatesFilter<"Player"> | $Enums.Position
    team?: StringWithAggregatesFilter<"Player"> | string
    number?: IntNullableWithAggregatesFilter<"Player"> | number | null
    byeWeek?: IntNullableWithAggregatesFilter<"Player"> | number | null
    isActive?: BoolWithAggregatesFilter<"Player"> | boolean
    injuryStatus?: EnumInjuryStatusWithAggregatesFilter<"Player"> | $Enums.InjuryStatus
    injuryNote?: StringNullableWithAggregatesFilter<"Player"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Player"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
  }

  export type RosterWhereInput = {
    AND?: RosterWhereInput | RosterWhereInput[]
    OR?: RosterWhereInput[]
    NOT?: RosterWhereInput | RosterWhereInput[]
    id?: StringFilter<"Roster"> | string
    teamId?: StringFilter<"Roster"> | string
    playerId?: StringFilter<"Roster"> | string
    position?: EnumRosterPositionFilter<"Roster"> | $Enums.RosterPosition
    isStarter?: BoolFilter<"Roster"> | boolean
    acquiredDate?: DateTimeFilter<"Roster"> | Date | string
    weekAdded?: IntNullableFilter<"Roster"> | number | null
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type RosterOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    position?: SortOrder
    isStarter?: SortOrder
    acquiredDate?: SortOrder
    weekAdded?: SortOrderInput | SortOrder
    team?: TeamOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
  }

  export type RosterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId_playerId?: RosterTeamIdPlayerIdCompoundUniqueInput
    AND?: RosterWhereInput | RosterWhereInput[]
    OR?: RosterWhereInput[]
    NOT?: RosterWhereInput | RosterWhereInput[]
    teamId?: StringFilter<"Roster"> | string
    playerId?: StringFilter<"Roster"> | string
    position?: EnumRosterPositionFilter<"Roster"> | $Enums.RosterPosition
    isStarter?: BoolFilter<"Roster"> | boolean
    acquiredDate?: DateTimeFilter<"Roster"> | Date | string
    weekAdded?: IntNullableFilter<"Roster"> | number | null
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id" | "teamId_playerId">

  export type RosterOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    position?: SortOrder
    isStarter?: SortOrder
    acquiredDate?: SortOrder
    weekAdded?: SortOrderInput | SortOrder
    _count?: RosterCountOrderByAggregateInput
    _avg?: RosterAvgOrderByAggregateInput
    _max?: RosterMaxOrderByAggregateInput
    _min?: RosterMinOrderByAggregateInput
    _sum?: RosterSumOrderByAggregateInput
  }

  export type RosterScalarWhereWithAggregatesInput = {
    AND?: RosterScalarWhereWithAggregatesInput | RosterScalarWhereWithAggregatesInput[]
    OR?: RosterScalarWhereWithAggregatesInput[]
    NOT?: RosterScalarWhereWithAggregatesInput | RosterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Roster"> | string
    teamId?: StringWithAggregatesFilter<"Roster"> | string
    playerId?: StringWithAggregatesFilter<"Roster"> | string
    position?: EnumRosterPositionWithAggregatesFilter<"Roster"> | $Enums.RosterPosition
    isStarter?: BoolWithAggregatesFilter<"Roster"> | boolean
    acquiredDate?: DateTimeWithAggregatesFilter<"Roster"> | Date | string
    weekAdded?: IntNullableWithAggregatesFilter<"Roster"> | number | null
  }

  export type DraftWhereInput = {
    AND?: DraftWhereInput | DraftWhereInput[]
    OR?: DraftWhereInput[]
    NOT?: DraftWhereInput | DraftWhereInput[]
    id?: StringFilter<"Draft"> | string
    leagueId?: StringFilter<"Draft"> | string
    draftType?: EnumDraftTypeFilter<"Draft"> | $Enums.DraftType
    draftDate?: DateTimeNullableFilter<"Draft"> | Date | string | null
    isComplete?: BoolFilter<"Draft"> | boolean
    currentRound?: IntFilter<"Draft"> | number
    currentPick?: IntFilter<"Draft"> | number
    timePerPick?: IntFilter<"Draft"> | number
    draftOrder?: JsonNullableFilter<"Draft">
    createdAt?: DateTimeFilter<"Draft"> | Date | string
    updatedAt?: DateTimeFilter<"Draft"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    picks?: DraftPickListRelationFilter
  }

  export type DraftOrderByWithRelationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    draftType?: SortOrder
    draftDate?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    currentRound?: SortOrder
    currentPick?: SortOrder
    timePerPick?: SortOrder
    draftOrder?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    league?: LeagueOrderByWithRelationInput
    picks?: DraftPickOrderByRelationAggregateInput
  }

  export type DraftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    leagueId?: string
    AND?: DraftWhereInput | DraftWhereInput[]
    OR?: DraftWhereInput[]
    NOT?: DraftWhereInput | DraftWhereInput[]
    draftType?: EnumDraftTypeFilter<"Draft"> | $Enums.DraftType
    draftDate?: DateTimeNullableFilter<"Draft"> | Date | string | null
    isComplete?: BoolFilter<"Draft"> | boolean
    currentRound?: IntFilter<"Draft"> | number
    currentPick?: IntFilter<"Draft"> | number
    timePerPick?: IntFilter<"Draft"> | number
    draftOrder?: JsonNullableFilter<"Draft">
    createdAt?: DateTimeFilter<"Draft"> | Date | string
    updatedAt?: DateTimeFilter<"Draft"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    picks?: DraftPickListRelationFilter
  }, "id" | "leagueId">

  export type DraftOrderByWithAggregationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    draftType?: SortOrder
    draftDate?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    currentRound?: SortOrder
    currentPick?: SortOrder
    timePerPick?: SortOrder
    draftOrder?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DraftCountOrderByAggregateInput
    _avg?: DraftAvgOrderByAggregateInput
    _max?: DraftMaxOrderByAggregateInput
    _min?: DraftMinOrderByAggregateInput
    _sum?: DraftSumOrderByAggregateInput
  }

  export type DraftScalarWhereWithAggregatesInput = {
    AND?: DraftScalarWhereWithAggregatesInput | DraftScalarWhereWithAggregatesInput[]
    OR?: DraftScalarWhereWithAggregatesInput[]
    NOT?: DraftScalarWhereWithAggregatesInput | DraftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Draft"> | string
    leagueId?: StringWithAggregatesFilter<"Draft"> | string
    draftType?: EnumDraftTypeWithAggregatesFilter<"Draft"> | $Enums.DraftType
    draftDate?: DateTimeNullableWithAggregatesFilter<"Draft"> | Date | string | null
    isComplete?: BoolWithAggregatesFilter<"Draft"> | boolean
    currentRound?: IntWithAggregatesFilter<"Draft"> | number
    currentPick?: IntWithAggregatesFilter<"Draft"> | number
    timePerPick?: IntWithAggregatesFilter<"Draft"> | number
    draftOrder?: JsonNullableWithAggregatesFilter<"Draft">
    createdAt?: DateTimeWithAggregatesFilter<"Draft"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Draft"> | Date | string
  }

  export type DraftPickWhereInput = {
    AND?: DraftPickWhereInput | DraftPickWhereInput[]
    OR?: DraftPickWhereInput[]
    NOT?: DraftPickWhereInput | DraftPickWhereInput[]
    id?: StringFilter<"DraftPick"> | string
    draftId?: StringFilter<"DraftPick"> | string
    teamId?: StringFilter<"DraftPick"> | string
    userId?: StringFilter<"DraftPick"> | string
    playerId?: StringNullableFilter<"DraftPick"> | string | null
    round?: IntFilter<"DraftPick"> | number
    pick?: IntFilter<"DraftPick"> | number
    pickInRound?: IntFilter<"DraftPick"> | number
    pickTime?: DateTimeNullableFilter<"DraftPick"> | Date | string | null
    isKeeper?: BoolFilter<"DraftPick"> | boolean
    createdAt?: DateTimeFilter<"DraftPick"> | Date | string
    draft?: XOR<DraftScalarRelationFilter, DraftWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
  }

  export type DraftPickOrderByWithRelationInput = {
    id?: SortOrder
    draftId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    playerId?: SortOrderInput | SortOrder
    round?: SortOrder
    pick?: SortOrder
    pickInRound?: SortOrder
    pickTime?: SortOrderInput | SortOrder
    isKeeper?: SortOrder
    createdAt?: SortOrder
    draft?: DraftOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
  }

  export type DraftPickWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    draftId_round_pickInRound?: DraftPickDraftIdRoundPickInRoundCompoundUniqueInput
    AND?: DraftPickWhereInput | DraftPickWhereInput[]
    OR?: DraftPickWhereInput[]
    NOT?: DraftPickWhereInput | DraftPickWhereInput[]
    draftId?: StringFilter<"DraftPick"> | string
    teamId?: StringFilter<"DraftPick"> | string
    userId?: StringFilter<"DraftPick"> | string
    playerId?: StringNullableFilter<"DraftPick"> | string | null
    round?: IntFilter<"DraftPick"> | number
    pick?: IntFilter<"DraftPick"> | number
    pickInRound?: IntFilter<"DraftPick"> | number
    pickTime?: DateTimeNullableFilter<"DraftPick"> | Date | string | null
    isKeeper?: BoolFilter<"DraftPick"> | boolean
    createdAt?: DateTimeFilter<"DraftPick"> | Date | string
    draft?: XOR<DraftScalarRelationFilter, DraftWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    player?: XOR<PlayerNullableScalarRelationFilter, PlayerWhereInput> | null
  }, "id" | "draftId_round_pickInRound">

  export type DraftPickOrderByWithAggregationInput = {
    id?: SortOrder
    draftId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    playerId?: SortOrderInput | SortOrder
    round?: SortOrder
    pick?: SortOrder
    pickInRound?: SortOrder
    pickTime?: SortOrderInput | SortOrder
    isKeeper?: SortOrder
    createdAt?: SortOrder
    _count?: DraftPickCountOrderByAggregateInput
    _avg?: DraftPickAvgOrderByAggregateInput
    _max?: DraftPickMaxOrderByAggregateInput
    _min?: DraftPickMinOrderByAggregateInput
    _sum?: DraftPickSumOrderByAggregateInput
  }

  export type DraftPickScalarWhereWithAggregatesInput = {
    AND?: DraftPickScalarWhereWithAggregatesInput | DraftPickScalarWhereWithAggregatesInput[]
    OR?: DraftPickScalarWhereWithAggregatesInput[]
    NOT?: DraftPickScalarWhereWithAggregatesInput | DraftPickScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DraftPick"> | string
    draftId?: StringWithAggregatesFilter<"DraftPick"> | string
    teamId?: StringWithAggregatesFilter<"DraftPick"> | string
    userId?: StringWithAggregatesFilter<"DraftPick"> | string
    playerId?: StringNullableWithAggregatesFilter<"DraftPick"> | string | null
    round?: IntWithAggregatesFilter<"DraftPick"> | number
    pick?: IntWithAggregatesFilter<"DraftPick"> | number
    pickInRound?: IntWithAggregatesFilter<"DraftPick"> | number
    pickTime?: DateTimeNullableWithAggregatesFilter<"DraftPick"> | Date | string | null
    isKeeper?: BoolWithAggregatesFilter<"DraftPick"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DraftPick"> | Date | string
  }

  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    id?: StringFilter<"Game"> | string
    leagueId?: StringFilter<"Game"> | string
    homeTeamId?: StringFilter<"Game"> | string
    awayTeamId?: StringFilter<"Game"> | string
    week?: IntFilter<"Game"> | number
    season?: IntFilter<"Game"> | number
    homeScore?: DecimalFilter<"Game"> | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFilter<"Game"> | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFilter<"Game"> | boolean
    isPlayoffs?: BoolFilter<"Game"> | boolean
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    homeTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    awayTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    week?: SortOrder
    season?: SortOrder
    homeScore?: SortOrder
    awayScore?: SortOrder
    isComplete?: SortOrder
    isPlayoffs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    league?: LeagueOrderByWithRelationInput
    homeTeam?: TeamOrderByWithRelationInput
    awayTeam?: TeamOrderByWithRelationInput
  }

  export type GameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    leagueId_homeTeamId_awayTeamId_week_season?: GameLeagueIdHomeTeamIdAwayTeamIdWeekSeasonCompoundUniqueInput
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    leagueId?: StringFilter<"Game"> | string
    homeTeamId?: StringFilter<"Game"> | string
    awayTeamId?: StringFilter<"Game"> | string
    week?: IntFilter<"Game"> | number
    season?: IntFilter<"Game"> | number
    homeScore?: DecimalFilter<"Game"> | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFilter<"Game"> | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFilter<"Game"> | boolean
    isPlayoffs?: BoolFilter<"Game"> | boolean
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    homeTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    awayTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id" | "leagueId_homeTeamId_awayTeamId_week_season">

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    week?: SortOrder
    season?: SortOrder
    homeScore?: SortOrder
    awayScore?: SortOrder
    isComplete?: SortOrder
    isPlayoffs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameCountOrderByAggregateInput
    _avg?: GameAvgOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
    _sum?: GameSumOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    OR?: GameScalarWhereWithAggregatesInput[]
    NOT?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Game"> | string
    leagueId?: StringWithAggregatesFilter<"Game"> | string
    homeTeamId?: StringWithAggregatesFilter<"Game"> | string
    awayTeamId?: StringWithAggregatesFilter<"Game"> | string
    week?: IntWithAggregatesFilter<"Game"> | number
    season?: IntWithAggregatesFilter<"Game"> | number
    homeScore?: DecimalWithAggregatesFilter<"Game"> | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalWithAggregatesFilter<"Game"> | Decimal | DecimalJsLike | number | string
    isComplete?: BoolWithAggregatesFilter<"Game"> | boolean
    isPlayoffs?: BoolWithAggregatesFilter<"Game"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    leagueId?: StringFilter<"Transaction"> | string
    teamId?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    playerId?: StringFilter<"Transaction"> | string
    transactionType?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    week?: IntFilter<"Transaction"> | number
    description?: StringNullableFilter<"Transaction"> | string | null
    isProcessed?: BoolFilter<"Transaction"> | boolean
    processedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    playerId?: SortOrder
    transactionType?: SortOrder
    week?: SortOrder
    description?: SortOrderInput | SortOrder
    isProcessed?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    league?: LeagueOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    leagueId?: StringFilter<"Transaction"> | string
    teamId?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    playerId?: StringFilter<"Transaction"> | string
    transactionType?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    week?: IntFilter<"Transaction"> | number
    description?: StringNullableFilter<"Transaction"> | string | null
    isProcessed?: BoolFilter<"Transaction"> | boolean
    processedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    playerId?: SortOrder
    transactionType?: SortOrder
    week?: SortOrder
    description?: SortOrderInput | SortOrder
    isProcessed?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    leagueId?: StringWithAggregatesFilter<"Transaction"> | string
    teamId?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    playerId?: StringWithAggregatesFilter<"Transaction"> | string
    transactionType?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    week?: IntWithAggregatesFilter<"Transaction"> | number
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    isProcessed?: BoolWithAggregatesFilter<"Transaction"> | boolean
    processedAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type TradeOfferWhereInput = {
    AND?: TradeOfferWhereInput | TradeOfferWhereInput[]
    OR?: TradeOfferWhereInput[]
    NOT?: TradeOfferWhereInput | TradeOfferWhereInput[]
    id?: StringFilter<"TradeOffer"> | string
    leagueId?: StringFilter<"TradeOffer"> | string
    offeringTeamId?: StringFilter<"TradeOffer"> | string
    targetTeamId?: StringFilter<"TradeOffer"> | string
    offererId?: StringFilter<"TradeOffer"> | string
    targetId?: StringFilter<"TradeOffer"> | string
    status?: EnumTradeStatusFilter<"TradeOffer"> | $Enums.TradeStatus
    note?: StringNullableFilter<"TradeOffer"> | string | null
    expiresAt?: DateTimeNullableFilter<"TradeOffer"> | Date | string | null
    respondedAt?: DateTimeNullableFilter<"TradeOffer"> | Date | string | null
    createdAt?: DateTimeFilter<"TradeOffer"> | Date | string
    updatedAt?: DateTimeFilter<"TradeOffer"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    offeringTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    targetTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    offerer?: XOR<UserScalarRelationFilter, UserWhereInput>
    target?: XOR<UserScalarRelationFilter, UserWhereInput>
    players?: TradeOfferPlayerListRelationFilter
  }

  export type TradeOfferOrderByWithRelationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    offeringTeamId?: SortOrder
    targetTeamId?: SortOrder
    offererId?: SortOrder
    targetId?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    league?: LeagueOrderByWithRelationInput
    offeringTeam?: TeamOrderByWithRelationInput
    targetTeam?: TeamOrderByWithRelationInput
    offerer?: UserOrderByWithRelationInput
    target?: UserOrderByWithRelationInput
    players?: TradeOfferPlayerOrderByRelationAggregateInput
  }

  export type TradeOfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TradeOfferWhereInput | TradeOfferWhereInput[]
    OR?: TradeOfferWhereInput[]
    NOT?: TradeOfferWhereInput | TradeOfferWhereInput[]
    leagueId?: StringFilter<"TradeOffer"> | string
    offeringTeamId?: StringFilter<"TradeOffer"> | string
    targetTeamId?: StringFilter<"TradeOffer"> | string
    offererId?: StringFilter<"TradeOffer"> | string
    targetId?: StringFilter<"TradeOffer"> | string
    status?: EnumTradeStatusFilter<"TradeOffer"> | $Enums.TradeStatus
    note?: StringNullableFilter<"TradeOffer"> | string | null
    expiresAt?: DateTimeNullableFilter<"TradeOffer"> | Date | string | null
    respondedAt?: DateTimeNullableFilter<"TradeOffer"> | Date | string | null
    createdAt?: DateTimeFilter<"TradeOffer"> | Date | string
    updatedAt?: DateTimeFilter<"TradeOffer"> | Date | string
    league?: XOR<LeagueScalarRelationFilter, LeagueWhereInput>
    offeringTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    targetTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    offerer?: XOR<UserScalarRelationFilter, UserWhereInput>
    target?: XOR<UserScalarRelationFilter, UserWhereInput>
    players?: TradeOfferPlayerListRelationFilter
  }, "id">

  export type TradeOfferOrderByWithAggregationInput = {
    id?: SortOrder
    leagueId?: SortOrder
    offeringTeamId?: SortOrder
    targetTeamId?: SortOrder
    offererId?: SortOrder
    targetId?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TradeOfferCountOrderByAggregateInput
    _max?: TradeOfferMaxOrderByAggregateInput
    _min?: TradeOfferMinOrderByAggregateInput
  }

  export type TradeOfferScalarWhereWithAggregatesInput = {
    AND?: TradeOfferScalarWhereWithAggregatesInput | TradeOfferScalarWhereWithAggregatesInput[]
    OR?: TradeOfferScalarWhereWithAggregatesInput[]
    NOT?: TradeOfferScalarWhereWithAggregatesInput | TradeOfferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TradeOffer"> | string
    leagueId?: StringWithAggregatesFilter<"TradeOffer"> | string
    offeringTeamId?: StringWithAggregatesFilter<"TradeOffer"> | string
    targetTeamId?: StringWithAggregatesFilter<"TradeOffer"> | string
    offererId?: StringWithAggregatesFilter<"TradeOffer"> | string
    targetId?: StringWithAggregatesFilter<"TradeOffer"> | string
    status?: EnumTradeStatusWithAggregatesFilter<"TradeOffer"> | $Enums.TradeStatus
    note?: StringNullableWithAggregatesFilter<"TradeOffer"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"TradeOffer"> | Date | string | null
    respondedAt?: DateTimeNullableWithAggregatesFilter<"TradeOffer"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TradeOffer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TradeOffer"> | Date | string
  }

  export type TradeOfferPlayerWhereInput = {
    AND?: TradeOfferPlayerWhereInput | TradeOfferPlayerWhereInput[]
    OR?: TradeOfferPlayerWhereInput[]
    NOT?: TradeOfferPlayerWhereInput | TradeOfferPlayerWhereInput[]
    id?: StringFilter<"TradeOfferPlayer"> | string
    tradeOfferId?: StringFilter<"TradeOfferPlayer"> | string
    playerId?: StringFilter<"TradeOfferPlayer"> | string
    fromTeam?: BoolFilter<"TradeOfferPlayer"> | boolean
    tradeOffer?: XOR<TradeOfferScalarRelationFilter, TradeOfferWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type TradeOfferPlayerOrderByWithRelationInput = {
    id?: SortOrder
    tradeOfferId?: SortOrder
    playerId?: SortOrder
    fromTeam?: SortOrder
    tradeOffer?: TradeOfferOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
  }

  export type TradeOfferPlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tradeOfferId_playerId?: TradeOfferPlayerTradeOfferIdPlayerIdCompoundUniqueInput
    AND?: TradeOfferPlayerWhereInput | TradeOfferPlayerWhereInput[]
    OR?: TradeOfferPlayerWhereInput[]
    NOT?: TradeOfferPlayerWhereInput | TradeOfferPlayerWhereInput[]
    tradeOfferId?: StringFilter<"TradeOfferPlayer"> | string
    playerId?: StringFilter<"TradeOfferPlayer"> | string
    fromTeam?: BoolFilter<"TradeOfferPlayer"> | boolean
    tradeOffer?: XOR<TradeOfferScalarRelationFilter, TradeOfferWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id" | "tradeOfferId_playerId">

  export type TradeOfferPlayerOrderByWithAggregationInput = {
    id?: SortOrder
    tradeOfferId?: SortOrder
    playerId?: SortOrder
    fromTeam?: SortOrder
    _count?: TradeOfferPlayerCountOrderByAggregateInput
    _max?: TradeOfferPlayerMaxOrderByAggregateInput
    _min?: TradeOfferPlayerMinOrderByAggregateInput
  }

  export type TradeOfferPlayerScalarWhereWithAggregatesInput = {
    AND?: TradeOfferPlayerScalarWhereWithAggregatesInput | TradeOfferPlayerScalarWhereWithAggregatesInput[]
    OR?: TradeOfferPlayerScalarWhereWithAggregatesInput[]
    NOT?: TradeOfferPlayerScalarWhereWithAggregatesInput | TradeOfferPlayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TradeOfferPlayer"> | string
    tradeOfferId?: StringWithAggregatesFilter<"TradeOfferPlayer"> | string
    playerId?: StringWithAggregatesFilter<"TradeOfferPlayer"> | string
    fromTeam?: BoolWithAggregatesFilter<"TradeOfferPlayer"> | boolean
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    leagueId?: StringNullableFilter<"Message"> | string | null
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringNullableFilter<"Message"> | string | null
    subject?: StringNullableFilter<"Message"> | string | null
    content?: StringFilter<"Message"> | string
    messageType?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    isRead?: BoolFilter<"Message"> | boolean
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    league?: XOR<LeagueNullableScalarRelationFilter, LeagueWhereInput> | null
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    leagueId?: SortOrderInput | SortOrder
    senderId?: SortOrder
    recipientId?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    league?: LeagueOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    leagueId?: StringNullableFilter<"Message"> | string | null
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringNullableFilter<"Message"> | string | null
    subject?: StringNullableFilter<"Message"> | string | null
    content?: StringFilter<"Message"> | string
    messageType?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    isRead?: BoolFilter<"Message"> | boolean
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    league?: XOR<LeagueNullableScalarRelationFilter, LeagueWhereInput> | null
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    leagueId?: SortOrderInput | SortOrder
    senderId?: SortOrder
    recipientId?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    leagueId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    senderId?: StringWithAggregatesFilter<"Message"> | string
    recipientId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    subject?: StringNullableWithAggregatesFilter<"Message"> | string | null
    content?: StringWithAggregatesFilter<"Message"> | string
    messageType?: EnumMessageTypeWithAggregatesFilter<"Message"> | $Enums.MessageType
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type GameStatsWhereInput = {
    AND?: GameStatsWhereInput | GameStatsWhereInput[]
    OR?: GameStatsWhereInput[]
    NOT?: GameStatsWhereInput | GameStatsWhereInput[]
    id?: StringFilter<"GameStats"> | string
    playerId?: StringFilter<"GameStats"> | string
    week?: IntFilter<"GameStats"> | number
    season?: IntFilter<"GameStats"> | number
    passingYards?: IntFilter<"GameStats"> | number
    passingTds?: IntFilter<"GameStats"> | number
    passingInts?: IntFilter<"GameStats"> | number
    passingAttempts?: IntFilter<"GameStats"> | number
    rushingYards?: IntFilter<"GameStats"> | number
    rushingTds?: IntFilter<"GameStats"> | number
    rushingAttempts?: IntFilter<"GameStats"> | number
    receptions?: IntFilter<"GameStats"> | number
    receivingYards?: IntFilter<"GameStats"> | number
    receivingTds?: IntFilter<"GameStats"> | number
    targets?: IntFilter<"GameStats"> | number
    fumbles?: IntFilter<"GameStats"> | number
    fumblesLost?: IntFilter<"GameStats"> | number
    fieldGoalsMade?: IntFilter<"GameStats"> | number
    fieldGoalsAttempted?: IntFilter<"GameStats"> | number
    extraPointsMade?: IntFilter<"GameStats"> | number
    extraPointsAttempted?: IntFilter<"GameStats"> | number
    sacks?: DecimalFilter<"GameStats"> | Decimal | DecimalJsLike | number | string
    interceptions?: IntFilter<"GameStats"> | number
    fumbleRecoveries?: IntFilter<"GameStats"> | number
    safeties?: IntFilter<"GameStats"> | number
    defensiveTds?: IntFilter<"GameStats"> | number
    pointsAllowed?: IntFilter<"GameStats"> | number
    fantasyPoints?: DecimalFilter<"GameStats"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"GameStats"> | Date | string
    updatedAt?: DateTimeFilter<"GameStats"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type GameStatsOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    week?: SortOrder
    season?: SortOrder
    passingYards?: SortOrder
    passingTds?: SortOrder
    passingInts?: SortOrder
    passingAttempts?: SortOrder
    rushingYards?: SortOrder
    rushingTds?: SortOrder
    rushingAttempts?: SortOrder
    receptions?: SortOrder
    receivingYards?: SortOrder
    receivingTds?: SortOrder
    targets?: SortOrder
    fumbles?: SortOrder
    fumblesLost?: SortOrder
    fieldGoalsMade?: SortOrder
    fieldGoalsAttempted?: SortOrder
    extraPointsMade?: SortOrder
    extraPointsAttempted?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
    fumbleRecoveries?: SortOrder
    safeties?: SortOrder
    defensiveTds?: SortOrder
    pointsAllowed?: SortOrder
    fantasyPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
  }

  export type GameStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_week_season?: GameStatsPlayerIdWeekSeasonCompoundUniqueInput
    AND?: GameStatsWhereInput | GameStatsWhereInput[]
    OR?: GameStatsWhereInput[]
    NOT?: GameStatsWhereInput | GameStatsWhereInput[]
    playerId?: StringFilter<"GameStats"> | string
    week?: IntFilter<"GameStats"> | number
    season?: IntFilter<"GameStats"> | number
    passingYards?: IntFilter<"GameStats"> | number
    passingTds?: IntFilter<"GameStats"> | number
    passingInts?: IntFilter<"GameStats"> | number
    passingAttempts?: IntFilter<"GameStats"> | number
    rushingYards?: IntFilter<"GameStats"> | number
    rushingTds?: IntFilter<"GameStats"> | number
    rushingAttempts?: IntFilter<"GameStats"> | number
    receptions?: IntFilter<"GameStats"> | number
    receivingYards?: IntFilter<"GameStats"> | number
    receivingTds?: IntFilter<"GameStats"> | number
    targets?: IntFilter<"GameStats"> | number
    fumbles?: IntFilter<"GameStats"> | number
    fumblesLost?: IntFilter<"GameStats"> | number
    fieldGoalsMade?: IntFilter<"GameStats"> | number
    fieldGoalsAttempted?: IntFilter<"GameStats"> | number
    extraPointsMade?: IntFilter<"GameStats"> | number
    extraPointsAttempted?: IntFilter<"GameStats"> | number
    sacks?: DecimalFilter<"GameStats"> | Decimal | DecimalJsLike | number | string
    interceptions?: IntFilter<"GameStats"> | number
    fumbleRecoveries?: IntFilter<"GameStats"> | number
    safeties?: IntFilter<"GameStats"> | number
    defensiveTds?: IntFilter<"GameStats"> | number
    pointsAllowed?: IntFilter<"GameStats"> | number
    fantasyPoints?: DecimalFilter<"GameStats"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"GameStats"> | Date | string
    updatedAt?: DateTimeFilter<"GameStats"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id" | "playerId_week_season">

  export type GameStatsOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    week?: SortOrder
    season?: SortOrder
    passingYards?: SortOrder
    passingTds?: SortOrder
    passingInts?: SortOrder
    passingAttempts?: SortOrder
    rushingYards?: SortOrder
    rushingTds?: SortOrder
    rushingAttempts?: SortOrder
    receptions?: SortOrder
    receivingYards?: SortOrder
    receivingTds?: SortOrder
    targets?: SortOrder
    fumbles?: SortOrder
    fumblesLost?: SortOrder
    fieldGoalsMade?: SortOrder
    fieldGoalsAttempted?: SortOrder
    extraPointsMade?: SortOrder
    extraPointsAttempted?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
    fumbleRecoveries?: SortOrder
    safeties?: SortOrder
    defensiveTds?: SortOrder
    pointsAllowed?: SortOrder
    fantasyPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameStatsCountOrderByAggregateInput
    _avg?: GameStatsAvgOrderByAggregateInput
    _max?: GameStatsMaxOrderByAggregateInput
    _min?: GameStatsMinOrderByAggregateInput
    _sum?: GameStatsSumOrderByAggregateInput
  }

  export type GameStatsScalarWhereWithAggregatesInput = {
    AND?: GameStatsScalarWhereWithAggregatesInput | GameStatsScalarWhereWithAggregatesInput[]
    OR?: GameStatsScalarWhereWithAggregatesInput[]
    NOT?: GameStatsScalarWhereWithAggregatesInput | GameStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameStats"> | string
    playerId?: StringWithAggregatesFilter<"GameStats"> | string
    week?: IntWithAggregatesFilter<"GameStats"> | number
    season?: IntWithAggregatesFilter<"GameStats"> | number
    passingYards?: IntWithAggregatesFilter<"GameStats"> | number
    passingTds?: IntWithAggregatesFilter<"GameStats"> | number
    passingInts?: IntWithAggregatesFilter<"GameStats"> | number
    passingAttempts?: IntWithAggregatesFilter<"GameStats"> | number
    rushingYards?: IntWithAggregatesFilter<"GameStats"> | number
    rushingTds?: IntWithAggregatesFilter<"GameStats"> | number
    rushingAttempts?: IntWithAggregatesFilter<"GameStats"> | number
    receptions?: IntWithAggregatesFilter<"GameStats"> | number
    receivingYards?: IntWithAggregatesFilter<"GameStats"> | number
    receivingTds?: IntWithAggregatesFilter<"GameStats"> | number
    targets?: IntWithAggregatesFilter<"GameStats"> | number
    fumbles?: IntWithAggregatesFilter<"GameStats"> | number
    fumblesLost?: IntWithAggregatesFilter<"GameStats"> | number
    fieldGoalsMade?: IntWithAggregatesFilter<"GameStats"> | number
    fieldGoalsAttempted?: IntWithAggregatesFilter<"GameStats"> | number
    extraPointsMade?: IntWithAggregatesFilter<"GameStats"> | number
    extraPointsAttempted?: IntWithAggregatesFilter<"GameStats"> | number
    sacks?: DecimalWithAggregatesFilter<"GameStats"> | Decimal | DecimalJsLike | number | string
    interceptions?: IntWithAggregatesFilter<"GameStats"> | number
    fumbleRecoveries?: IntWithAggregatesFilter<"GameStats"> | number
    safeties?: IntWithAggregatesFilter<"GameStats"> | number
    defensiveTds?: IntWithAggregatesFilter<"GameStats"> | number
    pointsAllowed?: IntWithAggregatesFilter<"GameStats"> | number
    fantasyPoints?: DecimalWithAggregatesFilter<"GameStats"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"GameStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameStats"> | Date | string
  }

  export type WeeklyProjectionWhereInput = {
    AND?: WeeklyProjectionWhereInput | WeeklyProjectionWhereInput[]
    OR?: WeeklyProjectionWhereInput[]
    NOT?: WeeklyProjectionWhereInput | WeeklyProjectionWhereInput[]
    id?: StringFilter<"WeeklyProjection"> | string
    playerId?: StringFilter<"WeeklyProjection"> | string
    week?: IntFilter<"WeeklyProjection"> | number
    season?: IntFilter<"WeeklyProjection"> | number
    projectedPoints?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projPassingYards?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projPassingTds?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projRushingYards?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projRushingTds?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projReceptions?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projReceivingYards?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projReceivingTds?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"WeeklyProjection"> | Date | string
    updatedAt?: DateTimeFilter<"WeeklyProjection"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type WeeklyProjectionOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    week?: SortOrder
    season?: SortOrder
    projectedPoints?: SortOrder
    confidence?: SortOrder
    projPassingYards?: SortOrder
    projPassingTds?: SortOrder
    projRushingYards?: SortOrder
    projRushingTds?: SortOrder
    projReceptions?: SortOrder
    projReceivingYards?: SortOrder
    projReceivingTds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: PlayerOrderByWithRelationInput
  }

  export type WeeklyProjectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_week_season?: WeeklyProjectionPlayerIdWeekSeasonCompoundUniqueInput
    AND?: WeeklyProjectionWhereInput | WeeklyProjectionWhereInput[]
    OR?: WeeklyProjectionWhereInput[]
    NOT?: WeeklyProjectionWhereInput | WeeklyProjectionWhereInput[]
    playerId?: StringFilter<"WeeklyProjection"> | string
    week?: IntFilter<"WeeklyProjection"> | number
    season?: IntFilter<"WeeklyProjection"> | number
    projectedPoints?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projPassingYards?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projPassingTds?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projRushingYards?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projRushingTds?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projReceptions?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projReceivingYards?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projReceivingTds?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"WeeklyProjection"> | Date | string
    updatedAt?: DateTimeFilter<"WeeklyProjection"> | Date | string
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id" | "playerId_week_season">

  export type WeeklyProjectionOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    week?: SortOrder
    season?: SortOrder
    projectedPoints?: SortOrder
    confidence?: SortOrder
    projPassingYards?: SortOrder
    projPassingTds?: SortOrder
    projRushingYards?: SortOrder
    projRushingTds?: SortOrder
    projReceptions?: SortOrder
    projReceivingYards?: SortOrder
    projReceivingTds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WeeklyProjectionCountOrderByAggregateInput
    _avg?: WeeklyProjectionAvgOrderByAggregateInput
    _max?: WeeklyProjectionMaxOrderByAggregateInput
    _min?: WeeklyProjectionMinOrderByAggregateInput
    _sum?: WeeklyProjectionSumOrderByAggregateInput
  }

  export type WeeklyProjectionScalarWhereWithAggregatesInput = {
    AND?: WeeklyProjectionScalarWhereWithAggregatesInput | WeeklyProjectionScalarWhereWithAggregatesInput[]
    OR?: WeeklyProjectionScalarWhereWithAggregatesInput[]
    NOT?: WeeklyProjectionScalarWhereWithAggregatesInput | WeeklyProjectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeeklyProjection"> | string
    playerId?: StringWithAggregatesFilter<"WeeklyProjection"> | string
    week?: IntWithAggregatesFilter<"WeeklyProjection"> | number
    season?: IntWithAggregatesFilter<"WeeklyProjection"> | number
    projectedPoints?: DecimalWithAggregatesFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalWithAggregatesFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projPassingYards?: DecimalWithAggregatesFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projPassingTds?: DecimalWithAggregatesFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projRushingYards?: DecimalWithAggregatesFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projRushingTds?: DecimalWithAggregatesFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projReceptions?: DecimalWithAggregatesFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projReceivingYards?: DecimalWithAggregatesFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projReceivingTds?: DecimalWithAggregatesFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"WeeklyProjection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WeeklyProjection"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamsOwned?: TeamCreateNestedManyWithoutOwnerInput
    leaguesCommissioned?: LeagueCreateNestedManyWithoutCommissionerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    draftPicks?: DraftPickCreateNestedManyWithoutUserInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutOffererInput
    tradeTargets?: TradeOfferCreateNestedManyWithoutTargetInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamsOwned?: TeamUncheckedCreateNestedManyWithoutOwnerInput
    leaguesCommissioned?: LeagueUncheckedCreateNestedManyWithoutCommissionerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutUserInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutOffererInput
    tradeTargets?: TradeOfferUncheckedCreateNestedManyWithoutTargetInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamsOwned?: TeamUpdateManyWithoutOwnerNestedInput
    leaguesCommissioned?: LeagueUpdateManyWithoutCommissionerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    draftPicks?: DraftPickUpdateManyWithoutUserNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutOffererNestedInput
    tradeTargets?: TradeOfferUpdateManyWithoutTargetNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamsOwned?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
    leaguesCommissioned?: LeagueUncheckedUpdateManyWithoutCommissionerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutUserNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutOffererNestedInput
    tradeTargets?: TradeOfferUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueCreateInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissioner: UserCreateNestedOneWithoutLeaguesCommissionedInput
    teams?: TeamCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsCreateNestedOneWithoutLeagueInput
    draft?: DraftCreateNestedOneWithoutLeagueInput
    games?: GameCreateNestedManyWithoutLeagueInput
    transactions?: TransactionCreateNestedManyWithoutLeagueInput
    messages?: MessageCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    commissionerId: string
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsUncheckedCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsUncheckedCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsUncheckedCreateNestedOneWithoutLeagueInput
    draft?: DraftUncheckedCreateNestedOneWithoutLeagueInput
    games?: GameUncheckedCreateNestedManyWithoutLeagueInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutLeagueInput
    messages?: MessageUncheckedCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissioner?: UserUpdateOneRequiredWithoutLeaguesCommissionedNestedInput
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUpdateOneWithoutLeagueNestedInput
    draft?: DraftUpdateOneWithoutLeagueNestedInput
    games?: GameUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUpdateManyWithoutLeagueNestedInput
    messages?: MessageUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    commissionerId?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    draft?: DraftUncheckedUpdateOneWithoutLeagueNestedInput
    games?: GameUncheckedUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutLeagueNestedInput
    messages?: MessageUncheckedUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueCreateManyInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    commissionerId: string
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeagueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    commissionerId?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueSettingsCreateInput = {
    id?: string
    scoringType?: $Enums.ScoringType
    hasDivisions?: boolean
    playoffTeams?: number
    playoffStartWeek?: number
    canTradeDraftPicks?: boolean
    tradeReviewType?: $Enums.TradeReviewType
    waiverType?: $Enums.WaiverType
    cantCutList?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutLeagueSettingsInput
  }

  export type LeagueSettingsUncheckedCreateInput = {
    id?: string
    leagueId: string
    scoringType?: $Enums.ScoringType
    hasDivisions?: boolean
    playoffTeams?: number
    playoffStartWeek?: number
    canTradeDraftPicks?: boolean
    tradeReviewType?: $Enums.TradeReviewType
    waiverType?: $Enums.WaiverType
    cantCutList?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeagueSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scoringType?: EnumScoringTypeFieldUpdateOperationsInput | $Enums.ScoringType
    hasDivisions?: BoolFieldUpdateOperationsInput | boolean
    playoffTeams?: IntFieldUpdateOperationsInput | number
    playoffStartWeek?: IntFieldUpdateOperationsInput | number
    canTradeDraftPicks?: BoolFieldUpdateOperationsInput | boolean
    tradeReviewType?: EnumTradeReviewTypeFieldUpdateOperationsInput | $Enums.TradeReviewType
    waiverType?: EnumWaiverTypeFieldUpdateOperationsInput | $Enums.WaiverType
    cantCutList?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutLeagueSettingsNestedInput
  }

  export type LeagueSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    scoringType?: EnumScoringTypeFieldUpdateOperationsInput | $Enums.ScoringType
    hasDivisions?: BoolFieldUpdateOperationsInput | boolean
    playoffTeams?: IntFieldUpdateOperationsInput | number
    playoffStartWeek?: IntFieldUpdateOperationsInput | number
    canTradeDraftPicks?: BoolFieldUpdateOperationsInput | boolean
    tradeReviewType?: EnumTradeReviewTypeFieldUpdateOperationsInput | $Enums.TradeReviewType
    waiverType?: EnumWaiverTypeFieldUpdateOperationsInput | $Enums.WaiverType
    cantCutList?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueSettingsCreateManyInput = {
    id?: string
    leagueId: string
    scoringType?: $Enums.ScoringType
    hasDivisions?: boolean
    playoffTeams?: number
    playoffStartWeek?: number
    canTradeDraftPicks?: boolean
    tradeReviewType?: $Enums.TradeReviewType
    waiverType?: $Enums.WaiverType
    cantCutList?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeagueSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scoringType?: EnumScoringTypeFieldUpdateOperationsInput | $Enums.ScoringType
    hasDivisions?: BoolFieldUpdateOperationsInput | boolean
    playoffTeams?: IntFieldUpdateOperationsInput | number
    playoffStartWeek?: IntFieldUpdateOperationsInput | number
    canTradeDraftPicks?: BoolFieldUpdateOperationsInput | boolean
    tradeReviewType?: EnumTradeReviewTypeFieldUpdateOperationsInput | $Enums.TradeReviewType
    waiverType?: EnumWaiverTypeFieldUpdateOperationsInput | $Enums.WaiverType
    cantCutList?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    scoringType?: EnumScoringTypeFieldUpdateOperationsInput | $Enums.ScoringType
    hasDivisions?: BoolFieldUpdateOperationsInput | boolean
    playoffTeams?: IntFieldUpdateOperationsInput | number
    playoffStartWeek?: IntFieldUpdateOperationsInput | number
    canTradeDraftPicks?: BoolFieldUpdateOperationsInput | boolean
    tradeReviewType?: EnumTradeReviewTypeFieldUpdateOperationsInput | $Enums.TradeReviewType
    waiverType?: EnumWaiverTypeFieldUpdateOperationsInput | $Enums.WaiverType
    cantCutList?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoringSettingsCreateInput = {
    id?: string
    passingYards?: Decimal | DecimalJsLike | number | string
    passingTds?: Decimal | DecimalJsLike | number | string
    passingInts?: Decimal | DecimalJsLike | number | string
    rushingYards?: Decimal | DecimalJsLike | number | string
    rushingTds?: Decimal | DecimalJsLike | number | string
    receivingYards?: Decimal | DecimalJsLike | number | string
    receivingTds?: Decimal | DecimalJsLike | number | string
    receptions?: Decimal | DecimalJsLike | number | string
    fumbles?: Decimal | DecimalJsLike | number | string
    fieldGoals?: Decimal | DecimalJsLike | number | string
    extraPoints?: Decimal | DecimalJsLike | number | string
    sacks?: Decimal | DecimalJsLike | number | string
    interceptions?: Decimal | DecimalJsLike | number | string
    fumbleRecoveries?: Decimal | DecimalJsLike | number | string
    safeties?: Decimal | DecimalJsLike | number | string
    defensiveTds?: Decimal | DecimalJsLike | number | string
    pointsAllowed0?: Decimal | DecimalJsLike | number | string
    pointsAllowed1to6?: Decimal | DecimalJsLike | number | string
    pointsAllowed7to13?: Decimal | DecimalJsLike | number | string
    pointsAllowed14to20?: Decimal | DecimalJsLike | number | string
    pointsAllowed21to27?: Decimal | DecimalJsLike | number | string
    pointsAllowed28plus?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutScoringSettingsInput
  }

  export type ScoringSettingsUncheckedCreateInput = {
    id?: string
    leagueId: string
    passingYards?: Decimal | DecimalJsLike | number | string
    passingTds?: Decimal | DecimalJsLike | number | string
    passingInts?: Decimal | DecimalJsLike | number | string
    rushingYards?: Decimal | DecimalJsLike | number | string
    rushingTds?: Decimal | DecimalJsLike | number | string
    receivingYards?: Decimal | DecimalJsLike | number | string
    receivingTds?: Decimal | DecimalJsLike | number | string
    receptions?: Decimal | DecimalJsLike | number | string
    fumbles?: Decimal | DecimalJsLike | number | string
    fieldGoals?: Decimal | DecimalJsLike | number | string
    extraPoints?: Decimal | DecimalJsLike | number | string
    sacks?: Decimal | DecimalJsLike | number | string
    interceptions?: Decimal | DecimalJsLike | number | string
    fumbleRecoveries?: Decimal | DecimalJsLike | number | string
    safeties?: Decimal | DecimalJsLike | number | string
    defensiveTds?: Decimal | DecimalJsLike | number | string
    pointsAllowed0?: Decimal | DecimalJsLike | number | string
    pointsAllowed1to6?: Decimal | DecimalJsLike | number | string
    pointsAllowed7to13?: Decimal | DecimalJsLike | number | string
    pointsAllowed14to20?: Decimal | DecimalJsLike | number | string
    pointsAllowed21to27?: Decimal | DecimalJsLike | number | string
    pointsAllowed28plus?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScoringSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passingInts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rushingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rushingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fumbles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fieldGoals?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    extraPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sacks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interceptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fumbleRecoveries?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    safeties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defensiveTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed0?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed1to6?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed7to13?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed14to20?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed21to27?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed28plus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutScoringSettingsNestedInput
  }

  export type ScoringSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    passingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passingInts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rushingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rushingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fumbles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fieldGoals?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    extraPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sacks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interceptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fumbleRecoveries?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    safeties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defensiveTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed0?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed1to6?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed7to13?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed14to20?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed21to27?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed28plus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoringSettingsCreateManyInput = {
    id?: string
    leagueId: string
    passingYards?: Decimal | DecimalJsLike | number | string
    passingTds?: Decimal | DecimalJsLike | number | string
    passingInts?: Decimal | DecimalJsLike | number | string
    rushingYards?: Decimal | DecimalJsLike | number | string
    rushingTds?: Decimal | DecimalJsLike | number | string
    receivingYards?: Decimal | DecimalJsLike | number | string
    receivingTds?: Decimal | DecimalJsLike | number | string
    receptions?: Decimal | DecimalJsLike | number | string
    fumbles?: Decimal | DecimalJsLike | number | string
    fieldGoals?: Decimal | DecimalJsLike | number | string
    extraPoints?: Decimal | DecimalJsLike | number | string
    sacks?: Decimal | DecimalJsLike | number | string
    interceptions?: Decimal | DecimalJsLike | number | string
    fumbleRecoveries?: Decimal | DecimalJsLike | number | string
    safeties?: Decimal | DecimalJsLike | number | string
    defensiveTds?: Decimal | DecimalJsLike | number | string
    pointsAllowed0?: Decimal | DecimalJsLike | number | string
    pointsAllowed1to6?: Decimal | DecimalJsLike | number | string
    pointsAllowed7to13?: Decimal | DecimalJsLike | number | string
    pointsAllowed14to20?: Decimal | DecimalJsLike | number | string
    pointsAllowed21to27?: Decimal | DecimalJsLike | number | string
    pointsAllowed28plus?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScoringSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    passingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passingInts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rushingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rushingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fumbles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fieldGoals?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    extraPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sacks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interceptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fumbleRecoveries?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    safeties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defensiveTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed0?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed1to6?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed7to13?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed14to20?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed21to27?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed28plus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoringSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    passingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passingInts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rushingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rushingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fumbles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fieldGoals?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    extraPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sacks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interceptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fumbleRecoveries?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    safeties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defensiveTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed0?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed1to6?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed7to13?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed14to20?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed21to27?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed28plus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RosterSettingsCreateInput = {
    id?: string
    qbSlots?: number
    rbSlots?: number
    wrSlots?: number
    teSlots?: number
    flexSlots?: number
    kSlots?: number
    defSlots?: number
    benchSlots?: number
    irSlots?: number
    maxRosterSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutRosterSettingsInput
  }

  export type RosterSettingsUncheckedCreateInput = {
    id?: string
    leagueId: string
    qbSlots?: number
    rbSlots?: number
    wrSlots?: number
    teSlots?: number
    flexSlots?: number
    kSlots?: number
    defSlots?: number
    benchSlots?: number
    irSlots?: number
    maxRosterSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RosterSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qbSlots?: IntFieldUpdateOperationsInput | number
    rbSlots?: IntFieldUpdateOperationsInput | number
    wrSlots?: IntFieldUpdateOperationsInput | number
    teSlots?: IntFieldUpdateOperationsInput | number
    flexSlots?: IntFieldUpdateOperationsInput | number
    kSlots?: IntFieldUpdateOperationsInput | number
    defSlots?: IntFieldUpdateOperationsInput | number
    benchSlots?: IntFieldUpdateOperationsInput | number
    irSlots?: IntFieldUpdateOperationsInput | number
    maxRosterSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutRosterSettingsNestedInput
  }

  export type RosterSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    qbSlots?: IntFieldUpdateOperationsInput | number
    rbSlots?: IntFieldUpdateOperationsInput | number
    wrSlots?: IntFieldUpdateOperationsInput | number
    teSlots?: IntFieldUpdateOperationsInput | number
    flexSlots?: IntFieldUpdateOperationsInput | number
    kSlots?: IntFieldUpdateOperationsInput | number
    defSlots?: IntFieldUpdateOperationsInput | number
    benchSlots?: IntFieldUpdateOperationsInput | number
    irSlots?: IntFieldUpdateOperationsInput | number
    maxRosterSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RosterSettingsCreateManyInput = {
    id?: string
    leagueId: string
    qbSlots?: number
    rbSlots?: number
    wrSlots?: number
    teSlots?: number
    flexSlots?: number
    kSlots?: number
    defSlots?: number
    benchSlots?: number
    irSlots?: number
    maxRosterSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RosterSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qbSlots?: IntFieldUpdateOperationsInput | number
    rbSlots?: IntFieldUpdateOperationsInput | number
    wrSlots?: IntFieldUpdateOperationsInput | number
    teSlots?: IntFieldUpdateOperationsInput | number
    flexSlots?: IntFieldUpdateOperationsInput | number
    kSlots?: IntFieldUpdateOperationsInput | number
    defSlots?: IntFieldUpdateOperationsInput | number
    benchSlots?: IntFieldUpdateOperationsInput | number
    irSlots?: IntFieldUpdateOperationsInput | number
    maxRosterSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RosterSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    qbSlots?: IntFieldUpdateOperationsInput | number
    rbSlots?: IntFieldUpdateOperationsInput | number
    wrSlots?: IntFieldUpdateOperationsInput | number
    teSlots?: IntFieldUpdateOperationsInput | number
    flexSlots?: IntFieldUpdateOperationsInput | number
    kSlots?: IntFieldUpdateOperationsInput | number
    defSlots?: IntFieldUpdateOperationsInput | number
    benchSlots?: IntFieldUpdateOperationsInput | number
    irSlots?: IntFieldUpdateOperationsInput | number
    maxRosterSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTeamsInput
    owner: UserCreateNestedOneWithoutTeamsOwnedInput
    roster?: RosterCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickCreateNestedManyWithoutTeamInput
    homeGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    leagueId: string
    ownerId: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterUncheckedCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutTeamInput
    homeGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferUncheckedCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferUncheckedCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTeamsNestedInput
    owner?: UserUpdateOneRequiredWithoutTeamsOwnedNestedInput
    roster?: RosterUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUpdateManyWithoutTeamNestedInput
    homeGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUpdateManyWithoutTargetTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUncheckedUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutTeamNestedInput
    homeGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUncheckedUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUncheckedUpdateManyWithoutTargetTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    leagueId: string
    ownerId: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCreateInput = {
    id?: string
    externalId?: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number?: number | null
    byeWeek?: number | null
    isActive?: boolean
    injuryStatus?: $Enums.InjuryStatus
    injuryNote?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterCreateNestedManyWithoutPlayerInput
    draftPicks?: DraftPickCreateNestedManyWithoutPlayerInput
    transactions?: TransactionCreateNestedManyWithoutPlayerInput
    gameStats?: GameStatsCreateNestedManyWithoutPlayerInput
    weeklyProjections?: WeeklyProjectionCreateNestedManyWithoutPlayerInput
    tradeOfferPlayers?: TradeOfferPlayerCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateInput = {
    id?: string
    externalId?: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number?: number | null
    byeWeek?: number | null
    isActive?: boolean
    injuryStatus?: $Enums.InjuryStatus
    injuryNote?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterUncheckedCreateNestedManyWithoutPlayerInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutPlayerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutPlayerInput
    gameStats?: GameStatsUncheckedCreateNestedManyWithoutPlayerInput
    weeklyProjections?: WeeklyProjectionUncheckedCreateNestedManyWithoutPlayerInput
    tradeOfferPlayers?: TradeOfferPlayerUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUpdateManyWithoutPlayerNestedInput
    draftPicks?: DraftPickUpdateManyWithoutPlayerNestedInput
    transactions?: TransactionUpdateManyWithoutPlayerNestedInput
    gameStats?: GameStatsUpdateManyWithoutPlayerNestedInput
    weeklyProjections?: WeeklyProjectionUpdateManyWithoutPlayerNestedInput
    tradeOfferPlayers?: TradeOfferPlayerUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUncheckedUpdateManyWithoutPlayerNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutPlayerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutPlayerNestedInput
    gameStats?: GameStatsUncheckedUpdateManyWithoutPlayerNestedInput
    weeklyProjections?: WeeklyProjectionUncheckedUpdateManyWithoutPlayerNestedInput
    tradeOfferPlayers?: TradeOfferPlayerUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerCreateManyInput = {
    id?: string
    externalId?: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number?: number | null
    byeWeek?: number | null
    isActive?: boolean
    injuryStatus?: $Enums.InjuryStatus
    injuryNote?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RosterCreateInput = {
    id?: string
    position?: $Enums.RosterPosition
    isStarter?: boolean
    acquiredDate?: Date | string
    weekAdded?: number | null
    team: TeamCreateNestedOneWithoutRosterInput
    player: PlayerCreateNestedOneWithoutRosterInput
  }

  export type RosterUncheckedCreateInput = {
    id?: string
    teamId: string
    playerId: string
    position?: $Enums.RosterPosition
    isStarter?: boolean
    acquiredDate?: Date | string
    weekAdded?: number | null
  }

  export type RosterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: EnumRosterPositionFieldUpdateOperationsInput | $Enums.RosterPosition
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weekAdded?: NullableIntFieldUpdateOperationsInput | number | null
    team?: TeamUpdateOneRequiredWithoutRosterNestedInput
    player?: PlayerUpdateOneRequiredWithoutRosterNestedInput
  }

  export type RosterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    position?: EnumRosterPositionFieldUpdateOperationsInput | $Enums.RosterPosition
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weekAdded?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RosterCreateManyInput = {
    id?: string
    teamId: string
    playerId: string
    position?: $Enums.RosterPosition
    isStarter?: boolean
    acquiredDate?: Date | string
    weekAdded?: number | null
  }

  export type RosterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: EnumRosterPositionFieldUpdateOperationsInput | $Enums.RosterPosition
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weekAdded?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RosterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    position?: EnumRosterPositionFieldUpdateOperationsInput | $Enums.RosterPosition
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weekAdded?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DraftCreateInput = {
    id?: string
    draftType: $Enums.DraftType
    draftDate?: Date | string | null
    isComplete?: boolean
    currentRound?: number
    currentPick?: number
    timePerPick?: number
    draftOrder?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutDraftInput
    picks?: DraftPickCreateNestedManyWithoutDraftInput
  }

  export type DraftUncheckedCreateInput = {
    id?: string
    leagueId: string
    draftType: $Enums.DraftType
    draftDate?: Date | string | null
    isComplete?: boolean
    currentRound?: number
    currentPick?: number
    timePerPick?: number
    draftOrder?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    picks?: DraftPickUncheckedCreateNestedManyWithoutDraftInput
  }

  export type DraftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    currentRound?: IntFieldUpdateOperationsInput | number
    currentPick?: IntFieldUpdateOperationsInput | number
    timePerPick?: IntFieldUpdateOperationsInput | number
    draftOrder?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutDraftNestedInput
    picks?: DraftPickUpdateManyWithoutDraftNestedInput
  }

  export type DraftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    currentRound?: IntFieldUpdateOperationsInput | number
    currentPick?: IntFieldUpdateOperationsInput | number
    timePerPick?: IntFieldUpdateOperationsInput | number
    draftOrder?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    picks?: DraftPickUncheckedUpdateManyWithoutDraftNestedInput
  }

  export type DraftCreateManyInput = {
    id?: string
    leagueId: string
    draftType: $Enums.DraftType
    draftDate?: Date | string | null
    isComplete?: boolean
    currentRound?: number
    currentPick?: number
    timePerPick?: number
    draftOrder?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DraftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    currentRound?: IntFieldUpdateOperationsInput | number
    currentPick?: IntFieldUpdateOperationsInput | number
    timePerPick?: IntFieldUpdateOperationsInput | number
    draftOrder?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    currentRound?: IntFieldUpdateOperationsInput | number
    currentPick?: IntFieldUpdateOperationsInput | number
    timePerPick?: IntFieldUpdateOperationsInput | number
    draftOrder?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftPickCreateInput = {
    id?: string
    round: number
    pick: number
    pickInRound: number
    pickTime?: Date | string | null
    isKeeper?: boolean
    createdAt?: Date | string
    draft: DraftCreateNestedOneWithoutPicksInput
    team: TeamCreateNestedOneWithoutDraftPicksInput
    user: UserCreateNestedOneWithoutDraftPicksInput
    player?: PlayerCreateNestedOneWithoutDraftPicksInput
  }

  export type DraftPickUncheckedCreateInput = {
    id?: string
    draftId: string
    teamId: string
    userId: string
    playerId?: string | null
    round: number
    pick: number
    pickInRound: number
    pickTime?: Date | string | null
    isKeeper?: boolean
    createdAt?: Date | string
  }

  export type DraftPickUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draft?: DraftUpdateOneRequiredWithoutPicksNestedInput
    team?: TeamUpdateOneRequiredWithoutDraftPicksNestedInput
    user?: UserUpdateOneRequiredWithoutDraftPicksNestedInput
    player?: PlayerUpdateOneWithoutDraftPicksNestedInput
  }

  export type DraftPickUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftPickCreateManyInput = {
    id?: string
    draftId: string
    teamId: string
    userId: string
    playerId?: string | null
    round: number
    pick: number
    pickInRound: number
    pickTime?: Date | string | null
    isKeeper?: boolean
    createdAt?: Date | string
  }

  export type DraftPickUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftPickUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCreateInput = {
    id?: string
    week: number
    season?: number
    homeScore?: Decimal | DecimalJsLike | number | string
    awayScore?: Decimal | DecimalJsLike | number | string
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutGamesInput
    homeTeam: TeamCreateNestedOneWithoutHomeGamesInput
    awayTeam: TeamCreateNestedOneWithoutAwayGamesInput
  }

  export type GameUncheckedCreateInput = {
    id?: string
    leagueId: string
    homeTeamId: string
    awayTeamId: string
    week: number
    season?: number
    homeScore?: Decimal | DecimalJsLike | number | string
    awayScore?: Decimal | DecimalJsLike | number | string
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    homeScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isPlayoffs?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutGamesNestedInput
    homeTeam?: TeamUpdateOneRequiredWithoutHomeGamesNestedInput
    awayTeam?: TeamUpdateOneRequiredWithoutAwayGamesNestedInput
  }

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    homeScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isPlayoffs?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCreateManyInput = {
    id?: string
    leagueId: string
    homeTeamId: string
    awayTeamId: string
    week: number
    season?: number
    homeScore?: Decimal | DecimalJsLike | number | string
    awayScore?: Decimal | DecimalJsLike | number | string
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    homeScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isPlayoffs?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    homeScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isPlayoffs?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    transactionType: $Enums.TransactionType
    week: number
    description?: string | null
    isProcessed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
    league: LeagueCreateNestedOneWithoutTransactionsInput
    team: TeamCreateNestedOneWithoutTransactionsInput
    user: UserCreateNestedOneWithoutTransactionsInput
    player: PlayerCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    leagueId: string
    teamId: string
    userId: string
    playerId: string
    transactionType: $Enums.TransactionType
    week: number
    description?: string | null
    isProcessed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTransactionsNestedInput
    team?: TeamUpdateOneRequiredWithoutTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    player?: PlayerUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    leagueId: string
    teamId: string
    userId: string
    playerId: string
    transactionType: $Enums.TransactionType
    week: number
    description?: string | null
    isProcessed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeOfferCreateInput = {
    id?: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTradeOffersInput
    offeringTeam: TeamCreateNestedOneWithoutOfferedTradesInput
    targetTeam: TeamCreateNestedOneWithoutTargetedTradesInput
    offerer: UserCreateNestedOneWithoutTradeOffersInput
    target: UserCreateNestedOneWithoutTradeTargetsInput
    players?: TradeOfferPlayerCreateNestedManyWithoutTradeOfferInput
  }

  export type TradeOfferUncheckedCreateInput = {
    id?: string
    leagueId: string
    offeringTeamId: string
    targetTeamId: string
    offererId: string
    targetId: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: TradeOfferPlayerUncheckedCreateNestedManyWithoutTradeOfferInput
  }

  export type TradeOfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTradeOffersNestedInput
    offeringTeam?: TeamUpdateOneRequiredWithoutOfferedTradesNestedInput
    targetTeam?: TeamUpdateOneRequiredWithoutTargetedTradesNestedInput
    offerer?: UserUpdateOneRequiredWithoutTradeOffersNestedInput
    target?: UserUpdateOneRequiredWithoutTradeTargetsNestedInput
    players?: TradeOfferPlayerUpdateManyWithoutTradeOfferNestedInput
  }

  export type TradeOfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    offeringTeamId?: StringFieldUpdateOperationsInput | string
    targetTeamId?: StringFieldUpdateOperationsInput | string
    offererId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: TradeOfferPlayerUncheckedUpdateManyWithoutTradeOfferNestedInput
  }

  export type TradeOfferCreateManyInput = {
    id?: string
    leagueId: string
    offeringTeamId: string
    targetTeamId: string
    offererId: string
    targetId: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeOfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeOfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    offeringTeamId?: StringFieldUpdateOperationsInput | string
    targetTeamId?: StringFieldUpdateOperationsInput | string
    offererId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeOfferPlayerCreateInput = {
    id?: string
    fromTeam: boolean
    tradeOffer: TradeOfferCreateNestedOneWithoutPlayersInput
    player: PlayerCreateNestedOneWithoutTradeOfferPlayersInput
  }

  export type TradeOfferPlayerUncheckedCreateInput = {
    id?: string
    tradeOfferId: string
    playerId: string
    fromTeam: boolean
  }

  export type TradeOfferPlayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromTeam?: BoolFieldUpdateOperationsInput | boolean
    tradeOffer?: TradeOfferUpdateOneRequiredWithoutPlayersNestedInput
    player?: PlayerUpdateOneRequiredWithoutTradeOfferPlayersNestedInput
  }

  export type TradeOfferPlayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeOfferId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    fromTeam?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TradeOfferPlayerCreateManyInput = {
    id?: string
    tradeOfferId: string
    playerId: string
    fromTeam: boolean
  }

  export type TradeOfferPlayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromTeam?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TradeOfferPlayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeOfferId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    fromTeam?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageCreateInput = {
    id?: string
    recipientId?: string | null
    subject?: string | null
    content: string
    messageType?: $Enums.MessageType
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    league?: LeagueCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    leagueId?: string | null
    senderId: string
    recipientId?: string | null
    subject?: string | null
    content: string
    messageType?: $Enums.MessageType
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    leagueId?: string | null
    senderId: string
    recipientId?: string | null
    subject?: string | null
    content: string
    messageType?: $Enums.MessageType
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameStatsCreateInput = {
    id?: string
    week: number
    season?: number
    passingYards?: number
    passingTds?: number
    passingInts?: number
    passingAttempts?: number
    rushingYards?: number
    rushingTds?: number
    rushingAttempts?: number
    receptions?: number
    receivingYards?: number
    receivingTds?: number
    targets?: number
    fumbles?: number
    fumblesLost?: number
    fieldGoalsMade?: number
    fieldGoalsAttempted?: number
    extraPointsMade?: number
    extraPointsAttempted?: number
    sacks?: Decimal | DecimalJsLike | number | string
    interceptions?: number
    fumbleRecoveries?: number
    safeties?: number
    defensiveTds?: number
    pointsAllowed?: number
    fantasyPoints?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutGameStatsInput
  }

  export type GameStatsUncheckedCreateInput = {
    id?: string
    playerId: string
    week: number
    season?: number
    passingYards?: number
    passingTds?: number
    passingInts?: number
    passingAttempts?: number
    rushingYards?: number
    rushingTds?: number
    rushingAttempts?: number
    receptions?: number
    receivingYards?: number
    receivingTds?: number
    targets?: number
    fumbles?: number
    fumblesLost?: number
    fieldGoalsMade?: number
    fieldGoalsAttempted?: number
    extraPointsMade?: number
    extraPointsAttempted?: number
    sacks?: Decimal | DecimalJsLike | number | string
    interceptions?: number
    fumbleRecoveries?: number
    safeties?: number
    defensiveTds?: number
    pointsAllowed?: number
    fantasyPoints?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    passingYards?: IntFieldUpdateOperationsInput | number
    passingTds?: IntFieldUpdateOperationsInput | number
    passingInts?: IntFieldUpdateOperationsInput | number
    passingAttempts?: IntFieldUpdateOperationsInput | number
    rushingYards?: IntFieldUpdateOperationsInput | number
    rushingTds?: IntFieldUpdateOperationsInput | number
    rushingAttempts?: IntFieldUpdateOperationsInput | number
    receptions?: IntFieldUpdateOperationsInput | number
    receivingYards?: IntFieldUpdateOperationsInput | number
    receivingTds?: IntFieldUpdateOperationsInput | number
    targets?: IntFieldUpdateOperationsInput | number
    fumbles?: IntFieldUpdateOperationsInput | number
    fumblesLost?: IntFieldUpdateOperationsInput | number
    fieldGoalsMade?: IntFieldUpdateOperationsInput | number
    fieldGoalsAttempted?: IntFieldUpdateOperationsInput | number
    extraPointsMade?: IntFieldUpdateOperationsInput | number
    extraPointsAttempted?: IntFieldUpdateOperationsInput | number
    sacks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interceptions?: IntFieldUpdateOperationsInput | number
    fumbleRecoveries?: IntFieldUpdateOperationsInput | number
    safeties?: IntFieldUpdateOperationsInput | number
    defensiveTds?: IntFieldUpdateOperationsInput | number
    pointsAllowed?: IntFieldUpdateOperationsInput | number
    fantasyPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutGameStatsNestedInput
  }

  export type GameStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    passingYards?: IntFieldUpdateOperationsInput | number
    passingTds?: IntFieldUpdateOperationsInput | number
    passingInts?: IntFieldUpdateOperationsInput | number
    passingAttempts?: IntFieldUpdateOperationsInput | number
    rushingYards?: IntFieldUpdateOperationsInput | number
    rushingTds?: IntFieldUpdateOperationsInput | number
    rushingAttempts?: IntFieldUpdateOperationsInput | number
    receptions?: IntFieldUpdateOperationsInput | number
    receivingYards?: IntFieldUpdateOperationsInput | number
    receivingTds?: IntFieldUpdateOperationsInput | number
    targets?: IntFieldUpdateOperationsInput | number
    fumbles?: IntFieldUpdateOperationsInput | number
    fumblesLost?: IntFieldUpdateOperationsInput | number
    fieldGoalsMade?: IntFieldUpdateOperationsInput | number
    fieldGoalsAttempted?: IntFieldUpdateOperationsInput | number
    extraPointsMade?: IntFieldUpdateOperationsInput | number
    extraPointsAttempted?: IntFieldUpdateOperationsInput | number
    sacks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interceptions?: IntFieldUpdateOperationsInput | number
    fumbleRecoveries?: IntFieldUpdateOperationsInput | number
    safeties?: IntFieldUpdateOperationsInput | number
    defensiveTds?: IntFieldUpdateOperationsInput | number
    pointsAllowed?: IntFieldUpdateOperationsInput | number
    fantasyPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameStatsCreateManyInput = {
    id?: string
    playerId: string
    week: number
    season?: number
    passingYards?: number
    passingTds?: number
    passingInts?: number
    passingAttempts?: number
    rushingYards?: number
    rushingTds?: number
    rushingAttempts?: number
    receptions?: number
    receivingYards?: number
    receivingTds?: number
    targets?: number
    fumbles?: number
    fumblesLost?: number
    fieldGoalsMade?: number
    fieldGoalsAttempted?: number
    extraPointsMade?: number
    extraPointsAttempted?: number
    sacks?: Decimal | DecimalJsLike | number | string
    interceptions?: number
    fumbleRecoveries?: number
    safeties?: number
    defensiveTds?: number
    pointsAllowed?: number
    fantasyPoints?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    passingYards?: IntFieldUpdateOperationsInput | number
    passingTds?: IntFieldUpdateOperationsInput | number
    passingInts?: IntFieldUpdateOperationsInput | number
    passingAttempts?: IntFieldUpdateOperationsInput | number
    rushingYards?: IntFieldUpdateOperationsInput | number
    rushingTds?: IntFieldUpdateOperationsInput | number
    rushingAttempts?: IntFieldUpdateOperationsInput | number
    receptions?: IntFieldUpdateOperationsInput | number
    receivingYards?: IntFieldUpdateOperationsInput | number
    receivingTds?: IntFieldUpdateOperationsInput | number
    targets?: IntFieldUpdateOperationsInput | number
    fumbles?: IntFieldUpdateOperationsInput | number
    fumblesLost?: IntFieldUpdateOperationsInput | number
    fieldGoalsMade?: IntFieldUpdateOperationsInput | number
    fieldGoalsAttempted?: IntFieldUpdateOperationsInput | number
    extraPointsMade?: IntFieldUpdateOperationsInput | number
    extraPointsAttempted?: IntFieldUpdateOperationsInput | number
    sacks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interceptions?: IntFieldUpdateOperationsInput | number
    fumbleRecoveries?: IntFieldUpdateOperationsInput | number
    safeties?: IntFieldUpdateOperationsInput | number
    defensiveTds?: IntFieldUpdateOperationsInput | number
    pointsAllowed?: IntFieldUpdateOperationsInput | number
    fantasyPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    passingYards?: IntFieldUpdateOperationsInput | number
    passingTds?: IntFieldUpdateOperationsInput | number
    passingInts?: IntFieldUpdateOperationsInput | number
    passingAttempts?: IntFieldUpdateOperationsInput | number
    rushingYards?: IntFieldUpdateOperationsInput | number
    rushingTds?: IntFieldUpdateOperationsInput | number
    rushingAttempts?: IntFieldUpdateOperationsInput | number
    receptions?: IntFieldUpdateOperationsInput | number
    receivingYards?: IntFieldUpdateOperationsInput | number
    receivingTds?: IntFieldUpdateOperationsInput | number
    targets?: IntFieldUpdateOperationsInput | number
    fumbles?: IntFieldUpdateOperationsInput | number
    fumblesLost?: IntFieldUpdateOperationsInput | number
    fieldGoalsMade?: IntFieldUpdateOperationsInput | number
    fieldGoalsAttempted?: IntFieldUpdateOperationsInput | number
    extraPointsMade?: IntFieldUpdateOperationsInput | number
    extraPointsAttempted?: IntFieldUpdateOperationsInput | number
    sacks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interceptions?: IntFieldUpdateOperationsInput | number
    fumbleRecoveries?: IntFieldUpdateOperationsInput | number
    safeties?: IntFieldUpdateOperationsInput | number
    defensiveTds?: IntFieldUpdateOperationsInput | number
    pointsAllowed?: IntFieldUpdateOperationsInput | number
    fantasyPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyProjectionCreateInput = {
    id?: string
    week: number
    season?: number
    projectedPoints?: Decimal | DecimalJsLike | number | string
    confidence?: Decimal | DecimalJsLike | number | string
    projPassingYards?: Decimal | DecimalJsLike | number | string
    projPassingTds?: Decimal | DecimalJsLike | number | string
    projRushingYards?: Decimal | DecimalJsLike | number | string
    projRushingTds?: Decimal | DecimalJsLike | number | string
    projReceptions?: Decimal | DecimalJsLike | number | string
    projReceivingYards?: Decimal | DecimalJsLike | number | string
    projReceivingTds?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    player: PlayerCreateNestedOneWithoutWeeklyProjectionsInput
  }

  export type WeeklyProjectionUncheckedCreateInput = {
    id?: string
    playerId: string
    week: number
    season?: number
    projectedPoints?: Decimal | DecimalJsLike | number | string
    confidence?: Decimal | DecimalJsLike | number | string
    projPassingYards?: Decimal | DecimalJsLike | number | string
    projPassingTds?: Decimal | DecimalJsLike | number | string
    projRushingYards?: Decimal | DecimalJsLike | number | string
    projRushingTds?: Decimal | DecimalJsLike | number | string
    projReceptions?: Decimal | DecimalJsLike | number | string
    projReceivingYards?: Decimal | DecimalJsLike | number | string
    projReceivingTds?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyProjectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    projectedPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projPassingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projPassingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projRushingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projRushingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceivingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceivingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutWeeklyProjectionsNestedInput
  }

  export type WeeklyProjectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    projectedPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projPassingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projPassingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projRushingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projRushingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceivingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceivingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyProjectionCreateManyInput = {
    id?: string
    playerId: string
    week: number
    season?: number
    projectedPoints?: Decimal | DecimalJsLike | number | string
    confidence?: Decimal | DecimalJsLike | number | string
    projPassingYards?: Decimal | DecimalJsLike | number | string
    projPassingTds?: Decimal | DecimalJsLike | number | string
    projRushingYards?: Decimal | DecimalJsLike | number | string
    projRushingTds?: Decimal | DecimalJsLike | number | string
    projReceptions?: Decimal | DecimalJsLike | number | string
    projReceivingYards?: Decimal | DecimalJsLike | number | string
    projReceivingTds?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyProjectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    projectedPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projPassingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projPassingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projRushingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projRushingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceivingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceivingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyProjectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    projectedPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projPassingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projPassingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projRushingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projRushingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceivingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceivingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type LeagueListRelationFilter = {
    every?: LeagueWhereInput
    some?: LeagueWhereInput
    none?: LeagueWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type DraftPickListRelationFilter = {
    every?: DraftPickWhereInput
    some?: DraftPickWhereInput
    none?: DraftPickWhereInput
  }

  export type TradeOfferListRelationFilter = {
    every?: TradeOfferWhereInput
    some?: TradeOfferWhereInput
    none?: TradeOfferWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeagueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DraftPickOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TradeOfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumDraftTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DraftType | EnumDraftTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DraftType[] | ListEnumDraftTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DraftType[] | ListEnumDraftTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDraftTypeFilter<$PrismaModel> | $Enums.DraftType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type LeagueSettingsNullableScalarRelationFilter = {
    is?: LeagueSettingsWhereInput | null
    isNot?: LeagueSettingsWhereInput | null
  }

  export type ScoringSettingsNullableScalarRelationFilter = {
    is?: ScoringSettingsWhereInput | null
    isNot?: ScoringSettingsWhereInput | null
  }

  export type RosterSettingsNullableScalarRelationFilter = {
    is?: RosterSettingsWhereInput | null
    isNot?: RosterSettingsWhereInput | null
  }

  export type DraftNullableScalarRelationFilter = {
    is?: DraftWhereInput | null
    isNot?: DraftWhereInput | null
  }

  export type GameListRelationFilter = {
    every?: GameWhereInput
    some?: GameWhereInput
    none?: GameWhereInput
  }

  export type GameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeagueCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    customUrl?: SortOrder
    commissionerId?: SortOrder
    maxTeams?: SortOrder
    isActive?: SortOrder
    isPaid?: SortOrder
    entryFee?: SortOrder
    prizeAmount?: SortOrder
    draftType?: SortOrder
    draftDate?: SortOrder
    seasonStartWeek?: SortOrder
    leagueStartDate?: SortOrder
    rosterDeadline?: SortOrder
    maxAddsPerSeason?: SortOrder
    maxAddsPerWeek?: SortOrder
    tradeRejectTime?: SortOrder
    tradeEndDate?: SortOrder
    waiverTime?: SortOrder
    commissionerMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeagueAvgOrderByAggregateInput = {
    maxTeams?: SortOrder
    entryFee?: SortOrder
    prizeAmount?: SortOrder
    seasonStartWeek?: SortOrder
    maxAddsPerSeason?: SortOrder
    maxAddsPerWeek?: SortOrder
    tradeRejectTime?: SortOrder
    waiverTime?: SortOrder
  }

  export type LeagueMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    customUrl?: SortOrder
    commissionerId?: SortOrder
    maxTeams?: SortOrder
    isActive?: SortOrder
    isPaid?: SortOrder
    entryFee?: SortOrder
    prizeAmount?: SortOrder
    draftType?: SortOrder
    draftDate?: SortOrder
    seasonStartWeek?: SortOrder
    leagueStartDate?: SortOrder
    rosterDeadline?: SortOrder
    maxAddsPerSeason?: SortOrder
    maxAddsPerWeek?: SortOrder
    tradeRejectTime?: SortOrder
    tradeEndDate?: SortOrder
    waiverTime?: SortOrder
    commissionerMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeagueMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    customUrl?: SortOrder
    commissionerId?: SortOrder
    maxTeams?: SortOrder
    isActive?: SortOrder
    isPaid?: SortOrder
    entryFee?: SortOrder
    prizeAmount?: SortOrder
    draftType?: SortOrder
    draftDate?: SortOrder
    seasonStartWeek?: SortOrder
    leagueStartDate?: SortOrder
    rosterDeadline?: SortOrder
    maxAddsPerSeason?: SortOrder
    maxAddsPerWeek?: SortOrder
    tradeRejectTime?: SortOrder
    tradeEndDate?: SortOrder
    waiverTime?: SortOrder
    commissionerMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeagueSumOrderByAggregateInput = {
    maxTeams?: SortOrder
    entryFee?: SortOrder
    prizeAmount?: SortOrder
    seasonStartWeek?: SortOrder
    maxAddsPerSeason?: SortOrder
    maxAddsPerWeek?: SortOrder
    tradeRejectTime?: SortOrder
    waiverTime?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumDraftTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DraftType | EnumDraftTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DraftType[] | ListEnumDraftTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DraftType[] | ListEnumDraftTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDraftTypeWithAggregatesFilter<$PrismaModel> | $Enums.DraftType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDraftTypeFilter<$PrismaModel>
    _max?: NestedEnumDraftTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumScoringTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoringType | EnumScoringTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoringType[] | ListEnumScoringTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoringType[] | ListEnumScoringTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoringTypeFilter<$PrismaModel> | $Enums.ScoringType
  }

  export type EnumTradeReviewTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeReviewType | EnumTradeReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TradeReviewType[] | ListEnumTradeReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeReviewType[] | ListEnumTradeReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeReviewTypeFilter<$PrismaModel> | $Enums.TradeReviewType
  }

  export type EnumWaiverTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WaiverType | EnumWaiverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WaiverType[] | ListEnumWaiverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WaiverType[] | ListEnumWaiverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWaiverTypeFilter<$PrismaModel> | $Enums.WaiverType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type LeagueScalarRelationFilter = {
    is?: LeagueWhereInput
    isNot?: LeagueWhereInput
  }

  export type LeagueSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    scoringType?: SortOrder
    hasDivisions?: SortOrder
    playoffTeams?: SortOrder
    playoffStartWeek?: SortOrder
    canTradeDraftPicks?: SortOrder
    tradeReviewType?: SortOrder
    waiverType?: SortOrder
    cantCutList?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeagueSettingsAvgOrderByAggregateInput = {
    playoffTeams?: SortOrder
    playoffStartWeek?: SortOrder
  }

  export type LeagueSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    scoringType?: SortOrder
    hasDivisions?: SortOrder
    playoffTeams?: SortOrder
    playoffStartWeek?: SortOrder
    canTradeDraftPicks?: SortOrder
    tradeReviewType?: SortOrder
    waiverType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeagueSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    scoringType?: SortOrder
    hasDivisions?: SortOrder
    playoffTeams?: SortOrder
    playoffStartWeek?: SortOrder
    canTradeDraftPicks?: SortOrder
    tradeReviewType?: SortOrder
    waiverType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeagueSettingsSumOrderByAggregateInput = {
    playoffTeams?: SortOrder
    playoffStartWeek?: SortOrder
  }

  export type EnumScoringTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoringType | EnumScoringTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoringType[] | ListEnumScoringTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoringType[] | ListEnumScoringTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoringTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScoringType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScoringTypeFilter<$PrismaModel>
    _max?: NestedEnumScoringTypeFilter<$PrismaModel>
  }

  export type EnumTradeReviewTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeReviewType | EnumTradeReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TradeReviewType[] | ListEnumTradeReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeReviewType[] | ListEnumTradeReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeReviewTypeWithAggregatesFilter<$PrismaModel> | $Enums.TradeReviewType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTradeReviewTypeFilter<$PrismaModel>
    _max?: NestedEnumTradeReviewTypeFilter<$PrismaModel>
  }

  export type EnumWaiverTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WaiverType | EnumWaiverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WaiverType[] | ListEnumWaiverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WaiverType[] | ListEnumWaiverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWaiverTypeWithAggregatesFilter<$PrismaModel> | $Enums.WaiverType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWaiverTypeFilter<$PrismaModel>
    _max?: NestedEnumWaiverTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ScoringSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    passingYards?: SortOrder
    passingTds?: SortOrder
    passingInts?: SortOrder
    rushingYards?: SortOrder
    rushingTds?: SortOrder
    receivingYards?: SortOrder
    receivingTds?: SortOrder
    receptions?: SortOrder
    fumbles?: SortOrder
    fieldGoals?: SortOrder
    extraPoints?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
    fumbleRecoveries?: SortOrder
    safeties?: SortOrder
    defensiveTds?: SortOrder
    pointsAllowed0?: SortOrder
    pointsAllowed1to6?: SortOrder
    pointsAllowed7to13?: SortOrder
    pointsAllowed14to20?: SortOrder
    pointsAllowed21to27?: SortOrder
    pointsAllowed28plus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScoringSettingsAvgOrderByAggregateInput = {
    passingYards?: SortOrder
    passingTds?: SortOrder
    passingInts?: SortOrder
    rushingYards?: SortOrder
    rushingTds?: SortOrder
    receivingYards?: SortOrder
    receivingTds?: SortOrder
    receptions?: SortOrder
    fumbles?: SortOrder
    fieldGoals?: SortOrder
    extraPoints?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
    fumbleRecoveries?: SortOrder
    safeties?: SortOrder
    defensiveTds?: SortOrder
    pointsAllowed0?: SortOrder
    pointsAllowed1to6?: SortOrder
    pointsAllowed7to13?: SortOrder
    pointsAllowed14to20?: SortOrder
    pointsAllowed21to27?: SortOrder
    pointsAllowed28plus?: SortOrder
  }

  export type ScoringSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    passingYards?: SortOrder
    passingTds?: SortOrder
    passingInts?: SortOrder
    rushingYards?: SortOrder
    rushingTds?: SortOrder
    receivingYards?: SortOrder
    receivingTds?: SortOrder
    receptions?: SortOrder
    fumbles?: SortOrder
    fieldGoals?: SortOrder
    extraPoints?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
    fumbleRecoveries?: SortOrder
    safeties?: SortOrder
    defensiveTds?: SortOrder
    pointsAllowed0?: SortOrder
    pointsAllowed1to6?: SortOrder
    pointsAllowed7to13?: SortOrder
    pointsAllowed14to20?: SortOrder
    pointsAllowed21to27?: SortOrder
    pointsAllowed28plus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScoringSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    passingYards?: SortOrder
    passingTds?: SortOrder
    passingInts?: SortOrder
    rushingYards?: SortOrder
    rushingTds?: SortOrder
    receivingYards?: SortOrder
    receivingTds?: SortOrder
    receptions?: SortOrder
    fumbles?: SortOrder
    fieldGoals?: SortOrder
    extraPoints?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
    fumbleRecoveries?: SortOrder
    safeties?: SortOrder
    defensiveTds?: SortOrder
    pointsAllowed0?: SortOrder
    pointsAllowed1to6?: SortOrder
    pointsAllowed7to13?: SortOrder
    pointsAllowed14to20?: SortOrder
    pointsAllowed21to27?: SortOrder
    pointsAllowed28plus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScoringSettingsSumOrderByAggregateInput = {
    passingYards?: SortOrder
    passingTds?: SortOrder
    passingInts?: SortOrder
    rushingYards?: SortOrder
    rushingTds?: SortOrder
    receivingYards?: SortOrder
    receivingTds?: SortOrder
    receptions?: SortOrder
    fumbles?: SortOrder
    fieldGoals?: SortOrder
    extraPoints?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
    fumbleRecoveries?: SortOrder
    safeties?: SortOrder
    defensiveTds?: SortOrder
    pointsAllowed0?: SortOrder
    pointsAllowed1to6?: SortOrder
    pointsAllowed7to13?: SortOrder
    pointsAllowed14to20?: SortOrder
    pointsAllowed21to27?: SortOrder
    pointsAllowed28plus?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type RosterSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    qbSlots?: SortOrder
    rbSlots?: SortOrder
    wrSlots?: SortOrder
    teSlots?: SortOrder
    flexSlots?: SortOrder
    kSlots?: SortOrder
    defSlots?: SortOrder
    benchSlots?: SortOrder
    irSlots?: SortOrder
    maxRosterSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RosterSettingsAvgOrderByAggregateInput = {
    qbSlots?: SortOrder
    rbSlots?: SortOrder
    wrSlots?: SortOrder
    teSlots?: SortOrder
    flexSlots?: SortOrder
    kSlots?: SortOrder
    defSlots?: SortOrder
    benchSlots?: SortOrder
    irSlots?: SortOrder
    maxRosterSize?: SortOrder
  }

  export type RosterSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    qbSlots?: SortOrder
    rbSlots?: SortOrder
    wrSlots?: SortOrder
    teSlots?: SortOrder
    flexSlots?: SortOrder
    kSlots?: SortOrder
    defSlots?: SortOrder
    benchSlots?: SortOrder
    irSlots?: SortOrder
    maxRosterSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RosterSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    qbSlots?: SortOrder
    rbSlots?: SortOrder
    wrSlots?: SortOrder
    teSlots?: SortOrder
    flexSlots?: SortOrder
    kSlots?: SortOrder
    defSlots?: SortOrder
    benchSlots?: SortOrder
    irSlots?: SortOrder
    maxRosterSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RosterSettingsSumOrderByAggregateInput = {
    qbSlots?: SortOrder
    rbSlots?: SortOrder
    wrSlots?: SortOrder
    teSlots?: SortOrder
    flexSlots?: SortOrder
    kSlots?: SortOrder
    defSlots?: SortOrder
    benchSlots?: SortOrder
    irSlots?: SortOrder
    maxRosterSize?: SortOrder
  }

  export type RosterListRelationFilter = {
    every?: RosterWhereInput
    some?: RosterWhereInput
    none?: RosterWhereInput
  }

  export type RosterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamLeagueIdOwnerIdCompoundUniqueInput = {
    leagueId: string
    ownerId: string
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    totalPoints?: SortOrder
    isActive?: SortOrder
    waiverPriority?: SortOrder
    transactionCount?: SortOrder
    paidEntry?: SortOrder
    amountOwed?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    totalPoints?: SortOrder
    waiverPriority?: SortOrder
    transactionCount?: SortOrder
    amountOwed?: SortOrder
    amountPaid?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    totalPoints?: SortOrder
    isActive?: SortOrder
    waiverPriority?: SortOrder
    transactionCount?: SortOrder
    paidEntry?: SortOrder
    amountOwed?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    totalPoints?: SortOrder
    isActive?: SortOrder
    waiverPriority?: SortOrder
    transactionCount?: SortOrder
    paidEntry?: SortOrder
    amountOwed?: SortOrder
    amountPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    wins?: SortOrder
    losses?: SortOrder
    ties?: SortOrder
    totalPoints?: SortOrder
    waiverPriority?: SortOrder
    transactionCount?: SortOrder
    amountOwed?: SortOrder
    amountPaid?: SortOrder
  }

  export type EnumPositionFilter<$PrismaModel = never> = {
    equals?: $Enums.Position | EnumPositionFieldRefInput<$PrismaModel>
    in?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionFilter<$PrismaModel> | $Enums.Position
  }

  export type EnumInjuryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryStatus | EnumInjuryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryStatusFilter<$PrismaModel> | $Enums.InjuryStatus
  }

  export type GameStatsListRelationFilter = {
    every?: GameStatsWhereInput
    some?: GameStatsWhereInput
    none?: GameStatsWhereInput
  }

  export type WeeklyProjectionListRelationFilter = {
    every?: WeeklyProjectionWhereInput
    some?: WeeklyProjectionWhereInput
    none?: WeeklyProjectionWhereInput
  }

  export type TradeOfferPlayerListRelationFilter = {
    every?: TradeOfferPlayerWhereInput
    some?: TradeOfferPlayerWhereInput
    none?: TradeOfferPlayerWhereInput
  }

  export type GameStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeeklyProjectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TradeOfferPlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    position?: SortOrder
    team?: SortOrder
    number?: SortOrder
    byeWeek?: SortOrder
    isActive?: SortOrder
    injuryStatus?: SortOrder
    injuryNote?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerAvgOrderByAggregateInput = {
    number?: SortOrder
    byeWeek?: SortOrder
  }

  export type PlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    position?: SortOrder
    team?: SortOrder
    number?: SortOrder
    byeWeek?: SortOrder
    isActive?: SortOrder
    injuryStatus?: SortOrder
    injuryNote?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    position?: SortOrder
    team?: SortOrder
    number?: SortOrder
    byeWeek?: SortOrder
    isActive?: SortOrder
    injuryStatus?: SortOrder
    injuryNote?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerSumOrderByAggregateInput = {
    number?: SortOrder
    byeWeek?: SortOrder
  }

  export type EnumPositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Position | EnumPositionFieldRefInput<$PrismaModel>
    in?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionWithAggregatesFilter<$PrismaModel> | $Enums.Position
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPositionFilter<$PrismaModel>
    _max?: NestedEnumPositionFilter<$PrismaModel>
  }

  export type EnumInjuryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryStatus | EnumInjuryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InjuryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInjuryStatusFilter<$PrismaModel>
    _max?: NestedEnumInjuryStatusFilter<$PrismaModel>
  }

  export type EnumRosterPositionFilter<$PrismaModel = never> = {
    equals?: $Enums.RosterPosition | EnumRosterPositionFieldRefInput<$PrismaModel>
    in?: $Enums.RosterPosition[] | ListEnumRosterPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.RosterPosition[] | ListEnumRosterPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumRosterPositionFilter<$PrismaModel> | $Enums.RosterPosition
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type PlayerScalarRelationFilter = {
    is?: PlayerWhereInput
    isNot?: PlayerWhereInput
  }

  export type RosterTeamIdPlayerIdCompoundUniqueInput = {
    teamId: string
    playerId: string
  }

  export type RosterCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    position?: SortOrder
    isStarter?: SortOrder
    acquiredDate?: SortOrder
    weekAdded?: SortOrder
  }

  export type RosterAvgOrderByAggregateInput = {
    weekAdded?: SortOrder
  }

  export type RosterMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    position?: SortOrder
    isStarter?: SortOrder
    acquiredDate?: SortOrder
    weekAdded?: SortOrder
  }

  export type RosterMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    position?: SortOrder
    isStarter?: SortOrder
    acquiredDate?: SortOrder
    weekAdded?: SortOrder
  }

  export type RosterSumOrderByAggregateInput = {
    weekAdded?: SortOrder
  }

  export type EnumRosterPositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RosterPosition | EnumRosterPositionFieldRefInput<$PrismaModel>
    in?: $Enums.RosterPosition[] | ListEnumRosterPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.RosterPosition[] | ListEnumRosterPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumRosterPositionWithAggregatesFilter<$PrismaModel> | $Enums.RosterPosition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRosterPositionFilter<$PrismaModel>
    _max?: NestedEnumRosterPositionFilter<$PrismaModel>
  }

  export type DraftCountOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    draftType?: SortOrder
    draftDate?: SortOrder
    isComplete?: SortOrder
    currentRound?: SortOrder
    currentPick?: SortOrder
    timePerPick?: SortOrder
    draftOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DraftAvgOrderByAggregateInput = {
    currentRound?: SortOrder
    currentPick?: SortOrder
    timePerPick?: SortOrder
  }

  export type DraftMaxOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    draftType?: SortOrder
    draftDate?: SortOrder
    isComplete?: SortOrder
    currentRound?: SortOrder
    currentPick?: SortOrder
    timePerPick?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DraftMinOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    draftType?: SortOrder
    draftDate?: SortOrder
    isComplete?: SortOrder
    currentRound?: SortOrder
    currentPick?: SortOrder
    timePerPick?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DraftSumOrderByAggregateInput = {
    currentRound?: SortOrder
    currentPick?: SortOrder
    timePerPick?: SortOrder
  }

  export type DraftScalarRelationFilter = {
    is?: DraftWhereInput
    isNot?: DraftWhereInput
  }

  export type PlayerNullableScalarRelationFilter = {
    is?: PlayerWhereInput | null
    isNot?: PlayerWhereInput | null
  }

  export type DraftPickDraftIdRoundPickInRoundCompoundUniqueInput = {
    draftId: string
    round: number
    pickInRound: number
  }

  export type DraftPickCountOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    playerId?: SortOrder
    round?: SortOrder
    pick?: SortOrder
    pickInRound?: SortOrder
    pickTime?: SortOrder
    isKeeper?: SortOrder
    createdAt?: SortOrder
  }

  export type DraftPickAvgOrderByAggregateInput = {
    round?: SortOrder
    pick?: SortOrder
    pickInRound?: SortOrder
  }

  export type DraftPickMaxOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    playerId?: SortOrder
    round?: SortOrder
    pick?: SortOrder
    pickInRound?: SortOrder
    pickTime?: SortOrder
    isKeeper?: SortOrder
    createdAt?: SortOrder
  }

  export type DraftPickMinOrderByAggregateInput = {
    id?: SortOrder
    draftId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    playerId?: SortOrder
    round?: SortOrder
    pick?: SortOrder
    pickInRound?: SortOrder
    pickTime?: SortOrder
    isKeeper?: SortOrder
    createdAt?: SortOrder
  }

  export type DraftPickSumOrderByAggregateInput = {
    round?: SortOrder
    pick?: SortOrder
    pickInRound?: SortOrder
  }

  export type GameLeagueIdHomeTeamIdAwayTeamIdWeekSeasonCompoundUniqueInput = {
    leagueId: string
    homeTeamId: string
    awayTeamId: string
    week: number
    season: number
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    week?: SortOrder
    season?: SortOrder
    homeScore?: SortOrder
    awayScore?: SortOrder
    isComplete?: SortOrder
    isPlayoffs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAvgOrderByAggregateInput = {
    week?: SortOrder
    season?: SortOrder
    homeScore?: SortOrder
    awayScore?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    week?: SortOrder
    season?: SortOrder
    homeScore?: SortOrder
    awayScore?: SortOrder
    isComplete?: SortOrder
    isPlayoffs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    week?: SortOrder
    season?: SortOrder
    homeScore?: SortOrder
    awayScore?: SortOrder
    isComplete?: SortOrder
    isPlayoffs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameSumOrderByAggregateInput = {
    week?: SortOrder
    season?: SortOrder
    homeScore?: SortOrder
    awayScore?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    playerId?: SortOrder
    transactionType?: SortOrder
    week?: SortOrder
    description?: SortOrder
    isProcessed?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    week?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    playerId?: SortOrder
    transactionType?: SortOrder
    week?: SortOrder
    description?: SortOrder
    isProcessed?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    playerId?: SortOrder
    transactionType?: SortOrder
    week?: SortOrder
    description?: SortOrder
    isProcessed?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    week?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTradeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeStatus | EnumTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeStatusFilter<$PrismaModel> | $Enums.TradeStatus
  }

  export type TradeOfferCountOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    offeringTeamId?: SortOrder
    targetTeamId?: SortOrder
    offererId?: SortOrder
    targetId?: SortOrder
    status?: SortOrder
    note?: SortOrder
    expiresAt?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeOfferMaxOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    offeringTeamId?: SortOrder
    targetTeamId?: SortOrder
    offererId?: SortOrder
    targetId?: SortOrder
    status?: SortOrder
    note?: SortOrder
    expiresAt?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeOfferMinOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    offeringTeamId?: SortOrder
    targetTeamId?: SortOrder
    offererId?: SortOrder
    targetId?: SortOrder
    status?: SortOrder
    note?: SortOrder
    expiresAt?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTradeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeStatus | EnumTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeStatusWithAggregatesFilter<$PrismaModel> | $Enums.TradeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTradeStatusFilter<$PrismaModel>
    _max?: NestedEnumTradeStatusFilter<$PrismaModel>
  }

  export type TradeOfferScalarRelationFilter = {
    is?: TradeOfferWhereInput
    isNot?: TradeOfferWhereInput
  }

  export type TradeOfferPlayerTradeOfferIdPlayerIdCompoundUniqueInput = {
    tradeOfferId: string
    playerId: string
  }

  export type TradeOfferPlayerCountOrderByAggregateInput = {
    id?: SortOrder
    tradeOfferId?: SortOrder
    playerId?: SortOrder
    fromTeam?: SortOrder
  }

  export type TradeOfferPlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    tradeOfferId?: SortOrder
    playerId?: SortOrder
    fromTeam?: SortOrder
  }

  export type TradeOfferPlayerMinOrderByAggregateInput = {
    id?: SortOrder
    tradeOfferId?: SortOrder
    playerId?: SortOrder
    fromTeam?: SortOrder
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type LeagueNullableScalarRelationFilter = {
    is?: LeagueWhereInput | null
    isNot?: LeagueWhereInput | null
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type GameStatsPlayerIdWeekSeasonCompoundUniqueInput = {
    playerId: string
    week: number
    season: number
  }

  export type GameStatsCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    week?: SortOrder
    season?: SortOrder
    passingYards?: SortOrder
    passingTds?: SortOrder
    passingInts?: SortOrder
    passingAttempts?: SortOrder
    rushingYards?: SortOrder
    rushingTds?: SortOrder
    rushingAttempts?: SortOrder
    receptions?: SortOrder
    receivingYards?: SortOrder
    receivingTds?: SortOrder
    targets?: SortOrder
    fumbles?: SortOrder
    fumblesLost?: SortOrder
    fieldGoalsMade?: SortOrder
    fieldGoalsAttempted?: SortOrder
    extraPointsMade?: SortOrder
    extraPointsAttempted?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
    fumbleRecoveries?: SortOrder
    safeties?: SortOrder
    defensiveTds?: SortOrder
    pointsAllowed?: SortOrder
    fantasyPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameStatsAvgOrderByAggregateInput = {
    week?: SortOrder
    season?: SortOrder
    passingYards?: SortOrder
    passingTds?: SortOrder
    passingInts?: SortOrder
    passingAttempts?: SortOrder
    rushingYards?: SortOrder
    rushingTds?: SortOrder
    rushingAttempts?: SortOrder
    receptions?: SortOrder
    receivingYards?: SortOrder
    receivingTds?: SortOrder
    targets?: SortOrder
    fumbles?: SortOrder
    fumblesLost?: SortOrder
    fieldGoalsMade?: SortOrder
    fieldGoalsAttempted?: SortOrder
    extraPointsMade?: SortOrder
    extraPointsAttempted?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
    fumbleRecoveries?: SortOrder
    safeties?: SortOrder
    defensiveTds?: SortOrder
    pointsAllowed?: SortOrder
    fantasyPoints?: SortOrder
  }

  export type GameStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    week?: SortOrder
    season?: SortOrder
    passingYards?: SortOrder
    passingTds?: SortOrder
    passingInts?: SortOrder
    passingAttempts?: SortOrder
    rushingYards?: SortOrder
    rushingTds?: SortOrder
    rushingAttempts?: SortOrder
    receptions?: SortOrder
    receivingYards?: SortOrder
    receivingTds?: SortOrder
    targets?: SortOrder
    fumbles?: SortOrder
    fumblesLost?: SortOrder
    fieldGoalsMade?: SortOrder
    fieldGoalsAttempted?: SortOrder
    extraPointsMade?: SortOrder
    extraPointsAttempted?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
    fumbleRecoveries?: SortOrder
    safeties?: SortOrder
    defensiveTds?: SortOrder
    pointsAllowed?: SortOrder
    fantasyPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameStatsMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    week?: SortOrder
    season?: SortOrder
    passingYards?: SortOrder
    passingTds?: SortOrder
    passingInts?: SortOrder
    passingAttempts?: SortOrder
    rushingYards?: SortOrder
    rushingTds?: SortOrder
    rushingAttempts?: SortOrder
    receptions?: SortOrder
    receivingYards?: SortOrder
    receivingTds?: SortOrder
    targets?: SortOrder
    fumbles?: SortOrder
    fumblesLost?: SortOrder
    fieldGoalsMade?: SortOrder
    fieldGoalsAttempted?: SortOrder
    extraPointsMade?: SortOrder
    extraPointsAttempted?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
    fumbleRecoveries?: SortOrder
    safeties?: SortOrder
    defensiveTds?: SortOrder
    pointsAllowed?: SortOrder
    fantasyPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameStatsSumOrderByAggregateInput = {
    week?: SortOrder
    season?: SortOrder
    passingYards?: SortOrder
    passingTds?: SortOrder
    passingInts?: SortOrder
    passingAttempts?: SortOrder
    rushingYards?: SortOrder
    rushingTds?: SortOrder
    rushingAttempts?: SortOrder
    receptions?: SortOrder
    receivingYards?: SortOrder
    receivingTds?: SortOrder
    targets?: SortOrder
    fumbles?: SortOrder
    fumblesLost?: SortOrder
    fieldGoalsMade?: SortOrder
    fieldGoalsAttempted?: SortOrder
    extraPointsMade?: SortOrder
    extraPointsAttempted?: SortOrder
    sacks?: SortOrder
    interceptions?: SortOrder
    fumbleRecoveries?: SortOrder
    safeties?: SortOrder
    defensiveTds?: SortOrder
    pointsAllowed?: SortOrder
    fantasyPoints?: SortOrder
  }

  export type WeeklyProjectionPlayerIdWeekSeasonCompoundUniqueInput = {
    playerId: string
    week: number
    season: number
  }

  export type WeeklyProjectionCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    week?: SortOrder
    season?: SortOrder
    projectedPoints?: SortOrder
    confidence?: SortOrder
    projPassingYards?: SortOrder
    projPassingTds?: SortOrder
    projRushingYards?: SortOrder
    projRushingTds?: SortOrder
    projReceptions?: SortOrder
    projReceivingYards?: SortOrder
    projReceivingTds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeeklyProjectionAvgOrderByAggregateInput = {
    week?: SortOrder
    season?: SortOrder
    projectedPoints?: SortOrder
    confidence?: SortOrder
    projPassingYards?: SortOrder
    projPassingTds?: SortOrder
    projRushingYards?: SortOrder
    projRushingTds?: SortOrder
    projReceptions?: SortOrder
    projReceivingYards?: SortOrder
    projReceivingTds?: SortOrder
  }

  export type WeeklyProjectionMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    week?: SortOrder
    season?: SortOrder
    projectedPoints?: SortOrder
    confidence?: SortOrder
    projPassingYards?: SortOrder
    projPassingTds?: SortOrder
    projRushingYards?: SortOrder
    projRushingTds?: SortOrder
    projReceptions?: SortOrder
    projReceivingYards?: SortOrder
    projReceivingTds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeeklyProjectionMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    week?: SortOrder
    season?: SortOrder
    projectedPoints?: SortOrder
    confidence?: SortOrder
    projPassingYards?: SortOrder
    projPassingTds?: SortOrder
    projRushingYards?: SortOrder
    projRushingTds?: SortOrder
    projReceptions?: SortOrder
    projReceivingYards?: SortOrder
    projReceivingTds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeeklyProjectionSumOrderByAggregateInput = {
    week?: SortOrder
    season?: SortOrder
    projectedPoints?: SortOrder
    confidence?: SortOrder
    projPassingYards?: SortOrder
    projPassingTds?: SortOrder
    projRushingYards?: SortOrder
    projRushingTds?: SortOrder
    projReceptions?: SortOrder
    projReceivingYards?: SortOrder
    projReceivingTds?: SortOrder
  }

  export type TeamCreateNestedManyWithoutOwnerInput = {
    create?: XOR<TeamCreateWithoutOwnerInput, TeamUncheckedCreateWithoutOwnerInput> | TeamCreateWithoutOwnerInput[] | TeamUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOwnerInput | TeamCreateOrConnectWithoutOwnerInput[]
    createMany?: TeamCreateManyOwnerInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type LeagueCreateNestedManyWithoutCommissionerInput = {
    create?: XOR<LeagueCreateWithoutCommissionerInput, LeagueUncheckedCreateWithoutCommissionerInput> | LeagueCreateWithoutCommissionerInput[] | LeagueUncheckedCreateWithoutCommissionerInput[]
    connectOrCreate?: LeagueCreateOrConnectWithoutCommissionerInput | LeagueCreateOrConnectWithoutCommissionerInput[]
    createMany?: LeagueCreateManyCommissionerInputEnvelope
    connect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type DraftPickCreateNestedManyWithoutUserInput = {
    create?: XOR<DraftPickCreateWithoutUserInput, DraftPickUncheckedCreateWithoutUserInput> | DraftPickCreateWithoutUserInput[] | DraftPickUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutUserInput | DraftPickCreateOrConnectWithoutUserInput[]
    createMany?: DraftPickCreateManyUserInputEnvelope
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
  }

  export type TradeOfferCreateNestedManyWithoutOffererInput = {
    create?: XOR<TradeOfferCreateWithoutOffererInput, TradeOfferUncheckedCreateWithoutOffererInput> | TradeOfferCreateWithoutOffererInput[] | TradeOfferUncheckedCreateWithoutOffererInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutOffererInput | TradeOfferCreateOrConnectWithoutOffererInput[]
    createMany?: TradeOfferCreateManyOffererInputEnvelope
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
  }

  export type TradeOfferCreateNestedManyWithoutTargetInput = {
    create?: XOR<TradeOfferCreateWithoutTargetInput, TradeOfferUncheckedCreateWithoutTargetInput> | TradeOfferCreateWithoutTargetInput[] | TradeOfferUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutTargetInput | TradeOfferCreateOrConnectWithoutTargetInput[]
    createMany?: TradeOfferCreateManyTargetInputEnvelope
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<TeamCreateWithoutOwnerInput, TeamUncheckedCreateWithoutOwnerInput> | TeamCreateWithoutOwnerInput[] | TeamUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOwnerInput | TeamCreateOrConnectWithoutOwnerInput[]
    createMany?: TeamCreateManyOwnerInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type LeagueUncheckedCreateNestedManyWithoutCommissionerInput = {
    create?: XOR<LeagueCreateWithoutCommissionerInput, LeagueUncheckedCreateWithoutCommissionerInput> | LeagueCreateWithoutCommissionerInput[] | LeagueUncheckedCreateWithoutCommissionerInput[]
    connectOrCreate?: LeagueCreateOrConnectWithoutCommissionerInput | LeagueCreateOrConnectWithoutCommissionerInput[]
    createMany?: LeagueCreateManyCommissionerInputEnvelope
    connect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type DraftPickUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DraftPickCreateWithoutUserInput, DraftPickUncheckedCreateWithoutUserInput> | DraftPickCreateWithoutUserInput[] | DraftPickUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutUserInput | DraftPickCreateOrConnectWithoutUserInput[]
    createMany?: DraftPickCreateManyUserInputEnvelope
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
  }

  export type TradeOfferUncheckedCreateNestedManyWithoutOffererInput = {
    create?: XOR<TradeOfferCreateWithoutOffererInput, TradeOfferUncheckedCreateWithoutOffererInput> | TradeOfferCreateWithoutOffererInput[] | TradeOfferUncheckedCreateWithoutOffererInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutOffererInput | TradeOfferCreateOrConnectWithoutOffererInput[]
    createMany?: TradeOfferCreateManyOffererInputEnvelope
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
  }

  export type TradeOfferUncheckedCreateNestedManyWithoutTargetInput = {
    create?: XOR<TradeOfferCreateWithoutTargetInput, TradeOfferUncheckedCreateWithoutTargetInput> | TradeOfferCreateWithoutTargetInput[] | TradeOfferUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutTargetInput | TradeOfferCreateOrConnectWithoutTargetInput[]
    createMany?: TradeOfferCreateManyTargetInputEnvelope
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TeamUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<TeamCreateWithoutOwnerInput, TeamUncheckedCreateWithoutOwnerInput> | TeamCreateWithoutOwnerInput[] | TeamUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOwnerInput | TeamCreateOrConnectWithoutOwnerInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutOwnerInput | TeamUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: TeamCreateManyOwnerInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutOwnerInput | TeamUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutOwnerInput | TeamUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type LeagueUpdateManyWithoutCommissionerNestedInput = {
    create?: XOR<LeagueCreateWithoutCommissionerInput, LeagueUncheckedCreateWithoutCommissionerInput> | LeagueCreateWithoutCommissionerInput[] | LeagueUncheckedCreateWithoutCommissionerInput[]
    connectOrCreate?: LeagueCreateOrConnectWithoutCommissionerInput | LeagueCreateOrConnectWithoutCommissionerInput[]
    upsert?: LeagueUpsertWithWhereUniqueWithoutCommissionerInput | LeagueUpsertWithWhereUniqueWithoutCommissionerInput[]
    createMany?: LeagueCreateManyCommissionerInputEnvelope
    set?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    disconnect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    delete?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    connect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    update?: LeagueUpdateWithWhereUniqueWithoutCommissionerInput | LeagueUpdateWithWhereUniqueWithoutCommissionerInput[]
    updateMany?: LeagueUpdateManyWithWhereWithoutCommissionerInput | LeagueUpdateManyWithWhereWithoutCommissionerInput[]
    deleteMany?: LeagueScalarWhereInput | LeagueScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type DraftPickUpdateManyWithoutUserNestedInput = {
    create?: XOR<DraftPickCreateWithoutUserInput, DraftPickUncheckedCreateWithoutUserInput> | DraftPickCreateWithoutUserInput[] | DraftPickUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutUserInput | DraftPickCreateOrConnectWithoutUserInput[]
    upsert?: DraftPickUpsertWithWhereUniqueWithoutUserInput | DraftPickUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DraftPickCreateManyUserInputEnvelope
    set?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    disconnect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    delete?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    update?: DraftPickUpdateWithWhereUniqueWithoutUserInput | DraftPickUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DraftPickUpdateManyWithWhereWithoutUserInput | DraftPickUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DraftPickScalarWhereInput | DraftPickScalarWhereInput[]
  }

  export type TradeOfferUpdateManyWithoutOffererNestedInput = {
    create?: XOR<TradeOfferCreateWithoutOffererInput, TradeOfferUncheckedCreateWithoutOffererInput> | TradeOfferCreateWithoutOffererInput[] | TradeOfferUncheckedCreateWithoutOffererInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutOffererInput | TradeOfferCreateOrConnectWithoutOffererInput[]
    upsert?: TradeOfferUpsertWithWhereUniqueWithoutOffererInput | TradeOfferUpsertWithWhereUniqueWithoutOffererInput[]
    createMany?: TradeOfferCreateManyOffererInputEnvelope
    set?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    disconnect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    delete?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    update?: TradeOfferUpdateWithWhereUniqueWithoutOffererInput | TradeOfferUpdateWithWhereUniqueWithoutOffererInput[]
    updateMany?: TradeOfferUpdateManyWithWhereWithoutOffererInput | TradeOfferUpdateManyWithWhereWithoutOffererInput[]
    deleteMany?: TradeOfferScalarWhereInput | TradeOfferScalarWhereInput[]
  }

  export type TradeOfferUpdateManyWithoutTargetNestedInput = {
    create?: XOR<TradeOfferCreateWithoutTargetInput, TradeOfferUncheckedCreateWithoutTargetInput> | TradeOfferCreateWithoutTargetInput[] | TradeOfferUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutTargetInput | TradeOfferCreateOrConnectWithoutTargetInput[]
    upsert?: TradeOfferUpsertWithWhereUniqueWithoutTargetInput | TradeOfferUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: TradeOfferCreateManyTargetInputEnvelope
    set?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    disconnect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    delete?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    update?: TradeOfferUpdateWithWhereUniqueWithoutTargetInput | TradeOfferUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: TradeOfferUpdateManyWithWhereWithoutTargetInput | TradeOfferUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: TradeOfferScalarWhereInput | TradeOfferScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<TeamCreateWithoutOwnerInput, TeamUncheckedCreateWithoutOwnerInput> | TeamCreateWithoutOwnerInput[] | TeamUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOwnerInput | TeamCreateOrConnectWithoutOwnerInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutOwnerInput | TeamUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: TeamCreateManyOwnerInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutOwnerInput | TeamUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutOwnerInput | TeamUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type LeagueUncheckedUpdateManyWithoutCommissionerNestedInput = {
    create?: XOR<LeagueCreateWithoutCommissionerInput, LeagueUncheckedCreateWithoutCommissionerInput> | LeagueCreateWithoutCommissionerInput[] | LeagueUncheckedCreateWithoutCommissionerInput[]
    connectOrCreate?: LeagueCreateOrConnectWithoutCommissionerInput | LeagueCreateOrConnectWithoutCommissionerInput[]
    upsert?: LeagueUpsertWithWhereUniqueWithoutCommissionerInput | LeagueUpsertWithWhereUniqueWithoutCommissionerInput[]
    createMany?: LeagueCreateManyCommissionerInputEnvelope
    set?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    disconnect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    delete?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    connect?: LeagueWhereUniqueInput | LeagueWhereUniqueInput[]
    update?: LeagueUpdateWithWhereUniqueWithoutCommissionerInput | LeagueUpdateWithWhereUniqueWithoutCommissionerInput[]
    updateMany?: LeagueUpdateManyWithWhereWithoutCommissionerInput | LeagueUpdateManyWithWhereWithoutCommissionerInput[]
    deleteMany?: LeagueScalarWhereInput | LeagueScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type DraftPickUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DraftPickCreateWithoutUserInput, DraftPickUncheckedCreateWithoutUserInput> | DraftPickCreateWithoutUserInput[] | DraftPickUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutUserInput | DraftPickCreateOrConnectWithoutUserInput[]
    upsert?: DraftPickUpsertWithWhereUniqueWithoutUserInput | DraftPickUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DraftPickCreateManyUserInputEnvelope
    set?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    disconnect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    delete?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    update?: DraftPickUpdateWithWhereUniqueWithoutUserInput | DraftPickUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DraftPickUpdateManyWithWhereWithoutUserInput | DraftPickUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DraftPickScalarWhereInput | DraftPickScalarWhereInput[]
  }

  export type TradeOfferUncheckedUpdateManyWithoutOffererNestedInput = {
    create?: XOR<TradeOfferCreateWithoutOffererInput, TradeOfferUncheckedCreateWithoutOffererInput> | TradeOfferCreateWithoutOffererInput[] | TradeOfferUncheckedCreateWithoutOffererInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutOffererInput | TradeOfferCreateOrConnectWithoutOffererInput[]
    upsert?: TradeOfferUpsertWithWhereUniqueWithoutOffererInput | TradeOfferUpsertWithWhereUniqueWithoutOffererInput[]
    createMany?: TradeOfferCreateManyOffererInputEnvelope
    set?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    disconnect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    delete?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    update?: TradeOfferUpdateWithWhereUniqueWithoutOffererInput | TradeOfferUpdateWithWhereUniqueWithoutOffererInput[]
    updateMany?: TradeOfferUpdateManyWithWhereWithoutOffererInput | TradeOfferUpdateManyWithWhereWithoutOffererInput[]
    deleteMany?: TradeOfferScalarWhereInput | TradeOfferScalarWhereInput[]
  }

  export type TradeOfferUncheckedUpdateManyWithoutTargetNestedInput = {
    create?: XOR<TradeOfferCreateWithoutTargetInput, TradeOfferUncheckedCreateWithoutTargetInput> | TradeOfferCreateWithoutTargetInput[] | TradeOfferUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutTargetInput | TradeOfferCreateOrConnectWithoutTargetInput[]
    upsert?: TradeOfferUpsertWithWhereUniqueWithoutTargetInput | TradeOfferUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: TradeOfferCreateManyTargetInputEnvelope
    set?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    disconnect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    delete?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    update?: TradeOfferUpdateWithWhereUniqueWithoutTargetInput | TradeOfferUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: TradeOfferUpdateManyWithWhereWithoutTargetInput | TradeOfferUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: TradeOfferScalarWhereInput | TradeOfferScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLeaguesCommissionedInput = {
    create?: XOR<UserCreateWithoutLeaguesCommissionedInput, UserUncheckedCreateWithoutLeaguesCommissionedInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaguesCommissionedInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedManyWithoutLeagueInput = {
    create?: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput> | TeamCreateWithoutLeagueInput[] | TeamUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeagueInput | TeamCreateOrConnectWithoutLeagueInput[]
    createMany?: TeamCreateManyLeagueInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type LeagueSettingsCreateNestedOneWithoutLeagueInput = {
    create?: XOR<LeagueSettingsCreateWithoutLeagueInput, LeagueSettingsUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: LeagueSettingsCreateOrConnectWithoutLeagueInput
    connect?: LeagueSettingsWhereUniqueInput
  }

  export type ScoringSettingsCreateNestedOneWithoutLeagueInput = {
    create?: XOR<ScoringSettingsCreateWithoutLeagueInput, ScoringSettingsUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: ScoringSettingsCreateOrConnectWithoutLeagueInput
    connect?: ScoringSettingsWhereUniqueInput
  }

  export type RosterSettingsCreateNestedOneWithoutLeagueInput = {
    create?: XOR<RosterSettingsCreateWithoutLeagueInput, RosterSettingsUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: RosterSettingsCreateOrConnectWithoutLeagueInput
    connect?: RosterSettingsWhereUniqueInput
  }

  export type DraftCreateNestedOneWithoutLeagueInput = {
    create?: XOR<DraftCreateWithoutLeagueInput, DraftUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: DraftCreateOrConnectWithoutLeagueInput
    connect?: DraftWhereUniqueInput
  }

  export type GameCreateNestedManyWithoutLeagueInput = {
    create?: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput> | GameCreateWithoutLeagueInput[] | GameUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: GameCreateOrConnectWithoutLeagueInput | GameCreateOrConnectWithoutLeagueInput[]
    createMany?: GameCreateManyLeagueInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutLeagueInput = {
    create?: XOR<TransactionCreateWithoutLeagueInput, TransactionUncheckedCreateWithoutLeagueInput> | TransactionCreateWithoutLeagueInput[] | TransactionUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutLeagueInput | TransactionCreateOrConnectWithoutLeagueInput[]
    createMany?: TransactionCreateManyLeagueInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutLeagueInput = {
    create?: XOR<MessageCreateWithoutLeagueInput, MessageUncheckedCreateWithoutLeagueInput> | MessageCreateWithoutLeagueInput[] | MessageUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutLeagueInput | MessageCreateOrConnectWithoutLeagueInput[]
    createMany?: MessageCreateManyLeagueInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TradeOfferCreateNestedManyWithoutLeagueInput = {
    create?: XOR<TradeOfferCreateWithoutLeagueInput, TradeOfferUncheckedCreateWithoutLeagueInput> | TradeOfferCreateWithoutLeagueInput[] | TradeOfferUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutLeagueInput | TradeOfferCreateOrConnectWithoutLeagueInput[]
    createMany?: TradeOfferCreateManyLeagueInputEnvelope
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutLeagueInput = {
    create?: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput> | TeamCreateWithoutLeagueInput[] | TeamUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeagueInput | TeamCreateOrConnectWithoutLeagueInput[]
    createMany?: TeamCreateManyLeagueInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type LeagueSettingsUncheckedCreateNestedOneWithoutLeagueInput = {
    create?: XOR<LeagueSettingsCreateWithoutLeagueInput, LeagueSettingsUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: LeagueSettingsCreateOrConnectWithoutLeagueInput
    connect?: LeagueSettingsWhereUniqueInput
  }

  export type ScoringSettingsUncheckedCreateNestedOneWithoutLeagueInput = {
    create?: XOR<ScoringSettingsCreateWithoutLeagueInput, ScoringSettingsUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: ScoringSettingsCreateOrConnectWithoutLeagueInput
    connect?: ScoringSettingsWhereUniqueInput
  }

  export type RosterSettingsUncheckedCreateNestedOneWithoutLeagueInput = {
    create?: XOR<RosterSettingsCreateWithoutLeagueInput, RosterSettingsUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: RosterSettingsCreateOrConnectWithoutLeagueInput
    connect?: RosterSettingsWhereUniqueInput
  }

  export type DraftUncheckedCreateNestedOneWithoutLeagueInput = {
    create?: XOR<DraftCreateWithoutLeagueInput, DraftUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: DraftCreateOrConnectWithoutLeagueInput
    connect?: DraftWhereUniqueInput
  }

  export type GameUncheckedCreateNestedManyWithoutLeagueInput = {
    create?: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput> | GameCreateWithoutLeagueInput[] | GameUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: GameCreateOrConnectWithoutLeagueInput | GameCreateOrConnectWithoutLeagueInput[]
    createMany?: GameCreateManyLeagueInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutLeagueInput = {
    create?: XOR<TransactionCreateWithoutLeagueInput, TransactionUncheckedCreateWithoutLeagueInput> | TransactionCreateWithoutLeagueInput[] | TransactionUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutLeagueInput | TransactionCreateOrConnectWithoutLeagueInput[]
    createMany?: TransactionCreateManyLeagueInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutLeagueInput = {
    create?: XOR<MessageCreateWithoutLeagueInput, MessageUncheckedCreateWithoutLeagueInput> | MessageCreateWithoutLeagueInput[] | MessageUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutLeagueInput | MessageCreateOrConnectWithoutLeagueInput[]
    createMany?: MessageCreateManyLeagueInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TradeOfferUncheckedCreateNestedManyWithoutLeagueInput = {
    create?: XOR<TradeOfferCreateWithoutLeagueInput, TradeOfferUncheckedCreateWithoutLeagueInput> | TradeOfferCreateWithoutLeagueInput[] | TradeOfferUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutLeagueInput | TradeOfferCreateOrConnectWithoutLeagueInput[]
    createMany?: TradeOfferCreateManyLeagueInputEnvelope
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumDraftTypeFieldUpdateOperationsInput = {
    set?: $Enums.DraftType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutLeaguesCommissionedNestedInput = {
    create?: XOR<UserCreateWithoutLeaguesCommissionedInput, UserUncheckedCreateWithoutLeaguesCommissionedInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaguesCommissionedInput
    upsert?: UserUpsertWithoutLeaguesCommissionedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaguesCommissionedInput, UserUpdateWithoutLeaguesCommissionedInput>, UserUncheckedUpdateWithoutLeaguesCommissionedInput>
  }

  export type TeamUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput> | TeamCreateWithoutLeagueInput[] | TeamUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeagueInput | TeamCreateOrConnectWithoutLeagueInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutLeagueInput | TeamUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: TeamCreateManyLeagueInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutLeagueInput | TeamUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutLeagueInput | TeamUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type LeagueSettingsUpdateOneWithoutLeagueNestedInput = {
    create?: XOR<LeagueSettingsCreateWithoutLeagueInput, LeagueSettingsUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: LeagueSettingsCreateOrConnectWithoutLeagueInput
    upsert?: LeagueSettingsUpsertWithoutLeagueInput
    disconnect?: LeagueSettingsWhereInput | boolean
    delete?: LeagueSettingsWhereInput | boolean
    connect?: LeagueSettingsWhereUniqueInput
    update?: XOR<XOR<LeagueSettingsUpdateToOneWithWhereWithoutLeagueInput, LeagueSettingsUpdateWithoutLeagueInput>, LeagueSettingsUncheckedUpdateWithoutLeagueInput>
  }

  export type ScoringSettingsUpdateOneWithoutLeagueNestedInput = {
    create?: XOR<ScoringSettingsCreateWithoutLeagueInput, ScoringSettingsUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: ScoringSettingsCreateOrConnectWithoutLeagueInput
    upsert?: ScoringSettingsUpsertWithoutLeagueInput
    disconnect?: ScoringSettingsWhereInput | boolean
    delete?: ScoringSettingsWhereInput | boolean
    connect?: ScoringSettingsWhereUniqueInput
    update?: XOR<XOR<ScoringSettingsUpdateToOneWithWhereWithoutLeagueInput, ScoringSettingsUpdateWithoutLeagueInput>, ScoringSettingsUncheckedUpdateWithoutLeagueInput>
  }

  export type RosterSettingsUpdateOneWithoutLeagueNestedInput = {
    create?: XOR<RosterSettingsCreateWithoutLeagueInput, RosterSettingsUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: RosterSettingsCreateOrConnectWithoutLeagueInput
    upsert?: RosterSettingsUpsertWithoutLeagueInput
    disconnect?: RosterSettingsWhereInput | boolean
    delete?: RosterSettingsWhereInput | boolean
    connect?: RosterSettingsWhereUniqueInput
    update?: XOR<XOR<RosterSettingsUpdateToOneWithWhereWithoutLeagueInput, RosterSettingsUpdateWithoutLeagueInput>, RosterSettingsUncheckedUpdateWithoutLeagueInput>
  }

  export type DraftUpdateOneWithoutLeagueNestedInput = {
    create?: XOR<DraftCreateWithoutLeagueInput, DraftUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: DraftCreateOrConnectWithoutLeagueInput
    upsert?: DraftUpsertWithoutLeagueInput
    disconnect?: DraftWhereInput | boolean
    delete?: DraftWhereInput | boolean
    connect?: DraftWhereUniqueInput
    update?: XOR<XOR<DraftUpdateToOneWithWhereWithoutLeagueInput, DraftUpdateWithoutLeagueInput>, DraftUncheckedUpdateWithoutLeagueInput>
  }

  export type GameUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput> | GameCreateWithoutLeagueInput[] | GameUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: GameCreateOrConnectWithoutLeagueInput | GameCreateOrConnectWithoutLeagueInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutLeagueInput | GameUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: GameCreateManyLeagueInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutLeagueInput | GameUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: GameUpdateManyWithWhereWithoutLeagueInput | GameUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<TransactionCreateWithoutLeagueInput, TransactionUncheckedCreateWithoutLeagueInput> | TransactionCreateWithoutLeagueInput[] | TransactionUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutLeagueInput | TransactionCreateOrConnectWithoutLeagueInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutLeagueInput | TransactionUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: TransactionCreateManyLeagueInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutLeagueInput | TransactionUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutLeagueInput | TransactionUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<MessageCreateWithoutLeagueInput, MessageUncheckedCreateWithoutLeagueInput> | MessageCreateWithoutLeagueInput[] | MessageUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutLeagueInput | MessageCreateOrConnectWithoutLeagueInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutLeagueInput | MessageUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: MessageCreateManyLeagueInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutLeagueInput | MessageUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutLeagueInput | MessageUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TradeOfferUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<TradeOfferCreateWithoutLeagueInput, TradeOfferUncheckedCreateWithoutLeagueInput> | TradeOfferCreateWithoutLeagueInput[] | TradeOfferUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutLeagueInput | TradeOfferCreateOrConnectWithoutLeagueInput[]
    upsert?: TradeOfferUpsertWithWhereUniqueWithoutLeagueInput | TradeOfferUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: TradeOfferCreateManyLeagueInputEnvelope
    set?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    disconnect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    delete?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    update?: TradeOfferUpdateWithWhereUniqueWithoutLeagueInput | TradeOfferUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: TradeOfferUpdateManyWithWhereWithoutLeagueInput | TradeOfferUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: TradeOfferScalarWhereInput | TradeOfferScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput> | TeamCreateWithoutLeagueInput[] | TeamUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeagueInput | TeamCreateOrConnectWithoutLeagueInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutLeagueInput | TeamUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: TeamCreateManyLeagueInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutLeagueInput | TeamUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutLeagueInput | TeamUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type LeagueSettingsUncheckedUpdateOneWithoutLeagueNestedInput = {
    create?: XOR<LeagueSettingsCreateWithoutLeagueInput, LeagueSettingsUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: LeagueSettingsCreateOrConnectWithoutLeagueInput
    upsert?: LeagueSettingsUpsertWithoutLeagueInput
    disconnect?: LeagueSettingsWhereInput | boolean
    delete?: LeagueSettingsWhereInput | boolean
    connect?: LeagueSettingsWhereUniqueInput
    update?: XOR<XOR<LeagueSettingsUpdateToOneWithWhereWithoutLeagueInput, LeagueSettingsUpdateWithoutLeagueInput>, LeagueSettingsUncheckedUpdateWithoutLeagueInput>
  }

  export type ScoringSettingsUncheckedUpdateOneWithoutLeagueNestedInput = {
    create?: XOR<ScoringSettingsCreateWithoutLeagueInput, ScoringSettingsUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: ScoringSettingsCreateOrConnectWithoutLeagueInput
    upsert?: ScoringSettingsUpsertWithoutLeagueInput
    disconnect?: ScoringSettingsWhereInput | boolean
    delete?: ScoringSettingsWhereInput | boolean
    connect?: ScoringSettingsWhereUniqueInput
    update?: XOR<XOR<ScoringSettingsUpdateToOneWithWhereWithoutLeagueInput, ScoringSettingsUpdateWithoutLeagueInput>, ScoringSettingsUncheckedUpdateWithoutLeagueInput>
  }

  export type RosterSettingsUncheckedUpdateOneWithoutLeagueNestedInput = {
    create?: XOR<RosterSettingsCreateWithoutLeagueInput, RosterSettingsUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: RosterSettingsCreateOrConnectWithoutLeagueInput
    upsert?: RosterSettingsUpsertWithoutLeagueInput
    disconnect?: RosterSettingsWhereInput | boolean
    delete?: RosterSettingsWhereInput | boolean
    connect?: RosterSettingsWhereUniqueInput
    update?: XOR<XOR<RosterSettingsUpdateToOneWithWhereWithoutLeagueInput, RosterSettingsUpdateWithoutLeagueInput>, RosterSettingsUncheckedUpdateWithoutLeagueInput>
  }

  export type DraftUncheckedUpdateOneWithoutLeagueNestedInput = {
    create?: XOR<DraftCreateWithoutLeagueInput, DraftUncheckedCreateWithoutLeagueInput>
    connectOrCreate?: DraftCreateOrConnectWithoutLeagueInput
    upsert?: DraftUpsertWithoutLeagueInput
    disconnect?: DraftWhereInput | boolean
    delete?: DraftWhereInput | boolean
    connect?: DraftWhereUniqueInput
    update?: XOR<XOR<DraftUpdateToOneWithWhereWithoutLeagueInput, DraftUpdateWithoutLeagueInput>, DraftUncheckedUpdateWithoutLeagueInput>
  }

  export type GameUncheckedUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput> | GameCreateWithoutLeagueInput[] | GameUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: GameCreateOrConnectWithoutLeagueInput | GameCreateOrConnectWithoutLeagueInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutLeagueInput | GameUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: GameCreateManyLeagueInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutLeagueInput | GameUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: GameUpdateManyWithWhereWithoutLeagueInput | GameUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<TransactionCreateWithoutLeagueInput, TransactionUncheckedCreateWithoutLeagueInput> | TransactionCreateWithoutLeagueInput[] | TransactionUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutLeagueInput | TransactionCreateOrConnectWithoutLeagueInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutLeagueInput | TransactionUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: TransactionCreateManyLeagueInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutLeagueInput | TransactionUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutLeagueInput | TransactionUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<MessageCreateWithoutLeagueInput, MessageUncheckedCreateWithoutLeagueInput> | MessageCreateWithoutLeagueInput[] | MessageUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutLeagueInput | MessageCreateOrConnectWithoutLeagueInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutLeagueInput | MessageUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: MessageCreateManyLeagueInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutLeagueInput | MessageUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutLeagueInput | MessageUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TradeOfferUncheckedUpdateManyWithoutLeagueNestedInput = {
    create?: XOR<TradeOfferCreateWithoutLeagueInput, TradeOfferUncheckedCreateWithoutLeagueInput> | TradeOfferCreateWithoutLeagueInput[] | TradeOfferUncheckedCreateWithoutLeagueInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutLeagueInput | TradeOfferCreateOrConnectWithoutLeagueInput[]
    upsert?: TradeOfferUpsertWithWhereUniqueWithoutLeagueInput | TradeOfferUpsertWithWhereUniqueWithoutLeagueInput[]
    createMany?: TradeOfferCreateManyLeagueInputEnvelope
    set?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    disconnect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    delete?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    update?: TradeOfferUpdateWithWhereUniqueWithoutLeagueInput | TradeOfferUpdateWithWhereUniqueWithoutLeagueInput[]
    updateMany?: TradeOfferUpdateManyWithWhereWithoutLeagueInput | TradeOfferUpdateManyWithWhereWithoutLeagueInput[]
    deleteMany?: TradeOfferScalarWhereInput | TradeOfferScalarWhereInput[]
  }

  export type LeagueCreateNestedOneWithoutLeagueSettingsInput = {
    create?: XOR<LeagueCreateWithoutLeagueSettingsInput, LeagueUncheckedCreateWithoutLeagueSettingsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutLeagueSettingsInput
    connect?: LeagueWhereUniqueInput
  }

  export type EnumScoringTypeFieldUpdateOperationsInput = {
    set?: $Enums.ScoringType
  }

  export type EnumTradeReviewTypeFieldUpdateOperationsInput = {
    set?: $Enums.TradeReviewType
  }

  export type EnumWaiverTypeFieldUpdateOperationsInput = {
    set?: $Enums.WaiverType
  }

  export type LeagueUpdateOneRequiredWithoutLeagueSettingsNestedInput = {
    create?: XOR<LeagueCreateWithoutLeagueSettingsInput, LeagueUncheckedCreateWithoutLeagueSettingsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutLeagueSettingsInput
    upsert?: LeagueUpsertWithoutLeagueSettingsInput
    connect?: LeagueWhereUniqueInput
    update?: XOR<XOR<LeagueUpdateToOneWithWhereWithoutLeagueSettingsInput, LeagueUpdateWithoutLeagueSettingsInput>, LeagueUncheckedUpdateWithoutLeagueSettingsInput>
  }

  export type LeagueCreateNestedOneWithoutScoringSettingsInput = {
    create?: XOR<LeagueCreateWithoutScoringSettingsInput, LeagueUncheckedCreateWithoutScoringSettingsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutScoringSettingsInput
    connect?: LeagueWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type LeagueUpdateOneRequiredWithoutScoringSettingsNestedInput = {
    create?: XOR<LeagueCreateWithoutScoringSettingsInput, LeagueUncheckedCreateWithoutScoringSettingsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutScoringSettingsInput
    upsert?: LeagueUpsertWithoutScoringSettingsInput
    connect?: LeagueWhereUniqueInput
    update?: XOR<XOR<LeagueUpdateToOneWithWhereWithoutScoringSettingsInput, LeagueUpdateWithoutScoringSettingsInput>, LeagueUncheckedUpdateWithoutScoringSettingsInput>
  }

  export type LeagueCreateNestedOneWithoutRosterSettingsInput = {
    create?: XOR<LeagueCreateWithoutRosterSettingsInput, LeagueUncheckedCreateWithoutRosterSettingsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutRosterSettingsInput
    connect?: LeagueWhereUniqueInput
  }

  export type LeagueUpdateOneRequiredWithoutRosterSettingsNestedInput = {
    create?: XOR<LeagueCreateWithoutRosterSettingsInput, LeagueUncheckedCreateWithoutRosterSettingsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutRosterSettingsInput
    upsert?: LeagueUpsertWithoutRosterSettingsInput
    connect?: LeagueWhereUniqueInput
    update?: XOR<XOR<LeagueUpdateToOneWithWhereWithoutRosterSettingsInput, LeagueUpdateWithoutRosterSettingsInput>, LeagueUncheckedUpdateWithoutRosterSettingsInput>
  }

  export type LeagueCreateNestedOneWithoutTeamsInput = {
    create?: XOR<LeagueCreateWithoutTeamsInput, LeagueUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutTeamsInput
    connect?: LeagueWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamsOwnedInput = {
    create?: XOR<UserCreateWithoutTeamsOwnedInput, UserUncheckedCreateWithoutTeamsOwnedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsOwnedInput
    connect?: UserWhereUniqueInput
  }

  export type RosterCreateNestedManyWithoutTeamInput = {
    create?: XOR<RosterCreateWithoutTeamInput, RosterUncheckedCreateWithoutTeamInput> | RosterCreateWithoutTeamInput[] | RosterUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: RosterCreateOrConnectWithoutTeamInput | RosterCreateOrConnectWithoutTeamInput[]
    createMany?: RosterCreateManyTeamInputEnvelope
    connect?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
  }

  export type DraftPickCreateNestedManyWithoutTeamInput = {
    create?: XOR<DraftPickCreateWithoutTeamInput, DraftPickUncheckedCreateWithoutTeamInput> | DraftPickCreateWithoutTeamInput[] | DraftPickUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutTeamInput | DraftPickCreateOrConnectWithoutTeamInput[]
    createMany?: DraftPickCreateManyTeamInputEnvelope
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
  }

  export type GameCreateNestedManyWithoutHomeTeamInput = {
    create?: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput> | GameCreateWithoutHomeTeamInput[] | GameUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutHomeTeamInput | GameCreateOrConnectWithoutHomeTeamInput[]
    createMany?: GameCreateManyHomeTeamInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameCreateNestedManyWithoutAwayTeamInput = {
    create?: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput> | GameCreateWithoutAwayTeamInput[] | GameUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutAwayTeamInput | GameCreateOrConnectWithoutAwayTeamInput[]
    createMany?: GameCreateManyAwayTeamInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutTeamInput = {
    create?: XOR<TransactionCreateWithoutTeamInput, TransactionUncheckedCreateWithoutTeamInput> | TransactionCreateWithoutTeamInput[] | TransactionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTeamInput | TransactionCreateOrConnectWithoutTeamInput[]
    createMany?: TransactionCreateManyTeamInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TradeOfferCreateNestedManyWithoutOfferingTeamInput = {
    create?: XOR<TradeOfferCreateWithoutOfferingTeamInput, TradeOfferUncheckedCreateWithoutOfferingTeamInput> | TradeOfferCreateWithoutOfferingTeamInput[] | TradeOfferUncheckedCreateWithoutOfferingTeamInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutOfferingTeamInput | TradeOfferCreateOrConnectWithoutOfferingTeamInput[]
    createMany?: TradeOfferCreateManyOfferingTeamInputEnvelope
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
  }

  export type TradeOfferCreateNestedManyWithoutTargetTeamInput = {
    create?: XOR<TradeOfferCreateWithoutTargetTeamInput, TradeOfferUncheckedCreateWithoutTargetTeamInput> | TradeOfferCreateWithoutTargetTeamInput[] | TradeOfferUncheckedCreateWithoutTargetTeamInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutTargetTeamInput | TradeOfferCreateOrConnectWithoutTargetTeamInput[]
    createMany?: TradeOfferCreateManyTargetTeamInputEnvelope
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
  }

  export type RosterUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<RosterCreateWithoutTeamInput, RosterUncheckedCreateWithoutTeamInput> | RosterCreateWithoutTeamInput[] | RosterUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: RosterCreateOrConnectWithoutTeamInput | RosterCreateOrConnectWithoutTeamInput[]
    createMany?: RosterCreateManyTeamInputEnvelope
    connect?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
  }

  export type DraftPickUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<DraftPickCreateWithoutTeamInput, DraftPickUncheckedCreateWithoutTeamInput> | DraftPickCreateWithoutTeamInput[] | DraftPickUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutTeamInput | DraftPickCreateOrConnectWithoutTeamInput[]
    createMany?: DraftPickCreateManyTeamInputEnvelope
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutHomeTeamInput = {
    create?: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput> | GameCreateWithoutHomeTeamInput[] | GameUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutHomeTeamInput | GameCreateOrConnectWithoutHomeTeamInput[]
    createMany?: GameCreateManyHomeTeamInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutAwayTeamInput = {
    create?: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput> | GameCreateWithoutAwayTeamInput[] | GameUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutAwayTeamInput | GameCreateOrConnectWithoutAwayTeamInput[]
    createMany?: GameCreateManyAwayTeamInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TransactionCreateWithoutTeamInput, TransactionUncheckedCreateWithoutTeamInput> | TransactionCreateWithoutTeamInput[] | TransactionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTeamInput | TransactionCreateOrConnectWithoutTeamInput[]
    createMany?: TransactionCreateManyTeamInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TradeOfferUncheckedCreateNestedManyWithoutOfferingTeamInput = {
    create?: XOR<TradeOfferCreateWithoutOfferingTeamInput, TradeOfferUncheckedCreateWithoutOfferingTeamInput> | TradeOfferCreateWithoutOfferingTeamInput[] | TradeOfferUncheckedCreateWithoutOfferingTeamInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutOfferingTeamInput | TradeOfferCreateOrConnectWithoutOfferingTeamInput[]
    createMany?: TradeOfferCreateManyOfferingTeamInputEnvelope
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
  }

  export type TradeOfferUncheckedCreateNestedManyWithoutTargetTeamInput = {
    create?: XOR<TradeOfferCreateWithoutTargetTeamInput, TradeOfferUncheckedCreateWithoutTargetTeamInput> | TradeOfferCreateWithoutTargetTeamInput[] | TradeOfferUncheckedCreateWithoutTargetTeamInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutTargetTeamInput | TradeOfferCreateOrConnectWithoutTargetTeamInput[]
    createMany?: TradeOfferCreateManyTargetTeamInputEnvelope
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
  }

  export type LeagueUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<LeagueCreateWithoutTeamsInput, LeagueUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutTeamsInput
    upsert?: LeagueUpsertWithoutTeamsInput
    connect?: LeagueWhereUniqueInput
    update?: XOR<XOR<LeagueUpdateToOneWithWhereWithoutTeamsInput, LeagueUpdateWithoutTeamsInput>, LeagueUncheckedUpdateWithoutTeamsInput>
  }

  export type UserUpdateOneRequiredWithoutTeamsOwnedNestedInput = {
    create?: XOR<UserCreateWithoutTeamsOwnedInput, UserUncheckedCreateWithoutTeamsOwnedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsOwnedInput
    upsert?: UserUpsertWithoutTeamsOwnedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamsOwnedInput, UserUpdateWithoutTeamsOwnedInput>, UserUncheckedUpdateWithoutTeamsOwnedInput>
  }

  export type RosterUpdateManyWithoutTeamNestedInput = {
    create?: XOR<RosterCreateWithoutTeamInput, RosterUncheckedCreateWithoutTeamInput> | RosterCreateWithoutTeamInput[] | RosterUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: RosterCreateOrConnectWithoutTeamInput | RosterCreateOrConnectWithoutTeamInput[]
    upsert?: RosterUpsertWithWhereUniqueWithoutTeamInput | RosterUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: RosterCreateManyTeamInputEnvelope
    set?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    disconnect?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    delete?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    connect?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    update?: RosterUpdateWithWhereUniqueWithoutTeamInput | RosterUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: RosterUpdateManyWithWhereWithoutTeamInput | RosterUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: RosterScalarWhereInput | RosterScalarWhereInput[]
  }

  export type DraftPickUpdateManyWithoutTeamNestedInput = {
    create?: XOR<DraftPickCreateWithoutTeamInput, DraftPickUncheckedCreateWithoutTeamInput> | DraftPickCreateWithoutTeamInput[] | DraftPickUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutTeamInput | DraftPickCreateOrConnectWithoutTeamInput[]
    upsert?: DraftPickUpsertWithWhereUniqueWithoutTeamInput | DraftPickUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: DraftPickCreateManyTeamInputEnvelope
    set?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    disconnect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    delete?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    update?: DraftPickUpdateWithWhereUniqueWithoutTeamInput | DraftPickUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: DraftPickUpdateManyWithWhereWithoutTeamInput | DraftPickUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: DraftPickScalarWhereInput | DraftPickScalarWhereInput[]
  }

  export type GameUpdateManyWithoutHomeTeamNestedInput = {
    create?: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput> | GameCreateWithoutHomeTeamInput[] | GameUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutHomeTeamInput | GameCreateOrConnectWithoutHomeTeamInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutHomeTeamInput | GameUpsertWithWhereUniqueWithoutHomeTeamInput[]
    createMany?: GameCreateManyHomeTeamInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutHomeTeamInput | GameUpdateWithWhereUniqueWithoutHomeTeamInput[]
    updateMany?: GameUpdateManyWithWhereWithoutHomeTeamInput | GameUpdateManyWithWhereWithoutHomeTeamInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameUpdateManyWithoutAwayTeamNestedInput = {
    create?: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput> | GameCreateWithoutAwayTeamInput[] | GameUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutAwayTeamInput | GameCreateOrConnectWithoutAwayTeamInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutAwayTeamInput | GameUpsertWithWhereUniqueWithoutAwayTeamInput[]
    createMany?: GameCreateManyAwayTeamInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutAwayTeamInput | GameUpdateWithWhereUniqueWithoutAwayTeamInput[]
    updateMany?: GameUpdateManyWithWhereWithoutAwayTeamInput | GameUpdateManyWithWhereWithoutAwayTeamInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TransactionCreateWithoutTeamInput, TransactionUncheckedCreateWithoutTeamInput> | TransactionCreateWithoutTeamInput[] | TransactionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTeamInput | TransactionCreateOrConnectWithoutTeamInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTeamInput | TransactionUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TransactionCreateManyTeamInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTeamInput | TransactionUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTeamInput | TransactionUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TradeOfferUpdateManyWithoutOfferingTeamNestedInput = {
    create?: XOR<TradeOfferCreateWithoutOfferingTeamInput, TradeOfferUncheckedCreateWithoutOfferingTeamInput> | TradeOfferCreateWithoutOfferingTeamInput[] | TradeOfferUncheckedCreateWithoutOfferingTeamInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutOfferingTeamInput | TradeOfferCreateOrConnectWithoutOfferingTeamInput[]
    upsert?: TradeOfferUpsertWithWhereUniqueWithoutOfferingTeamInput | TradeOfferUpsertWithWhereUniqueWithoutOfferingTeamInput[]
    createMany?: TradeOfferCreateManyOfferingTeamInputEnvelope
    set?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    disconnect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    delete?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    update?: TradeOfferUpdateWithWhereUniqueWithoutOfferingTeamInput | TradeOfferUpdateWithWhereUniqueWithoutOfferingTeamInput[]
    updateMany?: TradeOfferUpdateManyWithWhereWithoutOfferingTeamInput | TradeOfferUpdateManyWithWhereWithoutOfferingTeamInput[]
    deleteMany?: TradeOfferScalarWhereInput | TradeOfferScalarWhereInput[]
  }

  export type TradeOfferUpdateManyWithoutTargetTeamNestedInput = {
    create?: XOR<TradeOfferCreateWithoutTargetTeamInput, TradeOfferUncheckedCreateWithoutTargetTeamInput> | TradeOfferCreateWithoutTargetTeamInput[] | TradeOfferUncheckedCreateWithoutTargetTeamInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutTargetTeamInput | TradeOfferCreateOrConnectWithoutTargetTeamInput[]
    upsert?: TradeOfferUpsertWithWhereUniqueWithoutTargetTeamInput | TradeOfferUpsertWithWhereUniqueWithoutTargetTeamInput[]
    createMany?: TradeOfferCreateManyTargetTeamInputEnvelope
    set?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    disconnect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    delete?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    update?: TradeOfferUpdateWithWhereUniqueWithoutTargetTeamInput | TradeOfferUpdateWithWhereUniqueWithoutTargetTeamInput[]
    updateMany?: TradeOfferUpdateManyWithWhereWithoutTargetTeamInput | TradeOfferUpdateManyWithWhereWithoutTargetTeamInput[]
    deleteMany?: TradeOfferScalarWhereInput | TradeOfferScalarWhereInput[]
  }

  export type RosterUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<RosterCreateWithoutTeamInput, RosterUncheckedCreateWithoutTeamInput> | RosterCreateWithoutTeamInput[] | RosterUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: RosterCreateOrConnectWithoutTeamInput | RosterCreateOrConnectWithoutTeamInput[]
    upsert?: RosterUpsertWithWhereUniqueWithoutTeamInput | RosterUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: RosterCreateManyTeamInputEnvelope
    set?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    disconnect?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    delete?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    connect?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    update?: RosterUpdateWithWhereUniqueWithoutTeamInput | RosterUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: RosterUpdateManyWithWhereWithoutTeamInput | RosterUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: RosterScalarWhereInput | RosterScalarWhereInput[]
  }

  export type DraftPickUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<DraftPickCreateWithoutTeamInput, DraftPickUncheckedCreateWithoutTeamInput> | DraftPickCreateWithoutTeamInput[] | DraftPickUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutTeamInput | DraftPickCreateOrConnectWithoutTeamInput[]
    upsert?: DraftPickUpsertWithWhereUniqueWithoutTeamInput | DraftPickUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: DraftPickCreateManyTeamInputEnvelope
    set?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    disconnect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    delete?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    update?: DraftPickUpdateWithWhereUniqueWithoutTeamInput | DraftPickUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: DraftPickUpdateManyWithWhereWithoutTeamInput | DraftPickUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: DraftPickScalarWhereInput | DraftPickScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutHomeTeamNestedInput = {
    create?: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput> | GameCreateWithoutHomeTeamInput[] | GameUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutHomeTeamInput | GameCreateOrConnectWithoutHomeTeamInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutHomeTeamInput | GameUpsertWithWhereUniqueWithoutHomeTeamInput[]
    createMany?: GameCreateManyHomeTeamInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutHomeTeamInput | GameUpdateWithWhereUniqueWithoutHomeTeamInput[]
    updateMany?: GameUpdateManyWithWhereWithoutHomeTeamInput | GameUpdateManyWithWhereWithoutHomeTeamInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutAwayTeamNestedInput = {
    create?: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput> | GameCreateWithoutAwayTeamInput[] | GameUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: GameCreateOrConnectWithoutAwayTeamInput | GameCreateOrConnectWithoutAwayTeamInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutAwayTeamInput | GameUpsertWithWhereUniqueWithoutAwayTeamInput[]
    createMany?: GameCreateManyAwayTeamInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutAwayTeamInput | GameUpdateWithWhereUniqueWithoutAwayTeamInput[]
    updateMany?: GameUpdateManyWithWhereWithoutAwayTeamInput | GameUpdateManyWithWhereWithoutAwayTeamInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TransactionCreateWithoutTeamInput, TransactionUncheckedCreateWithoutTeamInput> | TransactionCreateWithoutTeamInput[] | TransactionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTeamInput | TransactionCreateOrConnectWithoutTeamInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTeamInput | TransactionUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TransactionCreateManyTeamInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTeamInput | TransactionUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTeamInput | TransactionUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TradeOfferUncheckedUpdateManyWithoutOfferingTeamNestedInput = {
    create?: XOR<TradeOfferCreateWithoutOfferingTeamInput, TradeOfferUncheckedCreateWithoutOfferingTeamInput> | TradeOfferCreateWithoutOfferingTeamInput[] | TradeOfferUncheckedCreateWithoutOfferingTeamInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutOfferingTeamInput | TradeOfferCreateOrConnectWithoutOfferingTeamInput[]
    upsert?: TradeOfferUpsertWithWhereUniqueWithoutOfferingTeamInput | TradeOfferUpsertWithWhereUniqueWithoutOfferingTeamInput[]
    createMany?: TradeOfferCreateManyOfferingTeamInputEnvelope
    set?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    disconnect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    delete?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    update?: TradeOfferUpdateWithWhereUniqueWithoutOfferingTeamInput | TradeOfferUpdateWithWhereUniqueWithoutOfferingTeamInput[]
    updateMany?: TradeOfferUpdateManyWithWhereWithoutOfferingTeamInput | TradeOfferUpdateManyWithWhereWithoutOfferingTeamInput[]
    deleteMany?: TradeOfferScalarWhereInput | TradeOfferScalarWhereInput[]
  }

  export type TradeOfferUncheckedUpdateManyWithoutTargetTeamNestedInput = {
    create?: XOR<TradeOfferCreateWithoutTargetTeamInput, TradeOfferUncheckedCreateWithoutTargetTeamInput> | TradeOfferCreateWithoutTargetTeamInput[] | TradeOfferUncheckedCreateWithoutTargetTeamInput[]
    connectOrCreate?: TradeOfferCreateOrConnectWithoutTargetTeamInput | TradeOfferCreateOrConnectWithoutTargetTeamInput[]
    upsert?: TradeOfferUpsertWithWhereUniqueWithoutTargetTeamInput | TradeOfferUpsertWithWhereUniqueWithoutTargetTeamInput[]
    createMany?: TradeOfferCreateManyTargetTeamInputEnvelope
    set?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    disconnect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    delete?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    connect?: TradeOfferWhereUniqueInput | TradeOfferWhereUniqueInput[]
    update?: TradeOfferUpdateWithWhereUniqueWithoutTargetTeamInput | TradeOfferUpdateWithWhereUniqueWithoutTargetTeamInput[]
    updateMany?: TradeOfferUpdateManyWithWhereWithoutTargetTeamInput | TradeOfferUpdateManyWithWhereWithoutTargetTeamInput[]
    deleteMany?: TradeOfferScalarWhereInput | TradeOfferScalarWhereInput[]
  }

  export type RosterCreateNestedManyWithoutPlayerInput = {
    create?: XOR<RosterCreateWithoutPlayerInput, RosterUncheckedCreateWithoutPlayerInput> | RosterCreateWithoutPlayerInput[] | RosterUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: RosterCreateOrConnectWithoutPlayerInput | RosterCreateOrConnectWithoutPlayerInput[]
    createMany?: RosterCreateManyPlayerInputEnvelope
    connect?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
  }

  export type DraftPickCreateNestedManyWithoutPlayerInput = {
    create?: XOR<DraftPickCreateWithoutPlayerInput, DraftPickUncheckedCreateWithoutPlayerInput> | DraftPickCreateWithoutPlayerInput[] | DraftPickUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutPlayerInput | DraftPickCreateOrConnectWithoutPlayerInput[]
    createMany?: DraftPickCreateManyPlayerInputEnvelope
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutPlayerInput = {
    create?: XOR<TransactionCreateWithoutPlayerInput, TransactionUncheckedCreateWithoutPlayerInput> | TransactionCreateWithoutPlayerInput[] | TransactionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPlayerInput | TransactionCreateOrConnectWithoutPlayerInput[]
    createMany?: TransactionCreateManyPlayerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type GameStatsCreateNestedManyWithoutPlayerInput = {
    create?: XOR<GameStatsCreateWithoutPlayerInput, GameStatsUncheckedCreateWithoutPlayerInput> | GameStatsCreateWithoutPlayerInput[] | GameStatsUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: GameStatsCreateOrConnectWithoutPlayerInput | GameStatsCreateOrConnectWithoutPlayerInput[]
    createMany?: GameStatsCreateManyPlayerInputEnvelope
    connect?: GameStatsWhereUniqueInput | GameStatsWhereUniqueInput[]
  }

  export type WeeklyProjectionCreateNestedManyWithoutPlayerInput = {
    create?: XOR<WeeklyProjectionCreateWithoutPlayerInput, WeeklyProjectionUncheckedCreateWithoutPlayerInput> | WeeklyProjectionCreateWithoutPlayerInput[] | WeeklyProjectionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: WeeklyProjectionCreateOrConnectWithoutPlayerInput | WeeklyProjectionCreateOrConnectWithoutPlayerInput[]
    createMany?: WeeklyProjectionCreateManyPlayerInputEnvelope
    connect?: WeeklyProjectionWhereUniqueInput | WeeklyProjectionWhereUniqueInput[]
  }

  export type TradeOfferPlayerCreateNestedManyWithoutPlayerInput = {
    create?: XOR<TradeOfferPlayerCreateWithoutPlayerInput, TradeOfferPlayerUncheckedCreateWithoutPlayerInput> | TradeOfferPlayerCreateWithoutPlayerInput[] | TradeOfferPlayerUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TradeOfferPlayerCreateOrConnectWithoutPlayerInput | TradeOfferPlayerCreateOrConnectWithoutPlayerInput[]
    createMany?: TradeOfferPlayerCreateManyPlayerInputEnvelope
    connect?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
  }

  export type RosterUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<RosterCreateWithoutPlayerInput, RosterUncheckedCreateWithoutPlayerInput> | RosterCreateWithoutPlayerInput[] | RosterUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: RosterCreateOrConnectWithoutPlayerInput | RosterCreateOrConnectWithoutPlayerInput[]
    createMany?: RosterCreateManyPlayerInputEnvelope
    connect?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
  }

  export type DraftPickUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<DraftPickCreateWithoutPlayerInput, DraftPickUncheckedCreateWithoutPlayerInput> | DraftPickCreateWithoutPlayerInput[] | DraftPickUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutPlayerInput | DraftPickCreateOrConnectWithoutPlayerInput[]
    createMany?: DraftPickCreateManyPlayerInputEnvelope
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<TransactionCreateWithoutPlayerInput, TransactionUncheckedCreateWithoutPlayerInput> | TransactionCreateWithoutPlayerInput[] | TransactionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPlayerInput | TransactionCreateOrConnectWithoutPlayerInput[]
    createMany?: TransactionCreateManyPlayerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type GameStatsUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<GameStatsCreateWithoutPlayerInput, GameStatsUncheckedCreateWithoutPlayerInput> | GameStatsCreateWithoutPlayerInput[] | GameStatsUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: GameStatsCreateOrConnectWithoutPlayerInput | GameStatsCreateOrConnectWithoutPlayerInput[]
    createMany?: GameStatsCreateManyPlayerInputEnvelope
    connect?: GameStatsWhereUniqueInput | GameStatsWhereUniqueInput[]
  }

  export type WeeklyProjectionUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<WeeklyProjectionCreateWithoutPlayerInput, WeeklyProjectionUncheckedCreateWithoutPlayerInput> | WeeklyProjectionCreateWithoutPlayerInput[] | WeeklyProjectionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: WeeklyProjectionCreateOrConnectWithoutPlayerInput | WeeklyProjectionCreateOrConnectWithoutPlayerInput[]
    createMany?: WeeklyProjectionCreateManyPlayerInputEnvelope
    connect?: WeeklyProjectionWhereUniqueInput | WeeklyProjectionWhereUniqueInput[]
  }

  export type TradeOfferPlayerUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<TradeOfferPlayerCreateWithoutPlayerInput, TradeOfferPlayerUncheckedCreateWithoutPlayerInput> | TradeOfferPlayerCreateWithoutPlayerInput[] | TradeOfferPlayerUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TradeOfferPlayerCreateOrConnectWithoutPlayerInput | TradeOfferPlayerCreateOrConnectWithoutPlayerInput[]
    createMany?: TradeOfferPlayerCreateManyPlayerInputEnvelope
    connect?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
  }

  export type EnumPositionFieldUpdateOperationsInput = {
    set?: $Enums.Position
  }

  export type EnumInjuryStatusFieldUpdateOperationsInput = {
    set?: $Enums.InjuryStatus
  }

  export type RosterUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<RosterCreateWithoutPlayerInput, RosterUncheckedCreateWithoutPlayerInput> | RosterCreateWithoutPlayerInput[] | RosterUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: RosterCreateOrConnectWithoutPlayerInput | RosterCreateOrConnectWithoutPlayerInput[]
    upsert?: RosterUpsertWithWhereUniqueWithoutPlayerInput | RosterUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: RosterCreateManyPlayerInputEnvelope
    set?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    disconnect?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    delete?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    connect?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    update?: RosterUpdateWithWhereUniqueWithoutPlayerInput | RosterUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: RosterUpdateManyWithWhereWithoutPlayerInput | RosterUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: RosterScalarWhereInput | RosterScalarWhereInput[]
  }

  export type DraftPickUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<DraftPickCreateWithoutPlayerInput, DraftPickUncheckedCreateWithoutPlayerInput> | DraftPickCreateWithoutPlayerInput[] | DraftPickUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutPlayerInput | DraftPickCreateOrConnectWithoutPlayerInput[]
    upsert?: DraftPickUpsertWithWhereUniqueWithoutPlayerInput | DraftPickUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: DraftPickCreateManyPlayerInputEnvelope
    set?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    disconnect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    delete?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    update?: DraftPickUpdateWithWhereUniqueWithoutPlayerInput | DraftPickUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: DraftPickUpdateManyWithWhereWithoutPlayerInput | DraftPickUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: DraftPickScalarWhereInput | DraftPickScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<TransactionCreateWithoutPlayerInput, TransactionUncheckedCreateWithoutPlayerInput> | TransactionCreateWithoutPlayerInput[] | TransactionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPlayerInput | TransactionCreateOrConnectWithoutPlayerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPlayerInput | TransactionUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: TransactionCreateManyPlayerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPlayerInput | TransactionUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPlayerInput | TransactionUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type GameStatsUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<GameStatsCreateWithoutPlayerInput, GameStatsUncheckedCreateWithoutPlayerInput> | GameStatsCreateWithoutPlayerInput[] | GameStatsUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: GameStatsCreateOrConnectWithoutPlayerInput | GameStatsCreateOrConnectWithoutPlayerInput[]
    upsert?: GameStatsUpsertWithWhereUniqueWithoutPlayerInput | GameStatsUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: GameStatsCreateManyPlayerInputEnvelope
    set?: GameStatsWhereUniqueInput | GameStatsWhereUniqueInput[]
    disconnect?: GameStatsWhereUniqueInput | GameStatsWhereUniqueInput[]
    delete?: GameStatsWhereUniqueInput | GameStatsWhereUniqueInput[]
    connect?: GameStatsWhereUniqueInput | GameStatsWhereUniqueInput[]
    update?: GameStatsUpdateWithWhereUniqueWithoutPlayerInput | GameStatsUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: GameStatsUpdateManyWithWhereWithoutPlayerInput | GameStatsUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: GameStatsScalarWhereInput | GameStatsScalarWhereInput[]
  }

  export type WeeklyProjectionUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<WeeklyProjectionCreateWithoutPlayerInput, WeeklyProjectionUncheckedCreateWithoutPlayerInput> | WeeklyProjectionCreateWithoutPlayerInput[] | WeeklyProjectionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: WeeklyProjectionCreateOrConnectWithoutPlayerInput | WeeklyProjectionCreateOrConnectWithoutPlayerInput[]
    upsert?: WeeklyProjectionUpsertWithWhereUniqueWithoutPlayerInput | WeeklyProjectionUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: WeeklyProjectionCreateManyPlayerInputEnvelope
    set?: WeeklyProjectionWhereUniqueInput | WeeklyProjectionWhereUniqueInput[]
    disconnect?: WeeklyProjectionWhereUniqueInput | WeeklyProjectionWhereUniqueInput[]
    delete?: WeeklyProjectionWhereUniqueInput | WeeklyProjectionWhereUniqueInput[]
    connect?: WeeklyProjectionWhereUniqueInput | WeeklyProjectionWhereUniqueInput[]
    update?: WeeklyProjectionUpdateWithWhereUniqueWithoutPlayerInput | WeeklyProjectionUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: WeeklyProjectionUpdateManyWithWhereWithoutPlayerInput | WeeklyProjectionUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: WeeklyProjectionScalarWhereInput | WeeklyProjectionScalarWhereInput[]
  }

  export type TradeOfferPlayerUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<TradeOfferPlayerCreateWithoutPlayerInput, TradeOfferPlayerUncheckedCreateWithoutPlayerInput> | TradeOfferPlayerCreateWithoutPlayerInput[] | TradeOfferPlayerUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TradeOfferPlayerCreateOrConnectWithoutPlayerInput | TradeOfferPlayerCreateOrConnectWithoutPlayerInput[]
    upsert?: TradeOfferPlayerUpsertWithWhereUniqueWithoutPlayerInput | TradeOfferPlayerUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: TradeOfferPlayerCreateManyPlayerInputEnvelope
    set?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    disconnect?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    delete?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    connect?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    update?: TradeOfferPlayerUpdateWithWhereUniqueWithoutPlayerInput | TradeOfferPlayerUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: TradeOfferPlayerUpdateManyWithWhereWithoutPlayerInput | TradeOfferPlayerUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: TradeOfferPlayerScalarWhereInput | TradeOfferPlayerScalarWhereInput[]
  }

  export type RosterUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<RosterCreateWithoutPlayerInput, RosterUncheckedCreateWithoutPlayerInput> | RosterCreateWithoutPlayerInput[] | RosterUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: RosterCreateOrConnectWithoutPlayerInput | RosterCreateOrConnectWithoutPlayerInput[]
    upsert?: RosterUpsertWithWhereUniqueWithoutPlayerInput | RosterUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: RosterCreateManyPlayerInputEnvelope
    set?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    disconnect?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    delete?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    connect?: RosterWhereUniqueInput | RosterWhereUniqueInput[]
    update?: RosterUpdateWithWhereUniqueWithoutPlayerInput | RosterUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: RosterUpdateManyWithWhereWithoutPlayerInput | RosterUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: RosterScalarWhereInput | RosterScalarWhereInput[]
  }

  export type DraftPickUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<DraftPickCreateWithoutPlayerInput, DraftPickUncheckedCreateWithoutPlayerInput> | DraftPickCreateWithoutPlayerInput[] | DraftPickUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutPlayerInput | DraftPickCreateOrConnectWithoutPlayerInput[]
    upsert?: DraftPickUpsertWithWhereUniqueWithoutPlayerInput | DraftPickUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: DraftPickCreateManyPlayerInputEnvelope
    set?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    disconnect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    delete?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    update?: DraftPickUpdateWithWhereUniqueWithoutPlayerInput | DraftPickUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: DraftPickUpdateManyWithWhereWithoutPlayerInput | DraftPickUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: DraftPickScalarWhereInput | DraftPickScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<TransactionCreateWithoutPlayerInput, TransactionUncheckedCreateWithoutPlayerInput> | TransactionCreateWithoutPlayerInput[] | TransactionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPlayerInput | TransactionCreateOrConnectWithoutPlayerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPlayerInput | TransactionUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: TransactionCreateManyPlayerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPlayerInput | TransactionUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPlayerInput | TransactionUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type GameStatsUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<GameStatsCreateWithoutPlayerInput, GameStatsUncheckedCreateWithoutPlayerInput> | GameStatsCreateWithoutPlayerInput[] | GameStatsUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: GameStatsCreateOrConnectWithoutPlayerInput | GameStatsCreateOrConnectWithoutPlayerInput[]
    upsert?: GameStatsUpsertWithWhereUniqueWithoutPlayerInput | GameStatsUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: GameStatsCreateManyPlayerInputEnvelope
    set?: GameStatsWhereUniqueInput | GameStatsWhereUniqueInput[]
    disconnect?: GameStatsWhereUniqueInput | GameStatsWhereUniqueInput[]
    delete?: GameStatsWhereUniqueInput | GameStatsWhereUniqueInput[]
    connect?: GameStatsWhereUniqueInput | GameStatsWhereUniqueInput[]
    update?: GameStatsUpdateWithWhereUniqueWithoutPlayerInput | GameStatsUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: GameStatsUpdateManyWithWhereWithoutPlayerInput | GameStatsUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: GameStatsScalarWhereInput | GameStatsScalarWhereInput[]
  }

  export type WeeklyProjectionUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<WeeklyProjectionCreateWithoutPlayerInput, WeeklyProjectionUncheckedCreateWithoutPlayerInput> | WeeklyProjectionCreateWithoutPlayerInput[] | WeeklyProjectionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: WeeklyProjectionCreateOrConnectWithoutPlayerInput | WeeklyProjectionCreateOrConnectWithoutPlayerInput[]
    upsert?: WeeklyProjectionUpsertWithWhereUniqueWithoutPlayerInput | WeeklyProjectionUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: WeeklyProjectionCreateManyPlayerInputEnvelope
    set?: WeeklyProjectionWhereUniqueInput | WeeklyProjectionWhereUniqueInput[]
    disconnect?: WeeklyProjectionWhereUniqueInput | WeeklyProjectionWhereUniqueInput[]
    delete?: WeeklyProjectionWhereUniqueInput | WeeklyProjectionWhereUniqueInput[]
    connect?: WeeklyProjectionWhereUniqueInput | WeeklyProjectionWhereUniqueInput[]
    update?: WeeklyProjectionUpdateWithWhereUniqueWithoutPlayerInput | WeeklyProjectionUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: WeeklyProjectionUpdateManyWithWhereWithoutPlayerInput | WeeklyProjectionUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: WeeklyProjectionScalarWhereInput | WeeklyProjectionScalarWhereInput[]
  }

  export type TradeOfferPlayerUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<TradeOfferPlayerCreateWithoutPlayerInput, TradeOfferPlayerUncheckedCreateWithoutPlayerInput> | TradeOfferPlayerCreateWithoutPlayerInput[] | TradeOfferPlayerUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: TradeOfferPlayerCreateOrConnectWithoutPlayerInput | TradeOfferPlayerCreateOrConnectWithoutPlayerInput[]
    upsert?: TradeOfferPlayerUpsertWithWhereUniqueWithoutPlayerInput | TradeOfferPlayerUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: TradeOfferPlayerCreateManyPlayerInputEnvelope
    set?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    disconnect?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    delete?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    connect?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    update?: TradeOfferPlayerUpdateWithWhereUniqueWithoutPlayerInput | TradeOfferPlayerUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: TradeOfferPlayerUpdateManyWithWhereWithoutPlayerInput | TradeOfferPlayerUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: TradeOfferPlayerScalarWhereInput | TradeOfferPlayerScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutRosterInput = {
    create?: XOR<TeamCreateWithoutRosterInput, TeamUncheckedCreateWithoutRosterInput>
    connectOrCreate?: TeamCreateOrConnectWithoutRosterInput
    connect?: TeamWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutRosterInput = {
    create?: XOR<PlayerCreateWithoutRosterInput, PlayerUncheckedCreateWithoutRosterInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutRosterInput
    connect?: PlayerWhereUniqueInput
  }

  export type EnumRosterPositionFieldUpdateOperationsInput = {
    set?: $Enums.RosterPosition
  }

  export type TeamUpdateOneRequiredWithoutRosterNestedInput = {
    create?: XOR<TeamCreateWithoutRosterInput, TeamUncheckedCreateWithoutRosterInput>
    connectOrCreate?: TeamCreateOrConnectWithoutRosterInput
    upsert?: TeamUpsertWithoutRosterInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutRosterInput, TeamUpdateWithoutRosterInput>, TeamUncheckedUpdateWithoutRosterInput>
  }

  export type PlayerUpdateOneRequiredWithoutRosterNestedInput = {
    create?: XOR<PlayerCreateWithoutRosterInput, PlayerUncheckedCreateWithoutRosterInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutRosterInput
    upsert?: PlayerUpsertWithoutRosterInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutRosterInput, PlayerUpdateWithoutRosterInput>, PlayerUncheckedUpdateWithoutRosterInput>
  }

  export type LeagueCreateNestedOneWithoutDraftInput = {
    create?: XOR<LeagueCreateWithoutDraftInput, LeagueUncheckedCreateWithoutDraftInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutDraftInput
    connect?: LeagueWhereUniqueInput
  }

  export type DraftPickCreateNestedManyWithoutDraftInput = {
    create?: XOR<DraftPickCreateWithoutDraftInput, DraftPickUncheckedCreateWithoutDraftInput> | DraftPickCreateWithoutDraftInput[] | DraftPickUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutDraftInput | DraftPickCreateOrConnectWithoutDraftInput[]
    createMany?: DraftPickCreateManyDraftInputEnvelope
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
  }

  export type DraftPickUncheckedCreateNestedManyWithoutDraftInput = {
    create?: XOR<DraftPickCreateWithoutDraftInput, DraftPickUncheckedCreateWithoutDraftInput> | DraftPickCreateWithoutDraftInput[] | DraftPickUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutDraftInput | DraftPickCreateOrConnectWithoutDraftInput[]
    createMany?: DraftPickCreateManyDraftInputEnvelope
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
  }

  export type LeagueUpdateOneRequiredWithoutDraftNestedInput = {
    create?: XOR<LeagueCreateWithoutDraftInput, LeagueUncheckedCreateWithoutDraftInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutDraftInput
    upsert?: LeagueUpsertWithoutDraftInput
    connect?: LeagueWhereUniqueInput
    update?: XOR<XOR<LeagueUpdateToOneWithWhereWithoutDraftInput, LeagueUpdateWithoutDraftInput>, LeagueUncheckedUpdateWithoutDraftInput>
  }

  export type DraftPickUpdateManyWithoutDraftNestedInput = {
    create?: XOR<DraftPickCreateWithoutDraftInput, DraftPickUncheckedCreateWithoutDraftInput> | DraftPickCreateWithoutDraftInput[] | DraftPickUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutDraftInput | DraftPickCreateOrConnectWithoutDraftInput[]
    upsert?: DraftPickUpsertWithWhereUniqueWithoutDraftInput | DraftPickUpsertWithWhereUniqueWithoutDraftInput[]
    createMany?: DraftPickCreateManyDraftInputEnvelope
    set?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    disconnect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    delete?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    update?: DraftPickUpdateWithWhereUniqueWithoutDraftInput | DraftPickUpdateWithWhereUniqueWithoutDraftInput[]
    updateMany?: DraftPickUpdateManyWithWhereWithoutDraftInput | DraftPickUpdateManyWithWhereWithoutDraftInput[]
    deleteMany?: DraftPickScalarWhereInput | DraftPickScalarWhereInput[]
  }

  export type DraftPickUncheckedUpdateManyWithoutDraftNestedInput = {
    create?: XOR<DraftPickCreateWithoutDraftInput, DraftPickUncheckedCreateWithoutDraftInput> | DraftPickCreateWithoutDraftInput[] | DraftPickUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: DraftPickCreateOrConnectWithoutDraftInput | DraftPickCreateOrConnectWithoutDraftInput[]
    upsert?: DraftPickUpsertWithWhereUniqueWithoutDraftInput | DraftPickUpsertWithWhereUniqueWithoutDraftInput[]
    createMany?: DraftPickCreateManyDraftInputEnvelope
    set?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    disconnect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    delete?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    connect?: DraftPickWhereUniqueInput | DraftPickWhereUniqueInput[]
    update?: DraftPickUpdateWithWhereUniqueWithoutDraftInput | DraftPickUpdateWithWhereUniqueWithoutDraftInput[]
    updateMany?: DraftPickUpdateManyWithWhereWithoutDraftInput | DraftPickUpdateManyWithWhereWithoutDraftInput[]
    deleteMany?: DraftPickScalarWhereInput | DraftPickScalarWhereInput[]
  }

  export type DraftCreateNestedOneWithoutPicksInput = {
    create?: XOR<DraftCreateWithoutPicksInput, DraftUncheckedCreateWithoutPicksInput>
    connectOrCreate?: DraftCreateOrConnectWithoutPicksInput
    connect?: DraftWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutDraftPicksInput = {
    create?: XOR<TeamCreateWithoutDraftPicksInput, TeamUncheckedCreateWithoutDraftPicksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutDraftPicksInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDraftPicksInput = {
    create?: XOR<UserCreateWithoutDraftPicksInput, UserUncheckedCreateWithoutDraftPicksInput>
    connectOrCreate?: UserCreateOrConnectWithoutDraftPicksInput
    connect?: UserWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutDraftPicksInput = {
    create?: XOR<PlayerCreateWithoutDraftPicksInput, PlayerUncheckedCreateWithoutDraftPicksInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutDraftPicksInput
    connect?: PlayerWhereUniqueInput
  }

  export type DraftUpdateOneRequiredWithoutPicksNestedInput = {
    create?: XOR<DraftCreateWithoutPicksInput, DraftUncheckedCreateWithoutPicksInput>
    connectOrCreate?: DraftCreateOrConnectWithoutPicksInput
    upsert?: DraftUpsertWithoutPicksInput
    connect?: DraftWhereUniqueInput
    update?: XOR<XOR<DraftUpdateToOneWithWhereWithoutPicksInput, DraftUpdateWithoutPicksInput>, DraftUncheckedUpdateWithoutPicksInput>
  }

  export type TeamUpdateOneRequiredWithoutDraftPicksNestedInput = {
    create?: XOR<TeamCreateWithoutDraftPicksInput, TeamUncheckedCreateWithoutDraftPicksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutDraftPicksInput
    upsert?: TeamUpsertWithoutDraftPicksInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutDraftPicksInput, TeamUpdateWithoutDraftPicksInput>, TeamUncheckedUpdateWithoutDraftPicksInput>
  }

  export type UserUpdateOneRequiredWithoutDraftPicksNestedInput = {
    create?: XOR<UserCreateWithoutDraftPicksInput, UserUncheckedCreateWithoutDraftPicksInput>
    connectOrCreate?: UserCreateOrConnectWithoutDraftPicksInput
    upsert?: UserUpsertWithoutDraftPicksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDraftPicksInput, UserUpdateWithoutDraftPicksInput>, UserUncheckedUpdateWithoutDraftPicksInput>
  }

  export type PlayerUpdateOneWithoutDraftPicksNestedInput = {
    create?: XOR<PlayerCreateWithoutDraftPicksInput, PlayerUncheckedCreateWithoutDraftPicksInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutDraftPicksInput
    upsert?: PlayerUpsertWithoutDraftPicksInput
    disconnect?: PlayerWhereInput | boolean
    delete?: PlayerWhereInput | boolean
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutDraftPicksInput, PlayerUpdateWithoutDraftPicksInput>, PlayerUncheckedUpdateWithoutDraftPicksInput>
  }

  export type LeagueCreateNestedOneWithoutGamesInput = {
    create?: XOR<LeagueCreateWithoutGamesInput, LeagueUncheckedCreateWithoutGamesInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutGamesInput
    connect?: LeagueWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutHomeGamesInput = {
    create?: XOR<TeamCreateWithoutHomeGamesInput, TeamUncheckedCreateWithoutHomeGamesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutHomeGamesInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutAwayGamesInput = {
    create?: XOR<TeamCreateWithoutAwayGamesInput, TeamUncheckedCreateWithoutAwayGamesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutAwayGamesInput
    connect?: TeamWhereUniqueInput
  }

  export type LeagueUpdateOneRequiredWithoutGamesNestedInput = {
    create?: XOR<LeagueCreateWithoutGamesInput, LeagueUncheckedCreateWithoutGamesInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutGamesInput
    upsert?: LeagueUpsertWithoutGamesInput
    connect?: LeagueWhereUniqueInput
    update?: XOR<XOR<LeagueUpdateToOneWithWhereWithoutGamesInput, LeagueUpdateWithoutGamesInput>, LeagueUncheckedUpdateWithoutGamesInput>
  }

  export type TeamUpdateOneRequiredWithoutHomeGamesNestedInput = {
    create?: XOR<TeamCreateWithoutHomeGamesInput, TeamUncheckedCreateWithoutHomeGamesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutHomeGamesInput
    upsert?: TeamUpsertWithoutHomeGamesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutHomeGamesInput, TeamUpdateWithoutHomeGamesInput>, TeamUncheckedUpdateWithoutHomeGamesInput>
  }

  export type TeamUpdateOneRequiredWithoutAwayGamesNestedInput = {
    create?: XOR<TeamCreateWithoutAwayGamesInput, TeamUncheckedCreateWithoutAwayGamesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutAwayGamesInput
    upsert?: TeamUpsertWithoutAwayGamesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutAwayGamesInput, TeamUpdateWithoutAwayGamesInput>, TeamUncheckedUpdateWithoutAwayGamesInput>
  }

  export type LeagueCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<LeagueCreateWithoutTransactionsInput, LeagueUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutTransactionsInput
    connect?: LeagueWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<TeamCreateWithoutTransactionsInput, TeamUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTransactionsInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<PlayerCreateWithoutTransactionsInput, PlayerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutTransactionsInput
    connect?: PlayerWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type LeagueUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<LeagueCreateWithoutTransactionsInput, LeagueUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutTransactionsInput
    upsert?: LeagueUpsertWithoutTransactionsInput
    connect?: LeagueWhereUniqueInput
    update?: XOR<XOR<LeagueUpdateToOneWithWhereWithoutTransactionsInput, LeagueUpdateWithoutTransactionsInput>, LeagueUncheckedUpdateWithoutTransactionsInput>
  }

  export type TeamUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<TeamCreateWithoutTransactionsInput, TeamUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTransactionsInput
    upsert?: TeamUpsertWithoutTransactionsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutTransactionsInput, TeamUpdateWithoutTransactionsInput>, TeamUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type PlayerUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<PlayerCreateWithoutTransactionsInput, PlayerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutTransactionsInput
    upsert?: PlayerUpsertWithoutTransactionsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutTransactionsInput, PlayerUpdateWithoutTransactionsInput>, PlayerUncheckedUpdateWithoutTransactionsInput>
  }

  export type LeagueCreateNestedOneWithoutTradeOffersInput = {
    create?: XOR<LeagueCreateWithoutTradeOffersInput, LeagueUncheckedCreateWithoutTradeOffersInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutTradeOffersInput
    connect?: LeagueWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutOfferedTradesInput = {
    create?: XOR<TeamCreateWithoutOfferedTradesInput, TeamUncheckedCreateWithoutOfferedTradesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutOfferedTradesInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutTargetedTradesInput = {
    create?: XOR<TeamCreateWithoutTargetedTradesInput, TeamUncheckedCreateWithoutTargetedTradesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTargetedTradesInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTradeOffersInput = {
    create?: XOR<UserCreateWithoutTradeOffersInput, UserUncheckedCreateWithoutTradeOffersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTradeOffersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTradeTargetsInput = {
    create?: XOR<UserCreateWithoutTradeTargetsInput, UserUncheckedCreateWithoutTradeTargetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTradeTargetsInput
    connect?: UserWhereUniqueInput
  }

  export type TradeOfferPlayerCreateNestedManyWithoutTradeOfferInput = {
    create?: XOR<TradeOfferPlayerCreateWithoutTradeOfferInput, TradeOfferPlayerUncheckedCreateWithoutTradeOfferInput> | TradeOfferPlayerCreateWithoutTradeOfferInput[] | TradeOfferPlayerUncheckedCreateWithoutTradeOfferInput[]
    connectOrCreate?: TradeOfferPlayerCreateOrConnectWithoutTradeOfferInput | TradeOfferPlayerCreateOrConnectWithoutTradeOfferInput[]
    createMany?: TradeOfferPlayerCreateManyTradeOfferInputEnvelope
    connect?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
  }

  export type TradeOfferPlayerUncheckedCreateNestedManyWithoutTradeOfferInput = {
    create?: XOR<TradeOfferPlayerCreateWithoutTradeOfferInput, TradeOfferPlayerUncheckedCreateWithoutTradeOfferInput> | TradeOfferPlayerCreateWithoutTradeOfferInput[] | TradeOfferPlayerUncheckedCreateWithoutTradeOfferInput[]
    connectOrCreate?: TradeOfferPlayerCreateOrConnectWithoutTradeOfferInput | TradeOfferPlayerCreateOrConnectWithoutTradeOfferInput[]
    createMany?: TradeOfferPlayerCreateManyTradeOfferInputEnvelope
    connect?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
  }

  export type EnumTradeStatusFieldUpdateOperationsInput = {
    set?: $Enums.TradeStatus
  }

  export type LeagueUpdateOneRequiredWithoutTradeOffersNestedInput = {
    create?: XOR<LeagueCreateWithoutTradeOffersInput, LeagueUncheckedCreateWithoutTradeOffersInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutTradeOffersInput
    upsert?: LeagueUpsertWithoutTradeOffersInput
    connect?: LeagueWhereUniqueInput
    update?: XOR<XOR<LeagueUpdateToOneWithWhereWithoutTradeOffersInput, LeagueUpdateWithoutTradeOffersInput>, LeagueUncheckedUpdateWithoutTradeOffersInput>
  }

  export type TeamUpdateOneRequiredWithoutOfferedTradesNestedInput = {
    create?: XOR<TeamCreateWithoutOfferedTradesInput, TeamUncheckedCreateWithoutOfferedTradesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutOfferedTradesInput
    upsert?: TeamUpsertWithoutOfferedTradesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutOfferedTradesInput, TeamUpdateWithoutOfferedTradesInput>, TeamUncheckedUpdateWithoutOfferedTradesInput>
  }

  export type TeamUpdateOneRequiredWithoutTargetedTradesNestedInput = {
    create?: XOR<TeamCreateWithoutTargetedTradesInput, TeamUncheckedCreateWithoutTargetedTradesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTargetedTradesInput
    upsert?: TeamUpsertWithoutTargetedTradesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutTargetedTradesInput, TeamUpdateWithoutTargetedTradesInput>, TeamUncheckedUpdateWithoutTargetedTradesInput>
  }

  export type UserUpdateOneRequiredWithoutTradeOffersNestedInput = {
    create?: XOR<UserCreateWithoutTradeOffersInput, UserUncheckedCreateWithoutTradeOffersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTradeOffersInput
    upsert?: UserUpsertWithoutTradeOffersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTradeOffersInput, UserUpdateWithoutTradeOffersInput>, UserUncheckedUpdateWithoutTradeOffersInput>
  }

  export type UserUpdateOneRequiredWithoutTradeTargetsNestedInput = {
    create?: XOR<UserCreateWithoutTradeTargetsInput, UserUncheckedCreateWithoutTradeTargetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTradeTargetsInput
    upsert?: UserUpsertWithoutTradeTargetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTradeTargetsInput, UserUpdateWithoutTradeTargetsInput>, UserUncheckedUpdateWithoutTradeTargetsInput>
  }

  export type TradeOfferPlayerUpdateManyWithoutTradeOfferNestedInput = {
    create?: XOR<TradeOfferPlayerCreateWithoutTradeOfferInput, TradeOfferPlayerUncheckedCreateWithoutTradeOfferInput> | TradeOfferPlayerCreateWithoutTradeOfferInput[] | TradeOfferPlayerUncheckedCreateWithoutTradeOfferInput[]
    connectOrCreate?: TradeOfferPlayerCreateOrConnectWithoutTradeOfferInput | TradeOfferPlayerCreateOrConnectWithoutTradeOfferInput[]
    upsert?: TradeOfferPlayerUpsertWithWhereUniqueWithoutTradeOfferInput | TradeOfferPlayerUpsertWithWhereUniqueWithoutTradeOfferInput[]
    createMany?: TradeOfferPlayerCreateManyTradeOfferInputEnvelope
    set?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    disconnect?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    delete?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    connect?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    update?: TradeOfferPlayerUpdateWithWhereUniqueWithoutTradeOfferInput | TradeOfferPlayerUpdateWithWhereUniqueWithoutTradeOfferInput[]
    updateMany?: TradeOfferPlayerUpdateManyWithWhereWithoutTradeOfferInput | TradeOfferPlayerUpdateManyWithWhereWithoutTradeOfferInput[]
    deleteMany?: TradeOfferPlayerScalarWhereInput | TradeOfferPlayerScalarWhereInput[]
  }

  export type TradeOfferPlayerUncheckedUpdateManyWithoutTradeOfferNestedInput = {
    create?: XOR<TradeOfferPlayerCreateWithoutTradeOfferInput, TradeOfferPlayerUncheckedCreateWithoutTradeOfferInput> | TradeOfferPlayerCreateWithoutTradeOfferInput[] | TradeOfferPlayerUncheckedCreateWithoutTradeOfferInput[]
    connectOrCreate?: TradeOfferPlayerCreateOrConnectWithoutTradeOfferInput | TradeOfferPlayerCreateOrConnectWithoutTradeOfferInput[]
    upsert?: TradeOfferPlayerUpsertWithWhereUniqueWithoutTradeOfferInput | TradeOfferPlayerUpsertWithWhereUniqueWithoutTradeOfferInput[]
    createMany?: TradeOfferPlayerCreateManyTradeOfferInputEnvelope
    set?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    disconnect?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    delete?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    connect?: TradeOfferPlayerWhereUniqueInput | TradeOfferPlayerWhereUniqueInput[]
    update?: TradeOfferPlayerUpdateWithWhereUniqueWithoutTradeOfferInput | TradeOfferPlayerUpdateWithWhereUniqueWithoutTradeOfferInput[]
    updateMany?: TradeOfferPlayerUpdateManyWithWhereWithoutTradeOfferInput | TradeOfferPlayerUpdateManyWithWhereWithoutTradeOfferInput[]
    deleteMany?: TradeOfferPlayerScalarWhereInput | TradeOfferPlayerScalarWhereInput[]
  }

  export type TradeOfferCreateNestedOneWithoutPlayersInput = {
    create?: XOR<TradeOfferCreateWithoutPlayersInput, TradeOfferUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: TradeOfferCreateOrConnectWithoutPlayersInput
    connect?: TradeOfferWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutTradeOfferPlayersInput = {
    create?: XOR<PlayerCreateWithoutTradeOfferPlayersInput, PlayerUncheckedCreateWithoutTradeOfferPlayersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutTradeOfferPlayersInput
    connect?: PlayerWhereUniqueInput
  }

  export type TradeOfferUpdateOneRequiredWithoutPlayersNestedInput = {
    create?: XOR<TradeOfferCreateWithoutPlayersInput, TradeOfferUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: TradeOfferCreateOrConnectWithoutPlayersInput
    upsert?: TradeOfferUpsertWithoutPlayersInput
    connect?: TradeOfferWhereUniqueInput
    update?: XOR<XOR<TradeOfferUpdateToOneWithWhereWithoutPlayersInput, TradeOfferUpdateWithoutPlayersInput>, TradeOfferUncheckedUpdateWithoutPlayersInput>
  }

  export type PlayerUpdateOneRequiredWithoutTradeOfferPlayersNestedInput = {
    create?: XOR<PlayerCreateWithoutTradeOfferPlayersInput, PlayerUncheckedCreateWithoutTradeOfferPlayersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutTradeOfferPlayersInput
    upsert?: PlayerUpsertWithoutTradeOfferPlayersInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutTradeOfferPlayersInput, PlayerUpdateWithoutTradeOfferPlayersInput>, PlayerUncheckedUpdateWithoutTradeOfferPlayersInput>
  }

  export type LeagueCreateNestedOneWithoutMessagesInput = {
    create?: XOR<LeagueCreateWithoutMessagesInput, LeagueUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutMessagesInput
    connect?: LeagueWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type LeagueUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<LeagueCreateWithoutMessagesInput, LeagueUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: LeagueCreateOrConnectWithoutMessagesInput
    upsert?: LeagueUpsertWithoutMessagesInput
    disconnect?: LeagueWhereInput | boolean
    delete?: LeagueWhereInput | boolean
    connect?: LeagueWhereUniqueInput
    update?: XOR<XOR<LeagueUpdateToOneWithWhereWithoutMessagesInput, LeagueUpdateWithoutMessagesInput>, LeagueUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type PlayerCreateNestedOneWithoutGameStatsInput = {
    create?: XOR<PlayerCreateWithoutGameStatsInput, PlayerUncheckedCreateWithoutGameStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutGameStatsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutGameStatsNestedInput = {
    create?: XOR<PlayerCreateWithoutGameStatsInput, PlayerUncheckedCreateWithoutGameStatsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutGameStatsInput
    upsert?: PlayerUpsertWithoutGameStatsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutGameStatsInput, PlayerUpdateWithoutGameStatsInput>, PlayerUncheckedUpdateWithoutGameStatsInput>
  }

  export type PlayerCreateNestedOneWithoutWeeklyProjectionsInput = {
    create?: XOR<PlayerCreateWithoutWeeklyProjectionsInput, PlayerUncheckedCreateWithoutWeeklyProjectionsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutWeeklyProjectionsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutWeeklyProjectionsNestedInput = {
    create?: XOR<PlayerCreateWithoutWeeklyProjectionsInput, PlayerUncheckedCreateWithoutWeeklyProjectionsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutWeeklyProjectionsInput
    upsert?: PlayerUpsertWithoutWeeklyProjectionsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutWeeklyProjectionsInput, PlayerUpdateWithoutWeeklyProjectionsInput>, PlayerUncheckedUpdateWithoutWeeklyProjectionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumDraftTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DraftType | EnumDraftTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DraftType[] | ListEnumDraftTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DraftType[] | ListEnumDraftTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDraftTypeFilter<$PrismaModel> | $Enums.DraftType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumDraftTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DraftType | EnumDraftTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DraftType[] | ListEnumDraftTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DraftType[] | ListEnumDraftTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDraftTypeWithAggregatesFilter<$PrismaModel> | $Enums.DraftType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDraftTypeFilter<$PrismaModel>
    _max?: NestedEnumDraftTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumScoringTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoringType | EnumScoringTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoringType[] | ListEnumScoringTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoringType[] | ListEnumScoringTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoringTypeFilter<$PrismaModel> | $Enums.ScoringType
  }

  export type NestedEnumTradeReviewTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeReviewType | EnumTradeReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TradeReviewType[] | ListEnumTradeReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeReviewType[] | ListEnumTradeReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeReviewTypeFilter<$PrismaModel> | $Enums.TradeReviewType
  }

  export type NestedEnumWaiverTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WaiverType | EnumWaiverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WaiverType[] | ListEnumWaiverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WaiverType[] | ListEnumWaiverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWaiverTypeFilter<$PrismaModel> | $Enums.WaiverType
  }

  export type NestedEnumScoringTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoringType | EnumScoringTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoringType[] | ListEnumScoringTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoringType[] | ListEnumScoringTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoringTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScoringType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScoringTypeFilter<$PrismaModel>
    _max?: NestedEnumScoringTypeFilter<$PrismaModel>
  }

  export type NestedEnumTradeReviewTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeReviewType | EnumTradeReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TradeReviewType[] | ListEnumTradeReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeReviewType[] | ListEnumTradeReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeReviewTypeWithAggregatesFilter<$PrismaModel> | $Enums.TradeReviewType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTradeReviewTypeFilter<$PrismaModel>
    _max?: NestedEnumTradeReviewTypeFilter<$PrismaModel>
  }

  export type NestedEnumWaiverTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WaiverType | EnumWaiverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WaiverType[] | ListEnumWaiverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WaiverType[] | ListEnumWaiverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWaiverTypeWithAggregatesFilter<$PrismaModel> | $Enums.WaiverType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWaiverTypeFilter<$PrismaModel>
    _max?: NestedEnumWaiverTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumPositionFilter<$PrismaModel = never> = {
    equals?: $Enums.Position | EnumPositionFieldRefInput<$PrismaModel>
    in?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionFilter<$PrismaModel> | $Enums.Position
  }

  export type NestedEnumInjuryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryStatus | EnumInjuryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryStatusFilter<$PrismaModel> | $Enums.InjuryStatus
  }

  export type NestedEnumPositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Position | EnumPositionFieldRefInput<$PrismaModel>
    in?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionWithAggregatesFilter<$PrismaModel> | $Enums.Position
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPositionFilter<$PrismaModel>
    _max?: NestedEnumPositionFilter<$PrismaModel>
  }

  export type NestedEnumInjuryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InjuryStatus | EnumInjuryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InjuryStatus[] | ListEnumInjuryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInjuryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InjuryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInjuryStatusFilter<$PrismaModel>
    _max?: NestedEnumInjuryStatusFilter<$PrismaModel>
  }

  export type NestedEnumRosterPositionFilter<$PrismaModel = never> = {
    equals?: $Enums.RosterPosition | EnumRosterPositionFieldRefInput<$PrismaModel>
    in?: $Enums.RosterPosition[] | ListEnumRosterPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.RosterPosition[] | ListEnumRosterPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumRosterPositionFilter<$PrismaModel> | $Enums.RosterPosition
  }

  export type NestedEnumRosterPositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RosterPosition | EnumRosterPositionFieldRefInput<$PrismaModel>
    in?: $Enums.RosterPosition[] | ListEnumRosterPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.RosterPosition[] | ListEnumRosterPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumRosterPositionWithAggregatesFilter<$PrismaModel> | $Enums.RosterPosition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRosterPositionFilter<$PrismaModel>
    _max?: NestedEnumRosterPositionFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTradeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeStatus | EnumTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeStatusFilter<$PrismaModel> | $Enums.TradeStatus
  }

  export type NestedEnumTradeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeStatus | EnumTradeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeStatus[] | ListEnumTradeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeStatusWithAggregatesFilter<$PrismaModel> | $Enums.TradeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTradeStatusFilter<$PrismaModel>
    _max?: NestedEnumTradeStatusFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type TeamCreateWithoutOwnerInput = {
    id?: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTeamsInput
    roster?: RosterCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickCreateNestedManyWithoutTeamInput
    homeGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamUncheckedCreateWithoutOwnerInput = {
    id?: string
    leagueId: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterUncheckedCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutTeamInput
    homeGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferUncheckedCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferUncheckedCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamCreateOrConnectWithoutOwnerInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutOwnerInput, TeamUncheckedCreateWithoutOwnerInput>
  }

  export type TeamCreateManyOwnerInputEnvelope = {
    data: TeamCreateManyOwnerInput | TeamCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type LeagueCreateWithoutCommissionerInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsCreateNestedOneWithoutLeagueInput
    draft?: DraftCreateNestedOneWithoutLeagueInput
    games?: GameCreateNestedManyWithoutLeagueInput
    transactions?: TransactionCreateNestedManyWithoutLeagueInput
    messages?: MessageCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateWithoutCommissionerInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsUncheckedCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsUncheckedCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsUncheckedCreateNestedOneWithoutLeagueInput
    draft?: DraftUncheckedCreateNestedOneWithoutLeagueInput
    games?: GameUncheckedCreateNestedManyWithoutLeagueInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutLeagueInput
    messages?: MessageUncheckedCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutCommissionerInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutCommissionerInput, LeagueUncheckedCreateWithoutCommissionerInput>
  }

  export type LeagueCreateManyCommissionerInputEnvelope = {
    data: LeagueCreateManyCommissionerInput | LeagueCreateManyCommissionerInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    transactionType: $Enums.TransactionType
    week: number
    description?: string | null
    isProcessed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
    league: LeagueCreateNestedOneWithoutTransactionsInput
    team: TeamCreateNestedOneWithoutTransactionsInput
    player: PlayerCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    leagueId: string
    teamId: string
    playerId: string
    transactionType: $Enums.TransactionType
    week: number
    description?: string | null
    isProcessed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    recipientId?: string | null
    subject?: string | null
    content: string
    messageType?: $Enums.MessageType
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    league?: LeagueCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    leagueId?: string | null
    recipientId?: string | null
    subject?: string | null
    content: string
    messageType?: $Enums.MessageType
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type DraftPickCreateWithoutUserInput = {
    id?: string
    round: number
    pick: number
    pickInRound: number
    pickTime?: Date | string | null
    isKeeper?: boolean
    createdAt?: Date | string
    draft: DraftCreateNestedOneWithoutPicksInput
    team: TeamCreateNestedOneWithoutDraftPicksInput
    player?: PlayerCreateNestedOneWithoutDraftPicksInput
  }

  export type DraftPickUncheckedCreateWithoutUserInput = {
    id?: string
    draftId: string
    teamId: string
    playerId?: string | null
    round: number
    pick: number
    pickInRound: number
    pickTime?: Date | string | null
    isKeeper?: boolean
    createdAt?: Date | string
  }

  export type DraftPickCreateOrConnectWithoutUserInput = {
    where: DraftPickWhereUniqueInput
    create: XOR<DraftPickCreateWithoutUserInput, DraftPickUncheckedCreateWithoutUserInput>
  }

  export type DraftPickCreateManyUserInputEnvelope = {
    data: DraftPickCreateManyUserInput | DraftPickCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TradeOfferCreateWithoutOffererInput = {
    id?: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTradeOffersInput
    offeringTeam: TeamCreateNestedOneWithoutOfferedTradesInput
    targetTeam: TeamCreateNestedOneWithoutTargetedTradesInput
    target: UserCreateNestedOneWithoutTradeTargetsInput
    players?: TradeOfferPlayerCreateNestedManyWithoutTradeOfferInput
  }

  export type TradeOfferUncheckedCreateWithoutOffererInput = {
    id?: string
    leagueId: string
    offeringTeamId: string
    targetTeamId: string
    targetId: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: TradeOfferPlayerUncheckedCreateNestedManyWithoutTradeOfferInput
  }

  export type TradeOfferCreateOrConnectWithoutOffererInput = {
    where: TradeOfferWhereUniqueInput
    create: XOR<TradeOfferCreateWithoutOffererInput, TradeOfferUncheckedCreateWithoutOffererInput>
  }

  export type TradeOfferCreateManyOffererInputEnvelope = {
    data: TradeOfferCreateManyOffererInput | TradeOfferCreateManyOffererInput[]
    skipDuplicates?: boolean
  }

  export type TradeOfferCreateWithoutTargetInput = {
    id?: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTradeOffersInput
    offeringTeam: TeamCreateNestedOneWithoutOfferedTradesInput
    targetTeam: TeamCreateNestedOneWithoutTargetedTradesInput
    offerer: UserCreateNestedOneWithoutTradeOffersInput
    players?: TradeOfferPlayerCreateNestedManyWithoutTradeOfferInput
  }

  export type TradeOfferUncheckedCreateWithoutTargetInput = {
    id?: string
    leagueId: string
    offeringTeamId: string
    targetTeamId: string
    offererId: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: TradeOfferPlayerUncheckedCreateNestedManyWithoutTradeOfferInput
  }

  export type TradeOfferCreateOrConnectWithoutTargetInput = {
    where: TradeOfferWhereUniqueInput
    create: XOR<TradeOfferCreateWithoutTargetInput, TradeOfferUncheckedCreateWithoutTargetInput>
  }

  export type TradeOfferCreateManyTargetInputEnvelope = {
    data: TradeOfferCreateManyTargetInput | TradeOfferCreateManyTargetInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithWhereUniqueWithoutOwnerInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutOwnerInput, TeamUncheckedUpdateWithoutOwnerInput>
    create: XOR<TeamCreateWithoutOwnerInput, TeamUncheckedCreateWithoutOwnerInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutOwnerInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutOwnerInput, TeamUncheckedUpdateWithoutOwnerInput>
  }

  export type TeamUpdateManyWithWhereWithoutOwnerInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutOwnerInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    leagueId?: StringFilter<"Team"> | string
    ownerId?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    logoUrl?: StringNullableFilter<"Team"> | string | null
    wins?: IntFilter<"Team"> | number
    losses?: IntFilter<"Team"> | number
    ties?: IntFilter<"Team"> | number
    totalPoints?: DecimalFilter<"Team"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"Team"> | boolean
    waiverPriority?: IntFilter<"Team"> | number
    transactionCount?: IntFilter<"Team"> | number
    paidEntry?: BoolFilter<"Team"> | boolean
    amountOwed?: DecimalFilter<"Team"> | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFilter<"Team"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
  }

  export type LeagueUpsertWithWhereUniqueWithoutCommissionerInput = {
    where: LeagueWhereUniqueInput
    update: XOR<LeagueUpdateWithoutCommissionerInput, LeagueUncheckedUpdateWithoutCommissionerInput>
    create: XOR<LeagueCreateWithoutCommissionerInput, LeagueUncheckedCreateWithoutCommissionerInput>
  }

  export type LeagueUpdateWithWhereUniqueWithoutCommissionerInput = {
    where: LeagueWhereUniqueInput
    data: XOR<LeagueUpdateWithoutCommissionerInput, LeagueUncheckedUpdateWithoutCommissionerInput>
  }

  export type LeagueUpdateManyWithWhereWithoutCommissionerInput = {
    where: LeagueScalarWhereInput
    data: XOR<LeagueUpdateManyMutationInput, LeagueUncheckedUpdateManyWithoutCommissionerInput>
  }

  export type LeagueScalarWhereInput = {
    AND?: LeagueScalarWhereInput | LeagueScalarWhereInput[]
    OR?: LeagueScalarWhereInput[]
    NOT?: LeagueScalarWhereInput | LeagueScalarWhereInput[]
    id?: StringFilter<"League"> | string
    name?: StringFilter<"League"> | string
    password?: StringNullableFilter<"League"> | string | null
    customUrl?: StringNullableFilter<"League"> | string | null
    commissionerId?: StringFilter<"League"> | string
    maxTeams?: IntFilter<"League"> | number
    isActive?: BoolFilter<"League"> | boolean
    isPaid?: BoolFilter<"League"> | boolean
    entryFee?: DecimalNullableFilter<"League"> | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: DecimalNullableFilter<"League"> | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFilter<"League"> | $Enums.DraftType
    draftDate?: DateTimeNullableFilter<"League"> | Date | string | null
    seasonStartWeek?: IntFilter<"League"> | number
    leagueStartDate?: DateTimeNullableFilter<"League"> | Date | string | null
    rosterDeadline?: DateTimeNullableFilter<"League"> | Date | string | null
    maxAddsPerSeason?: IntNullableFilter<"League"> | number | null
    maxAddsPerWeek?: IntNullableFilter<"League"> | number | null
    tradeRejectTime?: IntFilter<"League"> | number
    tradeEndDate?: DateTimeNullableFilter<"League"> | Date | string | null
    waiverTime?: IntFilter<"League"> | number
    commissionerMessage?: StringNullableFilter<"League"> | string | null
    createdAt?: DateTimeFilter<"League"> | Date | string
    updatedAt?: DateTimeFilter<"League"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    leagueId?: StringFilter<"Transaction"> | string
    teamId?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    playerId?: StringFilter<"Transaction"> | string
    transactionType?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    week?: IntFilter<"Transaction"> | number
    description?: StringNullableFilter<"Transaction"> | string | null
    isProcessed?: BoolFilter<"Transaction"> | boolean
    processedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    leagueId?: StringNullableFilter<"Message"> | string | null
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringNullableFilter<"Message"> | string | null
    subject?: StringNullableFilter<"Message"> | string | null
    content?: StringFilter<"Message"> | string
    messageType?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    isRead?: BoolFilter<"Message"> | boolean
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type DraftPickUpsertWithWhereUniqueWithoutUserInput = {
    where: DraftPickWhereUniqueInput
    update: XOR<DraftPickUpdateWithoutUserInput, DraftPickUncheckedUpdateWithoutUserInput>
    create: XOR<DraftPickCreateWithoutUserInput, DraftPickUncheckedCreateWithoutUserInput>
  }

  export type DraftPickUpdateWithWhereUniqueWithoutUserInput = {
    where: DraftPickWhereUniqueInput
    data: XOR<DraftPickUpdateWithoutUserInput, DraftPickUncheckedUpdateWithoutUserInput>
  }

  export type DraftPickUpdateManyWithWhereWithoutUserInput = {
    where: DraftPickScalarWhereInput
    data: XOR<DraftPickUpdateManyMutationInput, DraftPickUncheckedUpdateManyWithoutUserInput>
  }

  export type DraftPickScalarWhereInput = {
    AND?: DraftPickScalarWhereInput | DraftPickScalarWhereInput[]
    OR?: DraftPickScalarWhereInput[]
    NOT?: DraftPickScalarWhereInput | DraftPickScalarWhereInput[]
    id?: StringFilter<"DraftPick"> | string
    draftId?: StringFilter<"DraftPick"> | string
    teamId?: StringFilter<"DraftPick"> | string
    userId?: StringFilter<"DraftPick"> | string
    playerId?: StringNullableFilter<"DraftPick"> | string | null
    round?: IntFilter<"DraftPick"> | number
    pick?: IntFilter<"DraftPick"> | number
    pickInRound?: IntFilter<"DraftPick"> | number
    pickTime?: DateTimeNullableFilter<"DraftPick"> | Date | string | null
    isKeeper?: BoolFilter<"DraftPick"> | boolean
    createdAt?: DateTimeFilter<"DraftPick"> | Date | string
  }

  export type TradeOfferUpsertWithWhereUniqueWithoutOffererInput = {
    where: TradeOfferWhereUniqueInput
    update: XOR<TradeOfferUpdateWithoutOffererInput, TradeOfferUncheckedUpdateWithoutOffererInput>
    create: XOR<TradeOfferCreateWithoutOffererInput, TradeOfferUncheckedCreateWithoutOffererInput>
  }

  export type TradeOfferUpdateWithWhereUniqueWithoutOffererInput = {
    where: TradeOfferWhereUniqueInput
    data: XOR<TradeOfferUpdateWithoutOffererInput, TradeOfferUncheckedUpdateWithoutOffererInput>
  }

  export type TradeOfferUpdateManyWithWhereWithoutOffererInput = {
    where: TradeOfferScalarWhereInput
    data: XOR<TradeOfferUpdateManyMutationInput, TradeOfferUncheckedUpdateManyWithoutOffererInput>
  }

  export type TradeOfferScalarWhereInput = {
    AND?: TradeOfferScalarWhereInput | TradeOfferScalarWhereInput[]
    OR?: TradeOfferScalarWhereInput[]
    NOT?: TradeOfferScalarWhereInput | TradeOfferScalarWhereInput[]
    id?: StringFilter<"TradeOffer"> | string
    leagueId?: StringFilter<"TradeOffer"> | string
    offeringTeamId?: StringFilter<"TradeOffer"> | string
    targetTeamId?: StringFilter<"TradeOffer"> | string
    offererId?: StringFilter<"TradeOffer"> | string
    targetId?: StringFilter<"TradeOffer"> | string
    status?: EnumTradeStatusFilter<"TradeOffer"> | $Enums.TradeStatus
    note?: StringNullableFilter<"TradeOffer"> | string | null
    expiresAt?: DateTimeNullableFilter<"TradeOffer"> | Date | string | null
    respondedAt?: DateTimeNullableFilter<"TradeOffer"> | Date | string | null
    createdAt?: DateTimeFilter<"TradeOffer"> | Date | string
    updatedAt?: DateTimeFilter<"TradeOffer"> | Date | string
  }

  export type TradeOfferUpsertWithWhereUniqueWithoutTargetInput = {
    where: TradeOfferWhereUniqueInput
    update: XOR<TradeOfferUpdateWithoutTargetInput, TradeOfferUncheckedUpdateWithoutTargetInput>
    create: XOR<TradeOfferCreateWithoutTargetInput, TradeOfferUncheckedCreateWithoutTargetInput>
  }

  export type TradeOfferUpdateWithWhereUniqueWithoutTargetInput = {
    where: TradeOfferWhereUniqueInput
    data: XOR<TradeOfferUpdateWithoutTargetInput, TradeOfferUncheckedUpdateWithoutTargetInput>
  }

  export type TradeOfferUpdateManyWithWhereWithoutTargetInput = {
    where: TradeOfferScalarWhereInput
    data: XOR<TradeOfferUpdateManyMutationInput, TradeOfferUncheckedUpdateManyWithoutTargetInput>
  }

  export type UserCreateWithoutLeaguesCommissionedInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamsOwned?: TeamCreateNestedManyWithoutOwnerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    draftPicks?: DraftPickCreateNestedManyWithoutUserInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutOffererInput
    tradeTargets?: TradeOfferCreateNestedManyWithoutTargetInput
  }

  export type UserUncheckedCreateWithoutLeaguesCommissionedInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamsOwned?: TeamUncheckedCreateNestedManyWithoutOwnerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutUserInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutOffererInput
    tradeTargets?: TradeOfferUncheckedCreateNestedManyWithoutTargetInput
  }

  export type UserCreateOrConnectWithoutLeaguesCommissionedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaguesCommissionedInput, UserUncheckedCreateWithoutLeaguesCommissionedInput>
  }

  export type TeamCreateWithoutLeagueInput = {
    id?: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutTeamsOwnedInput
    roster?: RosterCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickCreateNestedManyWithoutTeamInput
    homeGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamUncheckedCreateWithoutLeagueInput = {
    id?: string
    ownerId: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterUncheckedCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutTeamInput
    homeGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferUncheckedCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferUncheckedCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamCreateOrConnectWithoutLeagueInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput>
  }

  export type TeamCreateManyLeagueInputEnvelope = {
    data: TeamCreateManyLeagueInput | TeamCreateManyLeagueInput[]
    skipDuplicates?: boolean
  }

  export type LeagueSettingsCreateWithoutLeagueInput = {
    id?: string
    scoringType?: $Enums.ScoringType
    hasDivisions?: boolean
    playoffTeams?: number
    playoffStartWeek?: number
    canTradeDraftPicks?: boolean
    tradeReviewType?: $Enums.TradeReviewType
    waiverType?: $Enums.WaiverType
    cantCutList?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeagueSettingsUncheckedCreateWithoutLeagueInput = {
    id?: string
    scoringType?: $Enums.ScoringType
    hasDivisions?: boolean
    playoffTeams?: number
    playoffStartWeek?: number
    canTradeDraftPicks?: boolean
    tradeReviewType?: $Enums.TradeReviewType
    waiverType?: $Enums.WaiverType
    cantCutList?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeagueSettingsCreateOrConnectWithoutLeagueInput = {
    where: LeagueSettingsWhereUniqueInput
    create: XOR<LeagueSettingsCreateWithoutLeagueInput, LeagueSettingsUncheckedCreateWithoutLeagueInput>
  }

  export type ScoringSettingsCreateWithoutLeagueInput = {
    id?: string
    passingYards?: Decimal | DecimalJsLike | number | string
    passingTds?: Decimal | DecimalJsLike | number | string
    passingInts?: Decimal | DecimalJsLike | number | string
    rushingYards?: Decimal | DecimalJsLike | number | string
    rushingTds?: Decimal | DecimalJsLike | number | string
    receivingYards?: Decimal | DecimalJsLike | number | string
    receivingTds?: Decimal | DecimalJsLike | number | string
    receptions?: Decimal | DecimalJsLike | number | string
    fumbles?: Decimal | DecimalJsLike | number | string
    fieldGoals?: Decimal | DecimalJsLike | number | string
    extraPoints?: Decimal | DecimalJsLike | number | string
    sacks?: Decimal | DecimalJsLike | number | string
    interceptions?: Decimal | DecimalJsLike | number | string
    fumbleRecoveries?: Decimal | DecimalJsLike | number | string
    safeties?: Decimal | DecimalJsLike | number | string
    defensiveTds?: Decimal | DecimalJsLike | number | string
    pointsAllowed0?: Decimal | DecimalJsLike | number | string
    pointsAllowed1to6?: Decimal | DecimalJsLike | number | string
    pointsAllowed7to13?: Decimal | DecimalJsLike | number | string
    pointsAllowed14to20?: Decimal | DecimalJsLike | number | string
    pointsAllowed21to27?: Decimal | DecimalJsLike | number | string
    pointsAllowed28plus?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScoringSettingsUncheckedCreateWithoutLeagueInput = {
    id?: string
    passingYards?: Decimal | DecimalJsLike | number | string
    passingTds?: Decimal | DecimalJsLike | number | string
    passingInts?: Decimal | DecimalJsLike | number | string
    rushingYards?: Decimal | DecimalJsLike | number | string
    rushingTds?: Decimal | DecimalJsLike | number | string
    receivingYards?: Decimal | DecimalJsLike | number | string
    receivingTds?: Decimal | DecimalJsLike | number | string
    receptions?: Decimal | DecimalJsLike | number | string
    fumbles?: Decimal | DecimalJsLike | number | string
    fieldGoals?: Decimal | DecimalJsLike | number | string
    extraPoints?: Decimal | DecimalJsLike | number | string
    sacks?: Decimal | DecimalJsLike | number | string
    interceptions?: Decimal | DecimalJsLike | number | string
    fumbleRecoveries?: Decimal | DecimalJsLike | number | string
    safeties?: Decimal | DecimalJsLike | number | string
    defensiveTds?: Decimal | DecimalJsLike | number | string
    pointsAllowed0?: Decimal | DecimalJsLike | number | string
    pointsAllowed1to6?: Decimal | DecimalJsLike | number | string
    pointsAllowed7to13?: Decimal | DecimalJsLike | number | string
    pointsAllowed14to20?: Decimal | DecimalJsLike | number | string
    pointsAllowed21to27?: Decimal | DecimalJsLike | number | string
    pointsAllowed28plus?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScoringSettingsCreateOrConnectWithoutLeagueInput = {
    where: ScoringSettingsWhereUniqueInput
    create: XOR<ScoringSettingsCreateWithoutLeagueInput, ScoringSettingsUncheckedCreateWithoutLeagueInput>
  }

  export type RosterSettingsCreateWithoutLeagueInput = {
    id?: string
    qbSlots?: number
    rbSlots?: number
    wrSlots?: number
    teSlots?: number
    flexSlots?: number
    kSlots?: number
    defSlots?: number
    benchSlots?: number
    irSlots?: number
    maxRosterSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RosterSettingsUncheckedCreateWithoutLeagueInput = {
    id?: string
    qbSlots?: number
    rbSlots?: number
    wrSlots?: number
    teSlots?: number
    flexSlots?: number
    kSlots?: number
    defSlots?: number
    benchSlots?: number
    irSlots?: number
    maxRosterSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RosterSettingsCreateOrConnectWithoutLeagueInput = {
    where: RosterSettingsWhereUniqueInput
    create: XOR<RosterSettingsCreateWithoutLeagueInput, RosterSettingsUncheckedCreateWithoutLeagueInput>
  }

  export type DraftCreateWithoutLeagueInput = {
    id?: string
    draftType: $Enums.DraftType
    draftDate?: Date | string | null
    isComplete?: boolean
    currentRound?: number
    currentPick?: number
    timePerPick?: number
    draftOrder?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    picks?: DraftPickCreateNestedManyWithoutDraftInput
  }

  export type DraftUncheckedCreateWithoutLeagueInput = {
    id?: string
    draftType: $Enums.DraftType
    draftDate?: Date | string | null
    isComplete?: boolean
    currentRound?: number
    currentPick?: number
    timePerPick?: number
    draftOrder?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    picks?: DraftPickUncheckedCreateNestedManyWithoutDraftInput
  }

  export type DraftCreateOrConnectWithoutLeagueInput = {
    where: DraftWhereUniqueInput
    create: XOR<DraftCreateWithoutLeagueInput, DraftUncheckedCreateWithoutLeagueInput>
  }

  export type GameCreateWithoutLeagueInput = {
    id?: string
    week: number
    season?: number
    homeScore?: Decimal | DecimalJsLike | number | string
    awayScore?: Decimal | DecimalJsLike | number | string
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    homeTeam: TeamCreateNestedOneWithoutHomeGamesInput
    awayTeam: TeamCreateNestedOneWithoutAwayGamesInput
  }

  export type GameUncheckedCreateWithoutLeagueInput = {
    id?: string
    homeTeamId: string
    awayTeamId: string
    week: number
    season?: number
    homeScore?: Decimal | DecimalJsLike | number | string
    awayScore?: Decimal | DecimalJsLike | number | string
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCreateOrConnectWithoutLeagueInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput>
  }

  export type GameCreateManyLeagueInputEnvelope = {
    data: GameCreateManyLeagueInput | GameCreateManyLeagueInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutLeagueInput = {
    id?: string
    transactionType: $Enums.TransactionType
    week: number
    description?: string | null
    isProcessed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutTransactionsInput
    user: UserCreateNestedOneWithoutTransactionsInput
    player: PlayerCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutLeagueInput = {
    id?: string
    teamId: string
    userId: string
    playerId: string
    transactionType: $Enums.TransactionType
    week: number
    description?: string | null
    isProcessed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutLeagueInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutLeagueInput, TransactionUncheckedCreateWithoutLeagueInput>
  }

  export type TransactionCreateManyLeagueInputEnvelope = {
    data: TransactionCreateManyLeagueInput | TransactionCreateManyLeagueInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutLeagueInput = {
    id?: string
    recipientId?: string | null
    subject?: string | null
    content: string
    messageType?: $Enums.MessageType
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutLeagueInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    subject?: string | null
    content: string
    messageType?: $Enums.MessageType
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutLeagueInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutLeagueInput, MessageUncheckedCreateWithoutLeagueInput>
  }

  export type MessageCreateManyLeagueInputEnvelope = {
    data: MessageCreateManyLeagueInput | MessageCreateManyLeagueInput[]
    skipDuplicates?: boolean
  }

  export type TradeOfferCreateWithoutLeagueInput = {
    id?: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offeringTeam: TeamCreateNestedOneWithoutOfferedTradesInput
    targetTeam: TeamCreateNestedOneWithoutTargetedTradesInput
    offerer: UserCreateNestedOneWithoutTradeOffersInput
    target: UserCreateNestedOneWithoutTradeTargetsInput
    players?: TradeOfferPlayerCreateNestedManyWithoutTradeOfferInput
  }

  export type TradeOfferUncheckedCreateWithoutLeagueInput = {
    id?: string
    offeringTeamId: string
    targetTeamId: string
    offererId: string
    targetId: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: TradeOfferPlayerUncheckedCreateNestedManyWithoutTradeOfferInput
  }

  export type TradeOfferCreateOrConnectWithoutLeagueInput = {
    where: TradeOfferWhereUniqueInput
    create: XOR<TradeOfferCreateWithoutLeagueInput, TradeOfferUncheckedCreateWithoutLeagueInput>
  }

  export type TradeOfferCreateManyLeagueInputEnvelope = {
    data: TradeOfferCreateManyLeagueInput | TradeOfferCreateManyLeagueInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLeaguesCommissionedInput = {
    update: XOR<UserUpdateWithoutLeaguesCommissionedInput, UserUncheckedUpdateWithoutLeaguesCommissionedInput>
    create: XOR<UserCreateWithoutLeaguesCommissionedInput, UserUncheckedCreateWithoutLeaguesCommissionedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaguesCommissionedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaguesCommissionedInput, UserUncheckedUpdateWithoutLeaguesCommissionedInput>
  }

  export type UserUpdateWithoutLeaguesCommissionedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamsOwned?: TeamUpdateManyWithoutOwnerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    draftPicks?: DraftPickUpdateManyWithoutUserNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutOffererNestedInput
    tradeTargets?: TradeOfferUpdateManyWithoutTargetNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaguesCommissionedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamsOwned?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutUserNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutOffererNestedInput
    tradeTargets?: TradeOfferUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type TeamUpsertWithWhereUniqueWithoutLeagueInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutLeagueInput, TeamUncheckedUpdateWithoutLeagueInput>
    create: XOR<TeamCreateWithoutLeagueInput, TeamUncheckedCreateWithoutLeagueInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutLeagueInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutLeagueInput, TeamUncheckedUpdateWithoutLeagueInput>
  }

  export type TeamUpdateManyWithWhereWithoutLeagueInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutLeagueInput>
  }

  export type LeagueSettingsUpsertWithoutLeagueInput = {
    update: XOR<LeagueSettingsUpdateWithoutLeagueInput, LeagueSettingsUncheckedUpdateWithoutLeagueInput>
    create: XOR<LeagueSettingsCreateWithoutLeagueInput, LeagueSettingsUncheckedCreateWithoutLeagueInput>
    where?: LeagueSettingsWhereInput
  }

  export type LeagueSettingsUpdateToOneWithWhereWithoutLeagueInput = {
    where?: LeagueSettingsWhereInput
    data: XOR<LeagueSettingsUpdateWithoutLeagueInput, LeagueSettingsUncheckedUpdateWithoutLeagueInput>
  }

  export type LeagueSettingsUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    scoringType?: EnumScoringTypeFieldUpdateOperationsInput | $Enums.ScoringType
    hasDivisions?: BoolFieldUpdateOperationsInput | boolean
    playoffTeams?: IntFieldUpdateOperationsInput | number
    playoffStartWeek?: IntFieldUpdateOperationsInput | number
    canTradeDraftPicks?: BoolFieldUpdateOperationsInput | boolean
    tradeReviewType?: EnumTradeReviewTypeFieldUpdateOperationsInput | $Enums.TradeReviewType
    waiverType?: EnumWaiverTypeFieldUpdateOperationsInput | $Enums.WaiverType
    cantCutList?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueSettingsUncheckedUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    scoringType?: EnumScoringTypeFieldUpdateOperationsInput | $Enums.ScoringType
    hasDivisions?: BoolFieldUpdateOperationsInput | boolean
    playoffTeams?: IntFieldUpdateOperationsInput | number
    playoffStartWeek?: IntFieldUpdateOperationsInput | number
    canTradeDraftPicks?: BoolFieldUpdateOperationsInput | boolean
    tradeReviewType?: EnumTradeReviewTypeFieldUpdateOperationsInput | $Enums.TradeReviewType
    waiverType?: EnumWaiverTypeFieldUpdateOperationsInput | $Enums.WaiverType
    cantCutList?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoringSettingsUpsertWithoutLeagueInput = {
    update: XOR<ScoringSettingsUpdateWithoutLeagueInput, ScoringSettingsUncheckedUpdateWithoutLeagueInput>
    create: XOR<ScoringSettingsCreateWithoutLeagueInput, ScoringSettingsUncheckedCreateWithoutLeagueInput>
    where?: ScoringSettingsWhereInput
  }

  export type ScoringSettingsUpdateToOneWithWhereWithoutLeagueInput = {
    where?: ScoringSettingsWhereInput
    data: XOR<ScoringSettingsUpdateWithoutLeagueInput, ScoringSettingsUncheckedUpdateWithoutLeagueInput>
  }

  export type ScoringSettingsUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    passingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passingInts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rushingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rushingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fumbles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fieldGoals?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    extraPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sacks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interceptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fumbleRecoveries?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    safeties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defensiveTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed0?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed1to6?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed7to13?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed14to20?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed21to27?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed28plus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoringSettingsUncheckedUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    passingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passingInts?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rushingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rushingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fumbles?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fieldGoals?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    extraPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sacks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interceptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fumbleRecoveries?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    safeties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defensiveTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed0?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed1to6?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed7to13?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed14to20?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed21to27?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pointsAllowed28plus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RosterSettingsUpsertWithoutLeagueInput = {
    update: XOR<RosterSettingsUpdateWithoutLeagueInput, RosterSettingsUncheckedUpdateWithoutLeagueInput>
    create: XOR<RosterSettingsCreateWithoutLeagueInput, RosterSettingsUncheckedCreateWithoutLeagueInput>
    where?: RosterSettingsWhereInput
  }

  export type RosterSettingsUpdateToOneWithWhereWithoutLeagueInput = {
    where?: RosterSettingsWhereInput
    data: XOR<RosterSettingsUpdateWithoutLeagueInput, RosterSettingsUncheckedUpdateWithoutLeagueInput>
  }

  export type RosterSettingsUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    qbSlots?: IntFieldUpdateOperationsInput | number
    rbSlots?: IntFieldUpdateOperationsInput | number
    wrSlots?: IntFieldUpdateOperationsInput | number
    teSlots?: IntFieldUpdateOperationsInput | number
    flexSlots?: IntFieldUpdateOperationsInput | number
    kSlots?: IntFieldUpdateOperationsInput | number
    defSlots?: IntFieldUpdateOperationsInput | number
    benchSlots?: IntFieldUpdateOperationsInput | number
    irSlots?: IntFieldUpdateOperationsInput | number
    maxRosterSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RosterSettingsUncheckedUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    qbSlots?: IntFieldUpdateOperationsInput | number
    rbSlots?: IntFieldUpdateOperationsInput | number
    wrSlots?: IntFieldUpdateOperationsInput | number
    teSlots?: IntFieldUpdateOperationsInput | number
    flexSlots?: IntFieldUpdateOperationsInput | number
    kSlots?: IntFieldUpdateOperationsInput | number
    defSlots?: IntFieldUpdateOperationsInput | number
    benchSlots?: IntFieldUpdateOperationsInput | number
    irSlots?: IntFieldUpdateOperationsInput | number
    maxRosterSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftUpsertWithoutLeagueInput = {
    update: XOR<DraftUpdateWithoutLeagueInput, DraftUncheckedUpdateWithoutLeagueInput>
    create: XOR<DraftCreateWithoutLeagueInput, DraftUncheckedCreateWithoutLeagueInput>
    where?: DraftWhereInput
  }

  export type DraftUpdateToOneWithWhereWithoutLeagueInput = {
    where?: DraftWhereInput
    data: XOR<DraftUpdateWithoutLeagueInput, DraftUncheckedUpdateWithoutLeagueInput>
  }

  export type DraftUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    currentRound?: IntFieldUpdateOperationsInput | number
    currentPick?: IntFieldUpdateOperationsInput | number
    timePerPick?: IntFieldUpdateOperationsInput | number
    draftOrder?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    picks?: DraftPickUpdateManyWithoutDraftNestedInput
  }

  export type DraftUncheckedUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    currentRound?: IntFieldUpdateOperationsInput | number
    currentPick?: IntFieldUpdateOperationsInput | number
    timePerPick?: IntFieldUpdateOperationsInput | number
    draftOrder?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    picks?: DraftPickUncheckedUpdateManyWithoutDraftNestedInput
  }

  export type GameUpsertWithWhereUniqueWithoutLeagueInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutLeagueInput, GameUncheckedUpdateWithoutLeagueInput>
    create: XOR<GameCreateWithoutLeagueInput, GameUncheckedCreateWithoutLeagueInput>
  }

  export type GameUpdateWithWhereUniqueWithoutLeagueInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutLeagueInput, GameUncheckedUpdateWithoutLeagueInput>
  }

  export type GameUpdateManyWithWhereWithoutLeagueInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutLeagueInput>
  }

  export type GameScalarWhereInput = {
    AND?: GameScalarWhereInput | GameScalarWhereInput[]
    OR?: GameScalarWhereInput[]
    NOT?: GameScalarWhereInput | GameScalarWhereInput[]
    id?: StringFilter<"Game"> | string
    leagueId?: StringFilter<"Game"> | string
    homeTeamId?: StringFilter<"Game"> | string
    awayTeamId?: StringFilter<"Game"> | string
    week?: IntFilter<"Game"> | number
    season?: IntFilter<"Game"> | number
    homeScore?: DecimalFilter<"Game"> | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFilter<"Game"> | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFilter<"Game"> | boolean
    isPlayoffs?: BoolFilter<"Game"> | boolean
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutLeagueInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutLeagueInput, TransactionUncheckedUpdateWithoutLeagueInput>
    create: XOR<TransactionCreateWithoutLeagueInput, TransactionUncheckedCreateWithoutLeagueInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutLeagueInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutLeagueInput, TransactionUncheckedUpdateWithoutLeagueInput>
  }

  export type TransactionUpdateManyWithWhereWithoutLeagueInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutLeagueInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutLeagueInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutLeagueInput, MessageUncheckedUpdateWithoutLeagueInput>
    create: XOR<MessageCreateWithoutLeagueInput, MessageUncheckedCreateWithoutLeagueInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutLeagueInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutLeagueInput, MessageUncheckedUpdateWithoutLeagueInput>
  }

  export type MessageUpdateManyWithWhereWithoutLeagueInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutLeagueInput>
  }

  export type TradeOfferUpsertWithWhereUniqueWithoutLeagueInput = {
    where: TradeOfferWhereUniqueInput
    update: XOR<TradeOfferUpdateWithoutLeagueInput, TradeOfferUncheckedUpdateWithoutLeagueInput>
    create: XOR<TradeOfferCreateWithoutLeagueInput, TradeOfferUncheckedCreateWithoutLeagueInput>
  }

  export type TradeOfferUpdateWithWhereUniqueWithoutLeagueInput = {
    where: TradeOfferWhereUniqueInput
    data: XOR<TradeOfferUpdateWithoutLeagueInput, TradeOfferUncheckedUpdateWithoutLeagueInput>
  }

  export type TradeOfferUpdateManyWithWhereWithoutLeagueInput = {
    where: TradeOfferScalarWhereInput
    data: XOR<TradeOfferUpdateManyMutationInput, TradeOfferUncheckedUpdateManyWithoutLeagueInput>
  }

  export type LeagueCreateWithoutLeagueSettingsInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissioner: UserCreateNestedOneWithoutLeaguesCommissionedInput
    teams?: TeamCreateNestedManyWithoutLeagueInput
    scoringSettings?: ScoringSettingsCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsCreateNestedOneWithoutLeagueInput
    draft?: DraftCreateNestedOneWithoutLeagueInput
    games?: GameCreateNestedManyWithoutLeagueInput
    transactions?: TransactionCreateNestedManyWithoutLeagueInput
    messages?: MessageCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateWithoutLeagueSettingsInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    commissionerId: string
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    scoringSettings?: ScoringSettingsUncheckedCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsUncheckedCreateNestedOneWithoutLeagueInput
    draft?: DraftUncheckedCreateNestedOneWithoutLeagueInput
    games?: GameUncheckedCreateNestedManyWithoutLeagueInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutLeagueInput
    messages?: MessageUncheckedCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutLeagueSettingsInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutLeagueSettingsInput, LeagueUncheckedCreateWithoutLeagueSettingsInput>
  }

  export type LeagueUpsertWithoutLeagueSettingsInput = {
    update: XOR<LeagueUpdateWithoutLeagueSettingsInput, LeagueUncheckedUpdateWithoutLeagueSettingsInput>
    create: XOR<LeagueCreateWithoutLeagueSettingsInput, LeagueUncheckedCreateWithoutLeagueSettingsInput>
    where?: LeagueWhereInput
  }

  export type LeagueUpdateToOneWithWhereWithoutLeagueSettingsInput = {
    where?: LeagueWhereInput
    data: XOR<LeagueUpdateWithoutLeagueSettingsInput, LeagueUncheckedUpdateWithoutLeagueSettingsInput>
  }

  export type LeagueUpdateWithoutLeagueSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissioner?: UserUpdateOneRequiredWithoutLeaguesCommissionedNestedInput
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUpdateOneWithoutLeagueNestedInput
    draft?: DraftUpdateOneWithoutLeagueNestedInput
    games?: GameUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUpdateManyWithoutLeagueNestedInput
    messages?: MessageUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateWithoutLeagueSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    commissionerId?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    draft?: DraftUncheckedUpdateOneWithoutLeagueNestedInput
    games?: GameUncheckedUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutLeagueNestedInput
    messages?: MessageUncheckedUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueCreateWithoutScoringSettingsInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissioner: UserCreateNestedOneWithoutLeaguesCommissionedInput
    teams?: TeamCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsCreateNestedOneWithoutLeagueInput
    draft?: DraftCreateNestedOneWithoutLeagueInput
    games?: GameCreateNestedManyWithoutLeagueInput
    transactions?: TransactionCreateNestedManyWithoutLeagueInput
    messages?: MessageCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateWithoutScoringSettingsInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    commissionerId: string
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsUncheckedCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsUncheckedCreateNestedOneWithoutLeagueInput
    draft?: DraftUncheckedCreateNestedOneWithoutLeagueInput
    games?: GameUncheckedCreateNestedManyWithoutLeagueInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutLeagueInput
    messages?: MessageUncheckedCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutScoringSettingsInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutScoringSettingsInput, LeagueUncheckedCreateWithoutScoringSettingsInput>
  }

  export type LeagueUpsertWithoutScoringSettingsInput = {
    update: XOR<LeagueUpdateWithoutScoringSettingsInput, LeagueUncheckedUpdateWithoutScoringSettingsInput>
    create: XOR<LeagueCreateWithoutScoringSettingsInput, LeagueUncheckedCreateWithoutScoringSettingsInput>
    where?: LeagueWhereInput
  }

  export type LeagueUpdateToOneWithWhereWithoutScoringSettingsInput = {
    where?: LeagueWhereInput
    data: XOR<LeagueUpdateWithoutScoringSettingsInput, LeagueUncheckedUpdateWithoutScoringSettingsInput>
  }

  export type LeagueUpdateWithoutScoringSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissioner?: UserUpdateOneRequiredWithoutLeaguesCommissionedNestedInput
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUpdateOneWithoutLeagueNestedInput
    draft?: DraftUpdateOneWithoutLeagueNestedInput
    games?: GameUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUpdateManyWithoutLeagueNestedInput
    messages?: MessageUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateWithoutScoringSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    commissionerId?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    draft?: DraftUncheckedUpdateOneWithoutLeagueNestedInput
    games?: GameUncheckedUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutLeagueNestedInput
    messages?: MessageUncheckedUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueCreateWithoutRosterSettingsInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissioner: UserCreateNestedOneWithoutLeaguesCommissionedInput
    teams?: TeamCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsCreateNestedOneWithoutLeagueInput
    draft?: DraftCreateNestedOneWithoutLeagueInput
    games?: GameCreateNestedManyWithoutLeagueInput
    transactions?: TransactionCreateNestedManyWithoutLeagueInput
    messages?: MessageCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateWithoutRosterSettingsInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    commissionerId: string
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsUncheckedCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsUncheckedCreateNestedOneWithoutLeagueInput
    draft?: DraftUncheckedCreateNestedOneWithoutLeagueInput
    games?: GameUncheckedCreateNestedManyWithoutLeagueInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutLeagueInput
    messages?: MessageUncheckedCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutRosterSettingsInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutRosterSettingsInput, LeagueUncheckedCreateWithoutRosterSettingsInput>
  }

  export type LeagueUpsertWithoutRosterSettingsInput = {
    update: XOR<LeagueUpdateWithoutRosterSettingsInput, LeagueUncheckedUpdateWithoutRosterSettingsInput>
    create: XOR<LeagueCreateWithoutRosterSettingsInput, LeagueUncheckedCreateWithoutRosterSettingsInput>
    where?: LeagueWhereInput
  }

  export type LeagueUpdateToOneWithWhereWithoutRosterSettingsInput = {
    where?: LeagueWhereInput
    data: XOR<LeagueUpdateWithoutRosterSettingsInput, LeagueUncheckedUpdateWithoutRosterSettingsInput>
  }

  export type LeagueUpdateWithoutRosterSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissioner?: UserUpdateOneRequiredWithoutLeaguesCommissionedNestedInput
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUpdateOneWithoutLeagueNestedInput
    draft?: DraftUpdateOneWithoutLeagueNestedInput
    games?: GameUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUpdateManyWithoutLeagueNestedInput
    messages?: MessageUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateWithoutRosterSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    commissionerId?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    draft?: DraftUncheckedUpdateOneWithoutLeagueNestedInput
    games?: GameUncheckedUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutLeagueNestedInput
    messages?: MessageUncheckedUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueCreateWithoutTeamsInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissioner: UserCreateNestedOneWithoutLeaguesCommissionedInput
    leagueSettings?: LeagueSettingsCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsCreateNestedOneWithoutLeagueInput
    draft?: DraftCreateNestedOneWithoutLeagueInput
    games?: GameCreateNestedManyWithoutLeagueInput
    transactions?: TransactionCreateNestedManyWithoutLeagueInput
    messages?: MessageCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateWithoutTeamsInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    commissionerId: string
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leagueSettings?: LeagueSettingsUncheckedCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsUncheckedCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsUncheckedCreateNestedOneWithoutLeagueInput
    draft?: DraftUncheckedCreateNestedOneWithoutLeagueInput
    games?: GameUncheckedCreateNestedManyWithoutLeagueInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutLeagueInput
    messages?: MessageUncheckedCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutTeamsInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutTeamsInput, LeagueUncheckedCreateWithoutTeamsInput>
  }

  export type UserCreateWithoutTeamsOwnedInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leaguesCommissioned?: LeagueCreateNestedManyWithoutCommissionerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    draftPicks?: DraftPickCreateNestedManyWithoutUserInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutOffererInput
    tradeTargets?: TradeOfferCreateNestedManyWithoutTargetInput
  }

  export type UserUncheckedCreateWithoutTeamsOwnedInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leaguesCommissioned?: LeagueUncheckedCreateNestedManyWithoutCommissionerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutUserInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutOffererInput
    tradeTargets?: TradeOfferUncheckedCreateNestedManyWithoutTargetInput
  }

  export type UserCreateOrConnectWithoutTeamsOwnedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamsOwnedInput, UserUncheckedCreateWithoutTeamsOwnedInput>
  }

  export type RosterCreateWithoutTeamInput = {
    id?: string
    position?: $Enums.RosterPosition
    isStarter?: boolean
    acquiredDate?: Date | string
    weekAdded?: number | null
    player: PlayerCreateNestedOneWithoutRosterInput
  }

  export type RosterUncheckedCreateWithoutTeamInput = {
    id?: string
    playerId: string
    position?: $Enums.RosterPosition
    isStarter?: boolean
    acquiredDate?: Date | string
    weekAdded?: number | null
  }

  export type RosterCreateOrConnectWithoutTeamInput = {
    where: RosterWhereUniqueInput
    create: XOR<RosterCreateWithoutTeamInput, RosterUncheckedCreateWithoutTeamInput>
  }

  export type RosterCreateManyTeamInputEnvelope = {
    data: RosterCreateManyTeamInput | RosterCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type DraftPickCreateWithoutTeamInput = {
    id?: string
    round: number
    pick: number
    pickInRound: number
    pickTime?: Date | string | null
    isKeeper?: boolean
    createdAt?: Date | string
    draft: DraftCreateNestedOneWithoutPicksInput
    user: UserCreateNestedOneWithoutDraftPicksInput
    player?: PlayerCreateNestedOneWithoutDraftPicksInput
  }

  export type DraftPickUncheckedCreateWithoutTeamInput = {
    id?: string
    draftId: string
    userId: string
    playerId?: string | null
    round: number
    pick: number
    pickInRound: number
    pickTime?: Date | string | null
    isKeeper?: boolean
    createdAt?: Date | string
  }

  export type DraftPickCreateOrConnectWithoutTeamInput = {
    where: DraftPickWhereUniqueInput
    create: XOR<DraftPickCreateWithoutTeamInput, DraftPickUncheckedCreateWithoutTeamInput>
  }

  export type DraftPickCreateManyTeamInputEnvelope = {
    data: DraftPickCreateManyTeamInput | DraftPickCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutHomeTeamInput = {
    id?: string
    week: number
    season?: number
    homeScore?: Decimal | DecimalJsLike | number | string
    awayScore?: Decimal | DecimalJsLike | number | string
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutGamesInput
    awayTeam: TeamCreateNestedOneWithoutAwayGamesInput
  }

  export type GameUncheckedCreateWithoutHomeTeamInput = {
    id?: string
    leagueId: string
    awayTeamId: string
    week: number
    season?: number
    homeScore?: Decimal | DecimalJsLike | number | string
    awayScore?: Decimal | DecimalJsLike | number | string
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCreateOrConnectWithoutHomeTeamInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput>
  }

  export type GameCreateManyHomeTeamInputEnvelope = {
    data: GameCreateManyHomeTeamInput | GameCreateManyHomeTeamInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutAwayTeamInput = {
    id?: string
    week: number
    season?: number
    homeScore?: Decimal | DecimalJsLike | number | string
    awayScore?: Decimal | DecimalJsLike | number | string
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutGamesInput
    homeTeam: TeamCreateNestedOneWithoutHomeGamesInput
  }

  export type GameUncheckedCreateWithoutAwayTeamInput = {
    id?: string
    leagueId: string
    homeTeamId: string
    week: number
    season?: number
    homeScore?: Decimal | DecimalJsLike | number | string
    awayScore?: Decimal | DecimalJsLike | number | string
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCreateOrConnectWithoutAwayTeamInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput>
  }

  export type GameCreateManyAwayTeamInputEnvelope = {
    data: GameCreateManyAwayTeamInput | GameCreateManyAwayTeamInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutTeamInput = {
    id?: string
    transactionType: $Enums.TransactionType
    week: number
    description?: string | null
    isProcessed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
    league: LeagueCreateNestedOneWithoutTransactionsInput
    user: UserCreateNestedOneWithoutTransactionsInput
    player: PlayerCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutTeamInput = {
    id?: string
    leagueId: string
    userId: string
    playerId: string
    transactionType: $Enums.TransactionType
    week: number
    description?: string | null
    isProcessed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutTeamInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutTeamInput, TransactionUncheckedCreateWithoutTeamInput>
  }

  export type TransactionCreateManyTeamInputEnvelope = {
    data: TransactionCreateManyTeamInput | TransactionCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TradeOfferCreateWithoutOfferingTeamInput = {
    id?: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTradeOffersInput
    targetTeam: TeamCreateNestedOneWithoutTargetedTradesInput
    offerer: UserCreateNestedOneWithoutTradeOffersInput
    target: UserCreateNestedOneWithoutTradeTargetsInput
    players?: TradeOfferPlayerCreateNestedManyWithoutTradeOfferInput
  }

  export type TradeOfferUncheckedCreateWithoutOfferingTeamInput = {
    id?: string
    leagueId: string
    targetTeamId: string
    offererId: string
    targetId: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: TradeOfferPlayerUncheckedCreateNestedManyWithoutTradeOfferInput
  }

  export type TradeOfferCreateOrConnectWithoutOfferingTeamInput = {
    where: TradeOfferWhereUniqueInput
    create: XOR<TradeOfferCreateWithoutOfferingTeamInput, TradeOfferUncheckedCreateWithoutOfferingTeamInput>
  }

  export type TradeOfferCreateManyOfferingTeamInputEnvelope = {
    data: TradeOfferCreateManyOfferingTeamInput | TradeOfferCreateManyOfferingTeamInput[]
    skipDuplicates?: boolean
  }

  export type TradeOfferCreateWithoutTargetTeamInput = {
    id?: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTradeOffersInput
    offeringTeam: TeamCreateNestedOneWithoutOfferedTradesInput
    offerer: UserCreateNestedOneWithoutTradeOffersInput
    target: UserCreateNestedOneWithoutTradeTargetsInput
    players?: TradeOfferPlayerCreateNestedManyWithoutTradeOfferInput
  }

  export type TradeOfferUncheckedCreateWithoutTargetTeamInput = {
    id?: string
    leagueId: string
    offeringTeamId: string
    offererId: string
    targetId: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: TradeOfferPlayerUncheckedCreateNestedManyWithoutTradeOfferInput
  }

  export type TradeOfferCreateOrConnectWithoutTargetTeamInput = {
    where: TradeOfferWhereUniqueInput
    create: XOR<TradeOfferCreateWithoutTargetTeamInput, TradeOfferUncheckedCreateWithoutTargetTeamInput>
  }

  export type TradeOfferCreateManyTargetTeamInputEnvelope = {
    data: TradeOfferCreateManyTargetTeamInput | TradeOfferCreateManyTargetTeamInput[]
    skipDuplicates?: boolean
  }

  export type LeagueUpsertWithoutTeamsInput = {
    update: XOR<LeagueUpdateWithoutTeamsInput, LeagueUncheckedUpdateWithoutTeamsInput>
    create: XOR<LeagueCreateWithoutTeamsInput, LeagueUncheckedCreateWithoutTeamsInput>
    where?: LeagueWhereInput
  }

  export type LeagueUpdateToOneWithWhereWithoutTeamsInput = {
    where?: LeagueWhereInput
    data: XOR<LeagueUpdateWithoutTeamsInput, LeagueUncheckedUpdateWithoutTeamsInput>
  }

  export type LeagueUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissioner?: UserUpdateOneRequiredWithoutLeaguesCommissionedNestedInput
    leagueSettings?: LeagueSettingsUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUpdateOneWithoutLeagueNestedInput
    draft?: DraftUpdateOneWithoutLeagueNestedInput
    games?: GameUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUpdateManyWithoutLeagueNestedInput
    messages?: MessageUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    commissionerId?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leagueSettings?: LeagueSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    draft?: DraftUncheckedUpdateOneWithoutLeagueNestedInput
    games?: GameUncheckedUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutLeagueNestedInput
    messages?: MessageUncheckedUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type UserUpsertWithoutTeamsOwnedInput = {
    update: XOR<UserUpdateWithoutTeamsOwnedInput, UserUncheckedUpdateWithoutTeamsOwnedInput>
    create: XOR<UserCreateWithoutTeamsOwnedInput, UserUncheckedCreateWithoutTeamsOwnedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamsOwnedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamsOwnedInput, UserUncheckedUpdateWithoutTeamsOwnedInput>
  }

  export type UserUpdateWithoutTeamsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaguesCommissioned?: LeagueUpdateManyWithoutCommissionerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    draftPicks?: DraftPickUpdateManyWithoutUserNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutOffererNestedInput
    tradeTargets?: TradeOfferUpdateManyWithoutTargetNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaguesCommissioned?: LeagueUncheckedUpdateManyWithoutCommissionerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutUserNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutOffererNestedInput
    tradeTargets?: TradeOfferUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type RosterUpsertWithWhereUniqueWithoutTeamInput = {
    where: RosterWhereUniqueInput
    update: XOR<RosterUpdateWithoutTeamInput, RosterUncheckedUpdateWithoutTeamInput>
    create: XOR<RosterCreateWithoutTeamInput, RosterUncheckedCreateWithoutTeamInput>
  }

  export type RosterUpdateWithWhereUniqueWithoutTeamInput = {
    where: RosterWhereUniqueInput
    data: XOR<RosterUpdateWithoutTeamInput, RosterUncheckedUpdateWithoutTeamInput>
  }

  export type RosterUpdateManyWithWhereWithoutTeamInput = {
    where: RosterScalarWhereInput
    data: XOR<RosterUpdateManyMutationInput, RosterUncheckedUpdateManyWithoutTeamInput>
  }

  export type RosterScalarWhereInput = {
    AND?: RosterScalarWhereInput | RosterScalarWhereInput[]
    OR?: RosterScalarWhereInput[]
    NOT?: RosterScalarWhereInput | RosterScalarWhereInput[]
    id?: StringFilter<"Roster"> | string
    teamId?: StringFilter<"Roster"> | string
    playerId?: StringFilter<"Roster"> | string
    position?: EnumRosterPositionFilter<"Roster"> | $Enums.RosterPosition
    isStarter?: BoolFilter<"Roster"> | boolean
    acquiredDate?: DateTimeFilter<"Roster"> | Date | string
    weekAdded?: IntNullableFilter<"Roster"> | number | null
  }

  export type DraftPickUpsertWithWhereUniqueWithoutTeamInput = {
    where: DraftPickWhereUniqueInput
    update: XOR<DraftPickUpdateWithoutTeamInput, DraftPickUncheckedUpdateWithoutTeamInput>
    create: XOR<DraftPickCreateWithoutTeamInput, DraftPickUncheckedCreateWithoutTeamInput>
  }

  export type DraftPickUpdateWithWhereUniqueWithoutTeamInput = {
    where: DraftPickWhereUniqueInput
    data: XOR<DraftPickUpdateWithoutTeamInput, DraftPickUncheckedUpdateWithoutTeamInput>
  }

  export type DraftPickUpdateManyWithWhereWithoutTeamInput = {
    where: DraftPickScalarWhereInput
    data: XOR<DraftPickUpdateManyMutationInput, DraftPickUncheckedUpdateManyWithoutTeamInput>
  }

  export type GameUpsertWithWhereUniqueWithoutHomeTeamInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutHomeTeamInput, GameUncheckedUpdateWithoutHomeTeamInput>
    create: XOR<GameCreateWithoutHomeTeamInput, GameUncheckedCreateWithoutHomeTeamInput>
  }

  export type GameUpdateWithWhereUniqueWithoutHomeTeamInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutHomeTeamInput, GameUncheckedUpdateWithoutHomeTeamInput>
  }

  export type GameUpdateManyWithWhereWithoutHomeTeamInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutHomeTeamInput>
  }

  export type GameUpsertWithWhereUniqueWithoutAwayTeamInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutAwayTeamInput, GameUncheckedUpdateWithoutAwayTeamInput>
    create: XOR<GameCreateWithoutAwayTeamInput, GameUncheckedCreateWithoutAwayTeamInput>
  }

  export type GameUpdateWithWhereUniqueWithoutAwayTeamInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutAwayTeamInput, GameUncheckedUpdateWithoutAwayTeamInput>
  }

  export type GameUpdateManyWithWhereWithoutAwayTeamInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutAwayTeamInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutTeamInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutTeamInput, TransactionUncheckedUpdateWithoutTeamInput>
    create: XOR<TransactionCreateWithoutTeamInput, TransactionUncheckedCreateWithoutTeamInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutTeamInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutTeamInput, TransactionUncheckedUpdateWithoutTeamInput>
  }

  export type TransactionUpdateManyWithWhereWithoutTeamInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTeamInput>
  }

  export type TradeOfferUpsertWithWhereUniqueWithoutOfferingTeamInput = {
    where: TradeOfferWhereUniqueInput
    update: XOR<TradeOfferUpdateWithoutOfferingTeamInput, TradeOfferUncheckedUpdateWithoutOfferingTeamInput>
    create: XOR<TradeOfferCreateWithoutOfferingTeamInput, TradeOfferUncheckedCreateWithoutOfferingTeamInput>
  }

  export type TradeOfferUpdateWithWhereUniqueWithoutOfferingTeamInput = {
    where: TradeOfferWhereUniqueInput
    data: XOR<TradeOfferUpdateWithoutOfferingTeamInput, TradeOfferUncheckedUpdateWithoutOfferingTeamInput>
  }

  export type TradeOfferUpdateManyWithWhereWithoutOfferingTeamInput = {
    where: TradeOfferScalarWhereInput
    data: XOR<TradeOfferUpdateManyMutationInput, TradeOfferUncheckedUpdateManyWithoutOfferingTeamInput>
  }

  export type TradeOfferUpsertWithWhereUniqueWithoutTargetTeamInput = {
    where: TradeOfferWhereUniqueInput
    update: XOR<TradeOfferUpdateWithoutTargetTeamInput, TradeOfferUncheckedUpdateWithoutTargetTeamInput>
    create: XOR<TradeOfferCreateWithoutTargetTeamInput, TradeOfferUncheckedCreateWithoutTargetTeamInput>
  }

  export type TradeOfferUpdateWithWhereUniqueWithoutTargetTeamInput = {
    where: TradeOfferWhereUniqueInput
    data: XOR<TradeOfferUpdateWithoutTargetTeamInput, TradeOfferUncheckedUpdateWithoutTargetTeamInput>
  }

  export type TradeOfferUpdateManyWithWhereWithoutTargetTeamInput = {
    where: TradeOfferScalarWhereInput
    data: XOR<TradeOfferUpdateManyMutationInput, TradeOfferUncheckedUpdateManyWithoutTargetTeamInput>
  }

  export type RosterCreateWithoutPlayerInput = {
    id?: string
    position?: $Enums.RosterPosition
    isStarter?: boolean
    acquiredDate?: Date | string
    weekAdded?: number | null
    team: TeamCreateNestedOneWithoutRosterInput
  }

  export type RosterUncheckedCreateWithoutPlayerInput = {
    id?: string
    teamId: string
    position?: $Enums.RosterPosition
    isStarter?: boolean
    acquiredDate?: Date | string
    weekAdded?: number | null
  }

  export type RosterCreateOrConnectWithoutPlayerInput = {
    where: RosterWhereUniqueInput
    create: XOR<RosterCreateWithoutPlayerInput, RosterUncheckedCreateWithoutPlayerInput>
  }

  export type RosterCreateManyPlayerInputEnvelope = {
    data: RosterCreateManyPlayerInput | RosterCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type DraftPickCreateWithoutPlayerInput = {
    id?: string
    round: number
    pick: number
    pickInRound: number
    pickTime?: Date | string | null
    isKeeper?: boolean
    createdAt?: Date | string
    draft: DraftCreateNestedOneWithoutPicksInput
    team: TeamCreateNestedOneWithoutDraftPicksInput
    user: UserCreateNestedOneWithoutDraftPicksInput
  }

  export type DraftPickUncheckedCreateWithoutPlayerInput = {
    id?: string
    draftId: string
    teamId: string
    userId: string
    round: number
    pick: number
    pickInRound: number
    pickTime?: Date | string | null
    isKeeper?: boolean
    createdAt?: Date | string
  }

  export type DraftPickCreateOrConnectWithoutPlayerInput = {
    where: DraftPickWhereUniqueInput
    create: XOR<DraftPickCreateWithoutPlayerInput, DraftPickUncheckedCreateWithoutPlayerInput>
  }

  export type DraftPickCreateManyPlayerInputEnvelope = {
    data: DraftPickCreateManyPlayerInput | DraftPickCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutPlayerInput = {
    id?: string
    transactionType: $Enums.TransactionType
    week: number
    description?: string | null
    isProcessed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
    league: LeagueCreateNestedOneWithoutTransactionsInput
    team: TeamCreateNestedOneWithoutTransactionsInput
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutPlayerInput = {
    id?: string
    leagueId: string
    teamId: string
    userId: string
    transactionType: $Enums.TransactionType
    week: number
    description?: string | null
    isProcessed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutPlayerInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPlayerInput, TransactionUncheckedCreateWithoutPlayerInput>
  }

  export type TransactionCreateManyPlayerInputEnvelope = {
    data: TransactionCreateManyPlayerInput | TransactionCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type GameStatsCreateWithoutPlayerInput = {
    id?: string
    week: number
    season?: number
    passingYards?: number
    passingTds?: number
    passingInts?: number
    passingAttempts?: number
    rushingYards?: number
    rushingTds?: number
    rushingAttempts?: number
    receptions?: number
    receivingYards?: number
    receivingTds?: number
    targets?: number
    fumbles?: number
    fumblesLost?: number
    fieldGoalsMade?: number
    fieldGoalsAttempted?: number
    extraPointsMade?: number
    extraPointsAttempted?: number
    sacks?: Decimal | DecimalJsLike | number | string
    interceptions?: number
    fumbleRecoveries?: number
    safeties?: number
    defensiveTds?: number
    pointsAllowed?: number
    fantasyPoints?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameStatsUncheckedCreateWithoutPlayerInput = {
    id?: string
    week: number
    season?: number
    passingYards?: number
    passingTds?: number
    passingInts?: number
    passingAttempts?: number
    rushingYards?: number
    rushingTds?: number
    rushingAttempts?: number
    receptions?: number
    receivingYards?: number
    receivingTds?: number
    targets?: number
    fumbles?: number
    fumblesLost?: number
    fieldGoalsMade?: number
    fieldGoalsAttempted?: number
    extraPointsMade?: number
    extraPointsAttempted?: number
    sacks?: Decimal | DecimalJsLike | number | string
    interceptions?: number
    fumbleRecoveries?: number
    safeties?: number
    defensiveTds?: number
    pointsAllowed?: number
    fantasyPoints?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameStatsCreateOrConnectWithoutPlayerInput = {
    where: GameStatsWhereUniqueInput
    create: XOR<GameStatsCreateWithoutPlayerInput, GameStatsUncheckedCreateWithoutPlayerInput>
  }

  export type GameStatsCreateManyPlayerInputEnvelope = {
    data: GameStatsCreateManyPlayerInput | GameStatsCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type WeeklyProjectionCreateWithoutPlayerInput = {
    id?: string
    week: number
    season?: number
    projectedPoints?: Decimal | DecimalJsLike | number | string
    confidence?: Decimal | DecimalJsLike | number | string
    projPassingYards?: Decimal | DecimalJsLike | number | string
    projPassingTds?: Decimal | DecimalJsLike | number | string
    projRushingYards?: Decimal | DecimalJsLike | number | string
    projRushingTds?: Decimal | DecimalJsLike | number | string
    projReceptions?: Decimal | DecimalJsLike | number | string
    projReceivingYards?: Decimal | DecimalJsLike | number | string
    projReceivingTds?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyProjectionUncheckedCreateWithoutPlayerInput = {
    id?: string
    week: number
    season?: number
    projectedPoints?: Decimal | DecimalJsLike | number | string
    confidence?: Decimal | DecimalJsLike | number | string
    projPassingYards?: Decimal | DecimalJsLike | number | string
    projPassingTds?: Decimal | DecimalJsLike | number | string
    projRushingYards?: Decimal | DecimalJsLike | number | string
    projRushingTds?: Decimal | DecimalJsLike | number | string
    projReceptions?: Decimal | DecimalJsLike | number | string
    projReceivingYards?: Decimal | DecimalJsLike | number | string
    projReceivingTds?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyProjectionCreateOrConnectWithoutPlayerInput = {
    where: WeeklyProjectionWhereUniqueInput
    create: XOR<WeeklyProjectionCreateWithoutPlayerInput, WeeklyProjectionUncheckedCreateWithoutPlayerInput>
  }

  export type WeeklyProjectionCreateManyPlayerInputEnvelope = {
    data: WeeklyProjectionCreateManyPlayerInput | WeeklyProjectionCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type TradeOfferPlayerCreateWithoutPlayerInput = {
    id?: string
    fromTeam: boolean
    tradeOffer: TradeOfferCreateNestedOneWithoutPlayersInput
  }

  export type TradeOfferPlayerUncheckedCreateWithoutPlayerInput = {
    id?: string
    tradeOfferId: string
    fromTeam: boolean
  }

  export type TradeOfferPlayerCreateOrConnectWithoutPlayerInput = {
    where: TradeOfferPlayerWhereUniqueInput
    create: XOR<TradeOfferPlayerCreateWithoutPlayerInput, TradeOfferPlayerUncheckedCreateWithoutPlayerInput>
  }

  export type TradeOfferPlayerCreateManyPlayerInputEnvelope = {
    data: TradeOfferPlayerCreateManyPlayerInput | TradeOfferPlayerCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type RosterUpsertWithWhereUniqueWithoutPlayerInput = {
    where: RosterWhereUniqueInput
    update: XOR<RosterUpdateWithoutPlayerInput, RosterUncheckedUpdateWithoutPlayerInput>
    create: XOR<RosterCreateWithoutPlayerInput, RosterUncheckedCreateWithoutPlayerInput>
  }

  export type RosterUpdateWithWhereUniqueWithoutPlayerInput = {
    where: RosterWhereUniqueInput
    data: XOR<RosterUpdateWithoutPlayerInput, RosterUncheckedUpdateWithoutPlayerInput>
  }

  export type RosterUpdateManyWithWhereWithoutPlayerInput = {
    where: RosterScalarWhereInput
    data: XOR<RosterUpdateManyMutationInput, RosterUncheckedUpdateManyWithoutPlayerInput>
  }

  export type DraftPickUpsertWithWhereUniqueWithoutPlayerInput = {
    where: DraftPickWhereUniqueInput
    update: XOR<DraftPickUpdateWithoutPlayerInput, DraftPickUncheckedUpdateWithoutPlayerInput>
    create: XOR<DraftPickCreateWithoutPlayerInput, DraftPickUncheckedCreateWithoutPlayerInput>
  }

  export type DraftPickUpdateWithWhereUniqueWithoutPlayerInput = {
    where: DraftPickWhereUniqueInput
    data: XOR<DraftPickUpdateWithoutPlayerInput, DraftPickUncheckedUpdateWithoutPlayerInput>
  }

  export type DraftPickUpdateManyWithWhereWithoutPlayerInput = {
    where: DraftPickScalarWhereInput
    data: XOR<DraftPickUpdateManyMutationInput, DraftPickUncheckedUpdateManyWithoutPlayerInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutPlayerInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutPlayerInput, TransactionUncheckedUpdateWithoutPlayerInput>
    create: XOR<TransactionCreateWithoutPlayerInput, TransactionUncheckedCreateWithoutPlayerInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutPlayerInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutPlayerInput, TransactionUncheckedUpdateWithoutPlayerInput>
  }

  export type TransactionUpdateManyWithWhereWithoutPlayerInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutPlayerInput>
  }

  export type GameStatsUpsertWithWhereUniqueWithoutPlayerInput = {
    where: GameStatsWhereUniqueInput
    update: XOR<GameStatsUpdateWithoutPlayerInput, GameStatsUncheckedUpdateWithoutPlayerInput>
    create: XOR<GameStatsCreateWithoutPlayerInput, GameStatsUncheckedCreateWithoutPlayerInput>
  }

  export type GameStatsUpdateWithWhereUniqueWithoutPlayerInput = {
    where: GameStatsWhereUniqueInput
    data: XOR<GameStatsUpdateWithoutPlayerInput, GameStatsUncheckedUpdateWithoutPlayerInput>
  }

  export type GameStatsUpdateManyWithWhereWithoutPlayerInput = {
    where: GameStatsScalarWhereInput
    data: XOR<GameStatsUpdateManyMutationInput, GameStatsUncheckedUpdateManyWithoutPlayerInput>
  }

  export type GameStatsScalarWhereInput = {
    AND?: GameStatsScalarWhereInput | GameStatsScalarWhereInput[]
    OR?: GameStatsScalarWhereInput[]
    NOT?: GameStatsScalarWhereInput | GameStatsScalarWhereInput[]
    id?: StringFilter<"GameStats"> | string
    playerId?: StringFilter<"GameStats"> | string
    week?: IntFilter<"GameStats"> | number
    season?: IntFilter<"GameStats"> | number
    passingYards?: IntFilter<"GameStats"> | number
    passingTds?: IntFilter<"GameStats"> | number
    passingInts?: IntFilter<"GameStats"> | number
    passingAttempts?: IntFilter<"GameStats"> | number
    rushingYards?: IntFilter<"GameStats"> | number
    rushingTds?: IntFilter<"GameStats"> | number
    rushingAttempts?: IntFilter<"GameStats"> | number
    receptions?: IntFilter<"GameStats"> | number
    receivingYards?: IntFilter<"GameStats"> | number
    receivingTds?: IntFilter<"GameStats"> | number
    targets?: IntFilter<"GameStats"> | number
    fumbles?: IntFilter<"GameStats"> | number
    fumblesLost?: IntFilter<"GameStats"> | number
    fieldGoalsMade?: IntFilter<"GameStats"> | number
    fieldGoalsAttempted?: IntFilter<"GameStats"> | number
    extraPointsMade?: IntFilter<"GameStats"> | number
    extraPointsAttempted?: IntFilter<"GameStats"> | number
    sacks?: DecimalFilter<"GameStats"> | Decimal | DecimalJsLike | number | string
    interceptions?: IntFilter<"GameStats"> | number
    fumbleRecoveries?: IntFilter<"GameStats"> | number
    safeties?: IntFilter<"GameStats"> | number
    defensiveTds?: IntFilter<"GameStats"> | number
    pointsAllowed?: IntFilter<"GameStats"> | number
    fantasyPoints?: DecimalFilter<"GameStats"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"GameStats"> | Date | string
    updatedAt?: DateTimeFilter<"GameStats"> | Date | string
  }

  export type WeeklyProjectionUpsertWithWhereUniqueWithoutPlayerInput = {
    where: WeeklyProjectionWhereUniqueInput
    update: XOR<WeeklyProjectionUpdateWithoutPlayerInput, WeeklyProjectionUncheckedUpdateWithoutPlayerInput>
    create: XOR<WeeklyProjectionCreateWithoutPlayerInput, WeeklyProjectionUncheckedCreateWithoutPlayerInput>
  }

  export type WeeklyProjectionUpdateWithWhereUniqueWithoutPlayerInput = {
    where: WeeklyProjectionWhereUniqueInput
    data: XOR<WeeklyProjectionUpdateWithoutPlayerInput, WeeklyProjectionUncheckedUpdateWithoutPlayerInput>
  }

  export type WeeklyProjectionUpdateManyWithWhereWithoutPlayerInput = {
    where: WeeklyProjectionScalarWhereInput
    data: XOR<WeeklyProjectionUpdateManyMutationInput, WeeklyProjectionUncheckedUpdateManyWithoutPlayerInput>
  }

  export type WeeklyProjectionScalarWhereInput = {
    AND?: WeeklyProjectionScalarWhereInput | WeeklyProjectionScalarWhereInput[]
    OR?: WeeklyProjectionScalarWhereInput[]
    NOT?: WeeklyProjectionScalarWhereInput | WeeklyProjectionScalarWhereInput[]
    id?: StringFilter<"WeeklyProjection"> | string
    playerId?: StringFilter<"WeeklyProjection"> | string
    week?: IntFilter<"WeeklyProjection"> | number
    season?: IntFilter<"WeeklyProjection"> | number
    projectedPoints?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projPassingYards?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projPassingTds?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projRushingYards?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projRushingTds?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projReceptions?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projReceivingYards?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    projReceivingTds?: DecimalFilter<"WeeklyProjection"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"WeeklyProjection"> | Date | string
    updatedAt?: DateTimeFilter<"WeeklyProjection"> | Date | string
  }

  export type TradeOfferPlayerUpsertWithWhereUniqueWithoutPlayerInput = {
    where: TradeOfferPlayerWhereUniqueInput
    update: XOR<TradeOfferPlayerUpdateWithoutPlayerInput, TradeOfferPlayerUncheckedUpdateWithoutPlayerInput>
    create: XOR<TradeOfferPlayerCreateWithoutPlayerInput, TradeOfferPlayerUncheckedCreateWithoutPlayerInput>
  }

  export type TradeOfferPlayerUpdateWithWhereUniqueWithoutPlayerInput = {
    where: TradeOfferPlayerWhereUniqueInput
    data: XOR<TradeOfferPlayerUpdateWithoutPlayerInput, TradeOfferPlayerUncheckedUpdateWithoutPlayerInput>
  }

  export type TradeOfferPlayerUpdateManyWithWhereWithoutPlayerInput = {
    where: TradeOfferPlayerScalarWhereInput
    data: XOR<TradeOfferPlayerUpdateManyMutationInput, TradeOfferPlayerUncheckedUpdateManyWithoutPlayerInput>
  }

  export type TradeOfferPlayerScalarWhereInput = {
    AND?: TradeOfferPlayerScalarWhereInput | TradeOfferPlayerScalarWhereInput[]
    OR?: TradeOfferPlayerScalarWhereInput[]
    NOT?: TradeOfferPlayerScalarWhereInput | TradeOfferPlayerScalarWhereInput[]
    id?: StringFilter<"TradeOfferPlayer"> | string
    tradeOfferId?: StringFilter<"TradeOfferPlayer"> | string
    playerId?: StringFilter<"TradeOfferPlayer"> | string
    fromTeam?: BoolFilter<"TradeOfferPlayer"> | boolean
  }

  export type TeamCreateWithoutRosterInput = {
    id?: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTeamsInput
    owner: UserCreateNestedOneWithoutTeamsOwnedInput
    draftPicks?: DraftPickCreateNestedManyWithoutTeamInput
    homeGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamUncheckedCreateWithoutRosterInput = {
    id?: string
    leagueId: string
    ownerId: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutTeamInput
    homeGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferUncheckedCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferUncheckedCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamCreateOrConnectWithoutRosterInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutRosterInput, TeamUncheckedCreateWithoutRosterInput>
  }

  export type PlayerCreateWithoutRosterInput = {
    id?: string
    externalId?: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number?: number | null
    byeWeek?: number | null
    isActive?: boolean
    injuryStatus?: $Enums.InjuryStatus
    injuryNote?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    draftPicks?: DraftPickCreateNestedManyWithoutPlayerInput
    transactions?: TransactionCreateNestedManyWithoutPlayerInput
    gameStats?: GameStatsCreateNestedManyWithoutPlayerInput
    weeklyProjections?: WeeklyProjectionCreateNestedManyWithoutPlayerInput
    tradeOfferPlayers?: TradeOfferPlayerCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutRosterInput = {
    id?: string
    externalId?: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number?: number | null
    byeWeek?: number | null
    isActive?: boolean
    injuryStatus?: $Enums.InjuryStatus
    injuryNote?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutPlayerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutPlayerInput
    gameStats?: GameStatsUncheckedCreateNestedManyWithoutPlayerInput
    weeklyProjections?: WeeklyProjectionUncheckedCreateNestedManyWithoutPlayerInput
    tradeOfferPlayers?: TradeOfferPlayerUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutRosterInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutRosterInput, PlayerUncheckedCreateWithoutRosterInput>
  }

  export type TeamUpsertWithoutRosterInput = {
    update: XOR<TeamUpdateWithoutRosterInput, TeamUncheckedUpdateWithoutRosterInput>
    create: XOR<TeamCreateWithoutRosterInput, TeamUncheckedCreateWithoutRosterInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutRosterInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutRosterInput, TeamUncheckedUpdateWithoutRosterInput>
  }

  export type TeamUpdateWithoutRosterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTeamsNestedInput
    owner?: UserUpdateOneRequiredWithoutTeamsOwnedNestedInput
    draftPicks?: DraftPickUpdateManyWithoutTeamNestedInput
    homeGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUpdateManyWithoutTargetTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutRosterInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftPicks?: DraftPickUncheckedUpdateManyWithoutTeamNestedInput
    homeGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUncheckedUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUncheckedUpdateManyWithoutTargetTeamNestedInput
  }

  export type PlayerUpsertWithoutRosterInput = {
    update: XOR<PlayerUpdateWithoutRosterInput, PlayerUncheckedUpdateWithoutRosterInput>
    create: XOR<PlayerCreateWithoutRosterInput, PlayerUncheckedCreateWithoutRosterInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutRosterInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutRosterInput, PlayerUncheckedUpdateWithoutRosterInput>
  }

  export type PlayerUpdateWithoutRosterInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftPicks?: DraftPickUpdateManyWithoutPlayerNestedInput
    transactions?: TransactionUpdateManyWithoutPlayerNestedInput
    gameStats?: GameStatsUpdateManyWithoutPlayerNestedInput
    weeklyProjections?: WeeklyProjectionUpdateManyWithoutPlayerNestedInput
    tradeOfferPlayers?: TradeOfferPlayerUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutRosterInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftPicks?: DraftPickUncheckedUpdateManyWithoutPlayerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutPlayerNestedInput
    gameStats?: GameStatsUncheckedUpdateManyWithoutPlayerNestedInput
    weeklyProjections?: WeeklyProjectionUncheckedUpdateManyWithoutPlayerNestedInput
    tradeOfferPlayers?: TradeOfferPlayerUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type LeagueCreateWithoutDraftInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissioner: UserCreateNestedOneWithoutLeaguesCommissionedInput
    teams?: TeamCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsCreateNestedOneWithoutLeagueInput
    games?: GameCreateNestedManyWithoutLeagueInput
    transactions?: TransactionCreateNestedManyWithoutLeagueInput
    messages?: MessageCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateWithoutDraftInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    commissionerId: string
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsUncheckedCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsUncheckedCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsUncheckedCreateNestedOneWithoutLeagueInput
    games?: GameUncheckedCreateNestedManyWithoutLeagueInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutLeagueInput
    messages?: MessageUncheckedCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutDraftInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutDraftInput, LeagueUncheckedCreateWithoutDraftInput>
  }

  export type DraftPickCreateWithoutDraftInput = {
    id?: string
    round: number
    pick: number
    pickInRound: number
    pickTime?: Date | string | null
    isKeeper?: boolean
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutDraftPicksInput
    user: UserCreateNestedOneWithoutDraftPicksInput
    player?: PlayerCreateNestedOneWithoutDraftPicksInput
  }

  export type DraftPickUncheckedCreateWithoutDraftInput = {
    id?: string
    teamId: string
    userId: string
    playerId?: string | null
    round: number
    pick: number
    pickInRound: number
    pickTime?: Date | string | null
    isKeeper?: boolean
    createdAt?: Date | string
  }

  export type DraftPickCreateOrConnectWithoutDraftInput = {
    where: DraftPickWhereUniqueInput
    create: XOR<DraftPickCreateWithoutDraftInput, DraftPickUncheckedCreateWithoutDraftInput>
  }

  export type DraftPickCreateManyDraftInputEnvelope = {
    data: DraftPickCreateManyDraftInput | DraftPickCreateManyDraftInput[]
    skipDuplicates?: boolean
  }

  export type LeagueUpsertWithoutDraftInput = {
    update: XOR<LeagueUpdateWithoutDraftInput, LeagueUncheckedUpdateWithoutDraftInput>
    create: XOR<LeagueCreateWithoutDraftInput, LeagueUncheckedCreateWithoutDraftInput>
    where?: LeagueWhereInput
  }

  export type LeagueUpdateToOneWithWhereWithoutDraftInput = {
    where?: LeagueWhereInput
    data: XOR<LeagueUpdateWithoutDraftInput, LeagueUncheckedUpdateWithoutDraftInput>
  }

  export type LeagueUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissioner?: UserUpdateOneRequiredWithoutLeaguesCommissionedNestedInput
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUpdateOneWithoutLeagueNestedInput
    games?: GameUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUpdateManyWithoutLeagueNestedInput
    messages?: MessageUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    commissionerId?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    games?: GameUncheckedUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutLeagueNestedInput
    messages?: MessageUncheckedUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type DraftPickUpsertWithWhereUniqueWithoutDraftInput = {
    where: DraftPickWhereUniqueInput
    update: XOR<DraftPickUpdateWithoutDraftInput, DraftPickUncheckedUpdateWithoutDraftInput>
    create: XOR<DraftPickCreateWithoutDraftInput, DraftPickUncheckedCreateWithoutDraftInput>
  }

  export type DraftPickUpdateWithWhereUniqueWithoutDraftInput = {
    where: DraftPickWhereUniqueInput
    data: XOR<DraftPickUpdateWithoutDraftInput, DraftPickUncheckedUpdateWithoutDraftInput>
  }

  export type DraftPickUpdateManyWithWhereWithoutDraftInput = {
    where: DraftPickScalarWhereInput
    data: XOR<DraftPickUpdateManyMutationInput, DraftPickUncheckedUpdateManyWithoutDraftInput>
  }

  export type DraftCreateWithoutPicksInput = {
    id?: string
    draftType: $Enums.DraftType
    draftDate?: Date | string | null
    isComplete?: boolean
    currentRound?: number
    currentPick?: number
    timePerPick?: number
    draftOrder?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutDraftInput
  }

  export type DraftUncheckedCreateWithoutPicksInput = {
    id?: string
    leagueId: string
    draftType: $Enums.DraftType
    draftDate?: Date | string | null
    isComplete?: boolean
    currentRound?: number
    currentPick?: number
    timePerPick?: number
    draftOrder?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DraftCreateOrConnectWithoutPicksInput = {
    where: DraftWhereUniqueInput
    create: XOR<DraftCreateWithoutPicksInput, DraftUncheckedCreateWithoutPicksInput>
  }

  export type TeamCreateWithoutDraftPicksInput = {
    id?: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTeamsInput
    owner: UserCreateNestedOneWithoutTeamsOwnedInput
    roster?: RosterCreateNestedManyWithoutTeamInput
    homeGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamUncheckedCreateWithoutDraftPicksInput = {
    id?: string
    leagueId: string
    ownerId: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterUncheckedCreateNestedManyWithoutTeamInput
    homeGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferUncheckedCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferUncheckedCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamCreateOrConnectWithoutDraftPicksInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutDraftPicksInput, TeamUncheckedCreateWithoutDraftPicksInput>
  }

  export type UserCreateWithoutDraftPicksInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamsOwned?: TeamCreateNestedManyWithoutOwnerInput
    leaguesCommissioned?: LeagueCreateNestedManyWithoutCommissionerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutOffererInput
    tradeTargets?: TradeOfferCreateNestedManyWithoutTargetInput
  }

  export type UserUncheckedCreateWithoutDraftPicksInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamsOwned?: TeamUncheckedCreateNestedManyWithoutOwnerInput
    leaguesCommissioned?: LeagueUncheckedCreateNestedManyWithoutCommissionerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutOffererInput
    tradeTargets?: TradeOfferUncheckedCreateNestedManyWithoutTargetInput
  }

  export type UserCreateOrConnectWithoutDraftPicksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDraftPicksInput, UserUncheckedCreateWithoutDraftPicksInput>
  }

  export type PlayerCreateWithoutDraftPicksInput = {
    id?: string
    externalId?: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number?: number | null
    byeWeek?: number | null
    isActive?: boolean
    injuryStatus?: $Enums.InjuryStatus
    injuryNote?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterCreateNestedManyWithoutPlayerInput
    transactions?: TransactionCreateNestedManyWithoutPlayerInput
    gameStats?: GameStatsCreateNestedManyWithoutPlayerInput
    weeklyProjections?: WeeklyProjectionCreateNestedManyWithoutPlayerInput
    tradeOfferPlayers?: TradeOfferPlayerCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutDraftPicksInput = {
    id?: string
    externalId?: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number?: number | null
    byeWeek?: number | null
    isActive?: boolean
    injuryStatus?: $Enums.InjuryStatus
    injuryNote?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterUncheckedCreateNestedManyWithoutPlayerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutPlayerInput
    gameStats?: GameStatsUncheckedCreateNestedManyWithoutPlayerInput
    weeklyProjections?: WeeklyProjectionUncheckedCreateNestedManyWithoutPlayerInput
    tradeOfferPlayers?: TradeOfferPlayerUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutDraftPicksInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutDraftPicksInput, PlayerUncheckedCreateWithoutDraftPicksInput>
  }

  export type DraftUpsertWithoutPicksInput = {
    update: XOR<DraftUpdateWithoutPicksInput, DraftUncheckedUpdateWithoutPicksInput>
    create: XOR<DraftCreateWithoutPicksInput, DraftUncheckedCreateWithoutPicksInput>
    where?: DraftWhereInput
  }

  export type DraftUpdateToOneWithWhereWithoutPicksInput = {
    where?: DraftWhereInput
    data: XOR<DraftUpdateWithoutPicksInput, DraftUncheckedUpdateWithoutPicksInput>
  }

  export type DraftUpdateWithoutPicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    currentRound?: IntFieldUpdateOperationsInput | number
    currentPick?: IntFieldUpdateOperationsInput | number
    timePerPick?: IntFieldUpdateOperationsInput | number
    draftOrder?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutDraftNestedInput
  }

  export type DraftUncheckedUpdateWithoutPicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    currentRound?: IntFieldUpdateOperationsInput | number
    currentPick?: IntFieldUpdateOperationsInput | number
    timePerPick?: IntFieldUpdateOperationsInput | number
    draftOrder?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpsertWithoutDraftPicksInput = {
    update: XOR<TeamUpdateWithoutDraftPicksInput, TeamUncheckedUpdateWithoutDraftPicksInput>
    create: XOR<TeamCreateWithoutDraftPicksInput, TeamUncheckedCreateWithoutDraftPicksInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutDraftPicksInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutDraftPicksInput, TeamUncheckedUpdateWithoutDraftPicksInput>
  }

  export type TeamUpdateWithoutDraftPicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTeamsNestedInput
    owner?: UserUpdateOneRequiredWithoutTeamsOwnedNestedInput
    roster?: RosterUpdateManyWithoutTeamNestedInput
    homeGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUpdateManyWithoutTargetTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutDraftPicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUncheckedUpdateManyWithoutTeamNestedInput
    homeGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUncheckedUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUncheckedUpdateManyWithoutTargetTeamNestedInput
  }

  export type UserUpsertWithoutDraftPicksInput = {
    update: XOR<UserUpdateWithoutDraftPicksInput, UserUncheckedUpdateWithoutDraftPicksInput>
    create: XOR<UserCreateWithoutDraftPicksInput, UserUncheckedCreateWithoutDraftPicksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDraftPicksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDraftPicksInput, UserUncheckedUpdateWithoutDraftPicksInput>
  }

  export type UserUpdateWithoutDraftPicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamsOwned?: TeamUpdateManyWithoutOwnerNestedInput
    leaguesCommissioned?: LeagueUpdateManyWithoutCommissionerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutOffererNestedInput
    tradeTargets?: TradeOfferUpdateManyWithoutTargetNestedInput
  }

  export type UserUncheckedUpdateWithoutDraftPicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamsOwned?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
    leaguesCommissioned?: LeagueUncheckedUpdateManyWithoutCommissionerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutOffererNestedInput
    tradeTargets?: TradeOfferUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type PlayerUpsertWithoutDraftPicksInput = {
    update: XOR<PlayerUpdateWithoutDraftPicksInput, PlayerUncheckedUpdateWithoutDraftPicksInput>
    create: XOR<PlayerCreateWithoutDraftPicksInput, PlayerUncheckedCreateWithoutDraftPicksInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutDraftPicksInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutDraftPicksInput, PlayerUncheckedUpdateWithoutDraftPicksInput>
  }

  export type PlayerUpdateWithoutDraftPicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUpdateManyWithoutPlayerNestedInput
    transactions?: TransactionUpdateManyWithoutPlayerNestedInput
    gameStats?: GameStatsUpdateManyWithoutPlayerNestedInput
    weeklyProjections?: WeeklyProjectionUpdateManyWithoutPlayerNestedInput
    tradeOfferPlayers?: TradeOfferPlayerUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutDraftPicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUncheckedUpdateManyWithoutPlayerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutPlayerNestedInput
    gameStats?: GameStatsUncheckedUpdateManyWithoutPlayerNestedInput
    weeklyProjections?: WeeklyProjectionUncheckedUpdateManyWithoutPlayerNestedInput
    tradeOfferPlayers?: TradeOfferPlayerUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type LeagueCreateWithoutGamesInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissioner: UserCreateNestedOneWithoutLeaguesCommissionedInput
    teams?: TeamCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsCreateNestedOneWithoutLeagueInput
    draft?: DraftCreateNestedOneWithoutLeagueInput
    transactions?: TransactionCreateNestedManyWithoutLeagueInput
    messages?: MessageCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateWithoutGamesInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    commissionerId: string
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsUncheckedCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsUncheckedCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsUncheckedCreateNestedOneWithoutLeagueInput
    draft?: DraftUncheckedCreateNestedOneWithoutLeagueInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutLeagueInput
    messages?: MessageUncheckedCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutGamesInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutGamesInput, LeagueUncheckedCreateWithoutGamesInput>
  }

  export type TeamCreateWithoutHomeGamesInput = {
    id?: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTeamsInput
    owner: UserCreateNestedOneWithoutTeamsOwnedInput
    roster?: RosterCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickCreateNestedManyWithoutTeamInput
    awayGames?: GameCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamUncheckedCreateWithoutHomeGamesInput = {
    id?: string
    leagueId: string
    ownerId: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterUncheckedCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutTeamInput
    awayGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferUncheckedCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferUncheckedCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamCreateOrConnectWithoutHomeGamesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutHomeGamesInput, TeamUncheckedCreateWithoutHomeGamesInput>
  }

  export type TeamCreateWithoutAwayGamesInput = {
    id?: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTeamsInput
    owner: UserCreateNestedOneWithoutTeamsOwnedInput
    roster?: RosterCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickCreateNestedManyWithoutTeamInput
    homeGames?: GameCreateNestedManyWithoutHomeTeamInput
    transactions?: TransactionCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamUncheckedCreateWithoutAwayGamesInput = {
    id?: string
    leagueId: string
    ownerId: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterUncheckedCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutTeamInput
    homeGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferUncheckedCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferUncheckedCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamCreateOrConnectWithoutAwayGamesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutAwayGamesInput, TeamUncheckedCreateWithoutAwayGamesInput>
  }

  export type LeagueUpsertWithoutGamesInput = {
    update: XOR<LeagueUpdateWithoutGamesInput, LeagueUncheckedUpdateWithoutGamesInput>
    create: XOR<LeagueCreateWithoutGamesInput, LeagueUncheckedCreateWithoutGamesInput>
    where?: LeagueWhereInput
  }

  export type LeagueUpdateToOneWithWhereWithoutGamesInput = {
    where?: LeagueWhereInput
    data: XOR<LeagueUpdateWithoutGamesInput, LeagueUncheckedUpdateWithoutGamesInput>
  }

  export type LeagueUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissioner?: UserUpdateOneRequiredWithoutLeaguesCommissionedNestedInput
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUpdateOneWithoutLeagueNestedInput
    draft?: DraftUpdateOneWithoutLeagueNestedInput
    transactions?: TransactionUpdateManyWithoutLeagueNestedInput
    messages?: MessageUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    commissionerId?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    draft?: DraftUncheckedUpdateOneWithoutLeagueNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutLeagueNestedInput
    messages?: MessageUncheckedUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type TeamUpsertWithoutHomeGamesInput = {
    update: XOR<TeamUpdateWithoutHomeGamesInput, TeamUncheckedUpdateWithoutHomeGamesInput>
    create: XOR<TeamCreateWithoutHomeGamesInput, TeamUncheckedCreateWithoutHomeGamesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutHomeGamesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutHomeGamesInput, TeamUncheckedUpdateWithoutHomeGamesInput>
  }

  export type TeamUpdateWithoutHomeGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTeamsNestedInput
    owner?: UserUpdateOneRequiredWithoutTeamsOwnedNestedInput
    roster?: RosterUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUpdateManyWithoutTeamNestedInput
    awayGames?: GameUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUpdateManyWithoutTargetTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutHomeGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUncheckedUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutTeamNestedInput
    awayGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUncheckedUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUncheckedUpdateManyWithoutTargetTeamNestedInput
  }

  export type TeamUpsertWithoutAwayGamesInput = {
    update: XOR<TeamUpdateWithoutAwayGamesInput, TeamUncheckedUpdateWithoutAwayGamesInput>
    create: XOR<TeamCreateWithoutAwayGamesInput, TeamUncheckedCreateWithoutAwayGamesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutAwayGamesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutAwayGamesInput, TeamUncheckedUpdateWithoutAwayGamesInput>
  }

  export type TeamUpdateWithoutAwayGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTeamsNestedInput
    owner?: UserUpdateOneRequiredWithoutTeamsOwnedNestedInput
    roster?: RosterUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUpdateManyWithoutTeamNestedInput
    homeGames?: GameUpdateManyWithoutHomeTeamNestedInput
    transactions?: TransactionUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUpdateManyWithoutTargetTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutAwayGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUncheckedUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutTeamNestedInput
    homeGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUncheckedUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUncheckedUpdateManyWithoutTargetTeamNestedInput
  }

  export type LeagueCreateWithoutTransactionsInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissioner: UserCreateNestedOneWithoutLeaguesCommissionedInput
    teams?: TeamCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsCreateNestedOneWithoutLeagueInput
    draft?: DraftCreateNestedOneWithoutLeagueInput
    games?: GameCreateNestedManyWithoutLeagueInput
    messages?: MessageCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    commissionerId: string
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsUncheckedCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsUncheckedCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsUncheckedCreateNestedOneWithoutLeagueInput
    draft?: DraftUncheckedCreateNestedOneWithoutLeagueInput
    games?: GameUncheckedCreateNestedManyWithoutLeagueInput
    messages?: MessageUncheckedCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutTransactionsInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutTransactionsInput, LeagueUncheckedCreateWithoutTransactionsInput>
  }

  export type TeamCreateWithoutTransactionsInput = {
    id?: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTeamsInput
    owner: UserCreateNestedOneWithoutTeamsOwnedInput
    roster?: RosterCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickCreateNestedManyWithoutTeamInput
    homeGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameCreateNestedManyWithoutAwayTeamInput
    offeredTrades?: TradeOfferCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamUncheckedCreateWithoutTransactionsInput = {
    id?: string
    leagueId: string
    ownerId: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterUncheckedCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutTeamInput
    homeGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
    offeredTrades?: TradeOfferUncheckedCreateNestedManyWithoutOfferingTeamInput
    targetedTrades?: TradeOfferUncheckedCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamCreateOrConnectWithoutTransactionsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTransactionsInput, TeamUncheckedCreateWithoutTransactionsInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamsOwned?: TeamCreateNestedManyWithoutOwnerInput
    leaguesCommissioned?: LeagueCreateNestedManyWithoutCommissionerInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    draftPicks?: DraftPickCreateNestedManyWithoutUserInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutOffererInput
    tradeTargets?: TradeOfferCreateNestedManyWithoutTargetInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamsOwned?: TeamUncheckedCreateNestedManyWithoutOwnerInput
    leaguesCommissioned?: LeagueUncheckedCreateNestedManyWithoutCommissionerInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutUserInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutOffererInput
    tradeTargets?: TradeOfferUncheckedCreateNestedManyWithoutTargetInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type PlayerCreateWithoutTransactionsInput = {
    id?: string
    externalId?: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number?: number | null
    byeWeek?: number | null
    isActive?: boolean
    injuryStatus?: $Enums.InjuryStatus
    injuryNote?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterCreateNestedManyWithoutPlayerInput
    draftPicks?: DraftPickCreateNestedManyWithoutPlayerInput
    gameStats?: GameStatsCreateNestedManyWithoutPlayerInput
    weeklyProjections?: WeeklyProjectionCreateNestedManyWithoutPlayerInput
    tradeOfferPlayers?: TradeOfferPlayerCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutTransactionsInput = {
    id?: string
    externalId?: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number?: number | null
    byeWeek?: number | null
    isActive?: boolean
    injuryStatus?: $Enums.InjuryStatus
    injuryNote?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterUncheckedCreateNestedManyWithoutPlayerInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutPlayerInput
    gameStats?: GameStatsUncheckedCreateNestedManyWithoutPlayerInput
    weeklyProjections?: WeeklyProjectionUncheckedCreateNestedManyWithoutPlayerInput
    tradeOfferPlayers?: TradeOfferPlayerUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutTransactionsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutTransactionsInput, PlayerUncheckedCreateWithoutTransactionsInput>
  }

  export type LeagueUpsertWithoutTransactionsInput = {
    update: XOR<LeagueUpdateWithoutTransactionsInput, LeagueUncheckedUpdateWithoutTransactionsInput>
    create: XOR<LeagueCreateWithoutTransactionsInput, LeagueUncheckedCreateWithoutTransactionsInput>
    where?: LeagueWhereInput
  }

  export type LeagueUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: LeagueWhereInput
    data: XOR<LeagueUpdateWithoutTransactionsInput, LeagueUncheckedUpdateWithoutTransactionsInput>
  }

  export type LeagueUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissioner?: UserUpdateOneRequiredWithoutLeaguesCommissionedNestedInput
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUpdateOneWithoutLeagueNestedInput
    draft?: DraftUpdateOneWithoutLeagueNestedInput
    games?: GameUpdateManyWithoutLeagueNestedInput
    messages?: MessageUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    commissionerId?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    draft?: DraftUncheckedUpdateOneWithoutLeagueNestedInput
    games?: GameUncheckedUpdateManyWithoutLeagueNestedInput
    messages?: MessageUncheckedUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type TeamUpsertWithoutTransactionsInput = {
    update: XOR<TeamUpdateWithoutTransactionsInput, TeamUncheckedUpdateWithoutTransactionsInput>
    create: XOR<TeamCreateWithoutTransactionsInput, TeamUncheckedCreateWithoutTransactionsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutTransactionsInput, TeamUncheckedUpdateWithoutTransactionsInput>
  }

  export type TeamUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTeamsNestedInput
    owner?: UserUpdateOneRequiredWithoutTeamsOwnedNestedInput
    roster?: RosterUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUpdateManyWithoutTeamNestedInput
    homeGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUpdateManyWithoutAwayTeamNestedInput
    offeredTrades?: TradeOfferUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUpdateManyWithoutTargetTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUncheckedUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutTeamNestedInput
    homeGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
    offeredTrades?: TradeOfferUncheckedUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUncheckedUpdateManyWithoutTargetTeamNestedInput
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamsOwned?: TeamUpdateManyWithoutOwnerNestedInput
    leaguesCommissioned?: LeagueUpdateManyWithoutCommissionerNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    draftPicks?: DraftPickUpdateManyWithoutUserNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutOffererNestedInput
    tradeTargets?: TradeOfferUpdateManyWithoutTargetNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamsOwned?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
    leaguesCommissioned?: LeagueUncheckedUpdateManyWithoutCommissionerNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutUserNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutOffererNestedInput
    tradeTargets?: TradeOfferUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type PlayerUpsertWithoutTransactionsInput = {
    update: XOR<PlayerUpdateWithoutTransactionsInput, PlayerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<PlayerCreateWithoutTransactionsInput, PlayerUncheckedCreateWithoutTransactionsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutTransactionsInput, PlayerUncheckedUpdateWithoutTransactionsInput>
  }

  export type PlayerUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUpdateManyWithoutPlayerNestedInput
    draftPicks?: DraftPickUpdateManyWithoutPlayerNestedInput
    gameStats?: GameStatsUpdateManyWithoutPlayerNestedInput
    weeklyProjections?: WeeklyProjectionUpdateManyWithoutPlayerNestedInput
    tradeOfferPlayers?: TradeOfferPlayerUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUncheckedUpdateManyWithoutPlayerNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutPlayerNestedInput
    gameStats?: GameStatsUncheckedUpdateManyWithoutPlayerNestedInput
    weeklyProjections?: WeeklyProjectionUncheckedUpdateManyWithoutPlayerNestedInput
    tradeOfferPlayers?: TradeOfferPlayerUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type LeagueCreateWithoutTradeOffersInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissioner: UserCreateNestedOneWithoutLeaguesCommissionedInput
    teams?: TeamCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsCreateNestedOneWithoutLeagueInput
    draft?: DraftCreateNestedOneWithoutLeagueInput
    games?: GameCreateNestedManyWithoutLeagueInput
    transactions?: TransactionCreateNestedManyWithoutLeagueInput
    messages?: MessageCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateWithoutTradeOffersInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    commissionerId: string
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsUncheckedCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsUncheckedCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsUncheckedCreateNestedOneWithoutLeagueInput
    draft?: DraftUncheckedCreateNestedOneWithoutLeagueInput
    games?: GameUncheckedCreateNestedManyWithoutLeagueInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutLeagueInput
    messages?: MessageUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutTradeOffersInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutTradeOffersInput, LeagueUncheckedCreateWithoutTradeOffersInput>
  }

  export type TeamCreateWithoutOfferedTradesInput = {
    id?: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTeamsInput
    owner: UserCreateNestedOneWithoutTeamsOwnedInput
    roster?: RosterCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickCreateNestedManyWithoutTeamInput
    homeGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionCreateNestedManyWithoutTeamInput
    targetedTrades?: TradeOfferCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamUncheckedCreateWithoutOfferedTradesInput = {
    id?: string
    leagueId: string
    ownerId: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterUncheckedCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutTeamInput
    homeGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTeamInput
    targetedTrades?: TradeOfferUncheckedCreateNestedManyWithoutTargetTeamInput
  }

  export type TeamCreateOrConnectWithoutOfferedTradesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutOfferedTradesInput, TeamUncheckedCreateWithoutOfferedTradesInput>
  }

  export type TeamCreateWithoutTargetedTradesInput = {
    id?: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTeamsInput
    owner: UserCreateNestedOneWithoutTeamsOwnedInput
    roster?: RosterCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickCreateNestedManyWithoutTeamInput
    homeGames?: GameCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferCreateNestedManyWithoutOfferingTeamInput
  }

  export type TeamUncheckedCreateWithoutTargetedTradesInput = {
    id?: string
    leagueId: string
    ownerId: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterUncheckedCreateNestedManyWithoutTeamInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutTeamInput
    homeGames?: GameUncheckedCreateNestedManyWithoutHomeTeamInput
    awayGames?: GameUncheckedCreateNestedManyWithoutAwayTeamInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTeamInput
    offeredTrades?: TradeOfferUncheckedCreateNestedManyWithoutOfferingTeamInput
  }

  export type TeamCreateOrConnectWithoutTargetedTradesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTargetedTradesInput, TeamUncheckedCreateWithoutTargetedTradesInput>
  }

  export type UserCreateWithoutTradeOffersInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamsOwned?: TeamCreateNestedManyWithoutOwnerInput
    leaguesCommissioned?: LeagueCreateNestedManyWithoutCommissionerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    draftPicks?: DraftPickCreateNestedManyWithoutUserInput
    tradeTargets?: TradeOfferCreateNestedManyWithoutTargetInput
  }

  export type UserUncheckedCreateWithoutTradeOffersInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamsOwned?: TeamUncheckedCreateNestedManyWithoutOwnerInput
    leaguesCommissioned?: LeagueUncheckedCreateNestedManyWithoutCommissionerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutUserInput
    tradeTargets?: TradeOfferUncheckedCreateNestedManyWithoutTargetInput
  }

  export type UserCreateOrConnectWithoutTradeOffersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTradeOffersInput, UserUncheckedCreateWithoutTradeOffersInput>
  }

  export type UserCreateWithoutTradeTargetsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamsOwned?: TeamCreateNestedManyWithoutOwnerInput
    leaguesCommissioned?: LeagueCreateNestedManyWithoutCommissionerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    draftPicks?: DraftPickCreateNestedManyWithoutUserInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutOffererInput
  }

  export type UserUncheckedCreateWithoutTradeTargetsInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamsOwned?: TeamUncheckedCreateNestedManyWithoutOwnerInput
    leaguesCommissioned?: LeagueUncheckedCreateNestedManyWithoutCommissionerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutUserInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutOffererInput
  }

  export type UserCreateOrConnectWithoutTradeTargetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTradeTargetsInput, UserUncheckedCreateWithoutTradeTargetsInput>
  }

  export type TradeOfferPlayerCreateWithoutTradeOfferInput = {
    id?: string
    fromTeam: boolean
    player: PlayerCreateNestedOneWithoutTradeOfferPlayersInput
  }

  export type TradeOfferPlayerUncheckedCreateWithoutTradeOfferInput = {
    id?: string
    playerId: string
    fromTeam: boolean
  }

  export type TradeOfferPlayerCreateOrConnectWithoutTradeOfferInput = {
    where: TradeOfferPlayerWhereUniqueInput
    create: XOR<TradeOfferPlayerCreateWithoutTradeOfferInput, TradeOfferPlayerUncheckedCreateWithoutTradeOfferInput>
  }

  export type TradeOfferPlayerCreateManyTradeOfferInputEnvelope = {
    data: TradeOfferPlayerCreateManyTradeOfferInput | TradeOfferPlayerCreateManyTradeOfferInput[]
    skipDuplicates?: boolean
  }

  export type LeagueUpsertWithoutTradeOffersInput = {
    update: XOR<LeagueUpdateWithoutTradeOffersInput, LeagueUncheckedUpdateWithoutTradeOffersInput>
    create: XOR<LeagueCreateWithoutTradeOffersInput, LeagueUncheckedCreateWithoutTradeOffersInput>
    where?: LeagueWhereInput
  }

  export type LeagueUpdateToOneWithWhereWithoutTradeOffersInput = {
    where?: LeagueWhereInput
    data: XOR<LeagueUpdateWithoutTradeOffersInput, LeagueUncheckedUpdateWithoutTradeOffersInput>
  }

  export type LeagueUpdateWithoutTradeOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissioner?: UserUpdateOneRequiredWithoutLeaguesCommissionedNestedInput
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUpdateOneWithoutLeagueNestedInput
    draft?: DraftUpdateOneWithoutLeagueNestedInput
    games?: GameUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUpdateManyWithoutLeagueNestedInput
    messages?: MessageUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateWithoutTradeOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    commissionerId?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    draft?: DraftUncheckedUpdateOneWithoutLeagueNestedInput
    games?: GameUncheckedUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutLeagueNestedInput
    messages?: MessageUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type TeamUpsertWithoutOfferedTradesInput = {
    update: XOR<TeamUpdateWithoutOfferedTradesInput, TeamUncheckedUpdateWithoutOfferedTradesInput>
    create: XOR<TeamCreateWithoutOfferedTradesInput, TeamUncheckedCreateWithoutOfferedTradesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutOfferedTradesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutOfferedTradesInput, TeamUncheckedUpdateWithoutOfferedTradesInput>
  }

  export type TeamUpdateWithoutOfferedTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTeamsNestedInput
    owner?: UserUpdateOneRequiredWithoutTeamsOwnedNestedInput
    roster?: RosterUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUpdateManyWithoutTeamNestedInput
    homeGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUpdateManyWithoutTeamNestedInput
    targetedTrades?: TradeOfferUpdateManyWithoutTargetTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutOfferedTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUncheckedUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutTeamNestedInput
    homeGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTeamNestedInput
    targetedTrades?: TradeOfferUncheckedUpdateManyWithoutTargetTeamNestedInput
  }

  export type TeamUpsertWithoutTargetedTradesInput = {
    update: XOR<TeamUpdateWithoutTargetedTradesInput, TeamUncheckedUpdateWithoutTargetedTradesInput>
    create: XOR<TeamCreateWithoutTargetedTradesInput, TeamUncheckedCreateWithoutTargetedTradesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutTargetedTradesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutTargetedTradesInput, TeamUncheckedUpdateWithoutTargetedTradesInput>
  }

  export type TeamUpdateWithoutTargetedTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTeamsNestedInput
    owner?: UserUpdateOneRequiredWithoutTeamsOwnedNestedInput
    roster?: RosterUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUpdateManyWithoutTeamNestedInput
    homeGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUpdateManyWithoutOfferingTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTargetedTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUncheckedUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutTeamNestedInput
    homeGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUncheckedUpdateManyWithoutOfferingTeamNestedInput
  }

  export type UserUpsertWithoutTradeOffersInput = {
    update: XOR<UserUpdateWithoutTradeOffersInput, UserUncheckedUpdateWithoutTradeOffersInput>
    create: XOR<UserCreateWithoutTradeOffersInput, UserUncheckedCreateWithoutTradeOffersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTradeOffersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTradeOffersInput, UserUncheckedUpdateWithoutTradeOffersInput>
  }

  export type UserUpdateWithoutTradeOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamsOwned?: TeamUpdateManyWithoutOwnerNestedInput
    leaguesCommissioned?: LeagueUpdateManyWithoutCommissionerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    draftPicks?: DraftPickUpdateManyWithoutUserNestedInput
    tradeTargets?: TradeOfferUpdateManyWithoutTargetNestedInput
  }

  export type UserUncheckedUpdateWithoutTradeOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamsOwned?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
    leaguesCommissioned?: LeagueUncheckedUpdateManyWithoutCommissionerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutUserNestedInput
    tradeTargets?: TradeOfferUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type UserUpsertWithoutTradeTargetsInput = {
    update: XOR<UserUpdateWithoutTradeTargetsInput, UserUncheckedUpdateWithoutTradeTargetsInput>
    create: XOR<UserCreateWithoutTradeTargetsInput, UserUncheckedCreateWithoutTradeTargetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTradeTargetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTradeTargetsInput, UserUncheckedUpdateWithoutTradeTargetsInput>
  }

  export type UserUpdateWithoutTradeTargetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamsOwned?: TeamUpdateManyWithoutOwnerNestedInput
    leaguesCommissioned?: LeagueUpdateManyWithoutCommissionerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    draftPicks?: DraftPickUpdateManyWithoutUserNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutOffererNestedInput
  }

  export type UserUncheckedUpdateWithoutTradeTargetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamsOwned?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
    leaguesCommissioned?: LeagueUncheckedUpdateManyWithoutCommissionerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutUserNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutOffererNestedInput
  }

  export type TradeOfferPlayerUpsertWithWhereUniqueWithoutTradeOfferInput = {
    where: TradeOfferPlayerWhereUniqueInput
    update: XOR<TradeOfferPlayerUpdateWithoutTradeOfferInput, TradeOfferPlayerUncheckedUpdateWithoutTradeOfferInput>
    create: XOR<TradeOfferPlayerCreateWithoutTradeOfferInput, TradeOfferPlayerUncheckedCreateWithoutTradeOfferInput>
  }

  export type TradeOfferPlayerUpdateWithWhereUniqueWithoutTradeOfferInput = {
    where: TradeOfferPlayerWhereUniqueInput
    data: XOR<TradeOfferPlayerUpdateWithoutTradeOfferInput, TradeOfferPlayerUncheckedUpdateWithoutTradeOfferInput>
  }

  export type TradeOfferPlayerUpdateManyWithWhereWithoutTradeOfferInput = {
    where: TradeOfferPlayerScalarWhereInput
    data: XOR<TradeOfferPlayerUpdateManyMutationInput, TradeOfferPlayerUncheckedUpdateManyWithoutTradeOfferInput>
  }

  export type TradeOfferCreateWithoutPlayersInput = {
    id?: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    league: LeagueCreateNestedOneWithoutTradeOffersInput
    offeringTeam: TeamCreateNestedOneWithoutOfferedTradesInput
    targetTeam: TeamCreateNestedOneWithoutTargetedTradesInput
    offerer: UserCreateNestedOneWithoutTradeOffersInput
    target: UserCreateNestedOneWithoutTradeTargetsInput
  }

  export type TradeOfferUncheckedCreateWithoutPlayersInput = {
    id?: string
    leagueId: string
    offeringTeamId: string
    targetTeamId: string
    offererId: string
    targetId: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeOfferCreateOrConnectWithoutPlayersInput = {
    where: TradeOfferWhereUniqueInput
    create: XOR<TradeOfferCreateWithoutPlayersInput, TradeOfferUncheckedCreateWithoutPlayersInput>
  }

  export type PlayerCreateWithoutTradeOfferPlayersInput = {
    id?: string
    externalId?: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number?: number | null
    byeWeek?: number | null
    isActive?: boolean
    injuryStatus?: $Enums.InjuryStatus
    injuryNote?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterCreateNestedManyWithoutPlayerInput
    draftPicks?: DraftPickCreateNestedManyWithoutPlayerInput
    transactions?: TransactionCreateNestedManyWithoutPlayerInput
    gameStats?: GameStatsCreateNestedManyWithoutPlayerInput
    weeklyProjections?: WeeklyProjectionCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutTradeOfferPlayersInput = {
    id?: string
    externalId?: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number?: number | null
    byeWeek?: number | null
    isActive?: boolean
    injuryStatus?: $Enums.InjuryStatus
    injuryNote?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterUncheckedCreateNestedManyWithoutPlayerInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutPlayerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutPlayerInput
    gameStats?: GameStatsUncheckedCreateNestedManyWithoutPlayerInput
    weeklyProjections?: WeeklyProjectionUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutTradeOfferPlayersInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutTradeOfferPlayersInput, PlayerUncheckedCreateWithoutTradeOfferPlayersInput>
  }

  export type TradeOfferUpsertWithoutPlayersInput = {
    update: XOR<TradeOfferUpdateWithoutPlayersInput, TradeOfferUncheckedUpdateWithoutPlayersInput>
    create: XOR<TradeOfferCreateWithoutPlayersInput, TradeOfferUncheckedCreateWithoutPlayersInput>
    where?: TradeOfferWhereInput
  }

  export type TradeOfferUpdateToOneWithWhereWithoutPlayersInput = {
    where?: TradeOfferWhereInput
    data: XOR<TradeOfferUpdateWithoutPlayersInput, TradeOfferUncheckedUpdateWithoutPlayersInput>
  }

  export type TradeOfferUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTradeOffersNestedInput
    offeringTeam?: TeamUpdateOneRequiredWithoutOfferedTradesNestedInput
    targetTeam?: TeamUpdateOneRequiredWithoutTargetedTradesNestedInput
    offerer?: UserUpdateOneRequiredWithoutTradeOffersNestedInput
    target?: UserUpdateOneRequiredWithoutTradeTargetsNestedInput
  }

  export type TradeOfferUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    offeringTeamId?: StringFieldUpdateOperationsInput | string
    targetTeamId?: StringFieldUpdateOperationsInput | string
    offererId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUpsertWithoutTradeOfferPlayersInput = {
    update: XOR<PlayerUpdateWithoutTradeOfferPlayersInput, PlayerUncheckedUpdateWithoutTradeOfferPlayersInput>
    create: XOR<PlayerCreateWithoutTradeOfferPlayersInput, PlayerUncheckedCreateWithoutTradeOfferPlayersInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutTradeOfferPlayersInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutTradeOfferPlayersInput, PlayerUncheckedUpdateWithoutTradeOfferPlayersInput>
  }

  export type PlayerUpdateWithoutTradeOfferPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUpdateManyWithoutPlayerNestedInput
    draftPicks?: DraftPickUpdateManyWithoutPlayerNestedInput
    transactions?: TransactionUpdateManyWithoutPlayerNestedInput
    gameStats?: GameStatsUpdateManyWithoutPlayerNestedInput
    weeklyProjections?: WeeklyProjectionUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutTradeOfferPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUncheckedUpdateManyWithoutPlayerNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutPlayerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutPlayerNestedInput
    gameStats?: GameStatsUncheckedUpdateManyWithoutPlayerNestedInput
    weeklyProjections?: WeeklyProjectionUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type LeagueCreateWithoutMessagesInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissioner: UserCreateNestedOneWithoutLeaguesCommissionedInput
    teams?: TeamCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsCreateNestedOneWithoutLeagueInput
    draft?: DraftCreateNestedOneWithoutLeagueInput
    games?: GameCreateNestedManyWithoutLeagueInput
    transactions?: TransactionCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutLeagueInput
  }

  export type LeagueUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    commissionerId: string
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutLeagueInput
    leagueSettings?: LeagueSettingsUncheckedCreateNestedOneWithoutLeagueInput
    scoringSettings?: ScoringSettingsUncheckedCreateNestedOneWithoutLeagueInput
    rosterSettings?: RosterSettingsUncheckedCreateNestedOneWithoutLeagueInput
    draft?: DraftUncheckedCreateNestedOneWithoutLeagueInput
    games?: GameUncheckedCreateNestedManyWithoutLeagueInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutLeagueInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutLeagueInput
  }

  export type LeagueCreateOrConnectWithoutMessagesInput = {
    where: LeagueWhereUniqueInput
    create: XOR<LeagueCreateWithoutMessagesInput, LeagueUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamsOwned?: TeamCreateNestedManyWithoutOwnerInput
    leaguesCommissioned?: LeagueCreateNestedManyWithoutCommissionerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    draftPicks?: DraftPickCreateNestedManyWithoutUserInput
    tradeOffers?: TradeOfferCreateNestedManyWithoutOffererInput
    tradeTargets?: TradeOfferCreateNestedManyWithoutTargetInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    username: string
    firstName?: string | null
    lastName?: string | null
    profileImage?: string | null
    timezone?: string
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamsOwned?: TeamUncheckedCreateNestedManyWithoutOwnerInput
    leaguesCommissioned?: LeagueUncheckedCreateNestedManyWithoutCommissionerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutUserInput
    tradeOffers?: TradeOfferUncheckedCreateNestedManyWithoutOffererInput
    tradeTargets?: TradeOfferUncheckedCreateNestedManyWithoutTargetInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type LeagueUpsertWithoutMessagesInput = {
    update: XOR<LeagueUpdateWithoutMessagesInput, LeagueUncheckedUpdateWithoutMessagesInput>
    create: XOR<LeagueCreateWithoutMessagesInput, LeagueUncheckedCreateWithoutMessagesInput>
    where?: LeagueWhereInput
  }

  export type LeagueUpdateToOneWithWhereWithoutMessagesInput = {
    where?: LeagueWhereInput
    data: XOR<LeagueUpdateWithoutMessagesInput, LeagueUncheckedUpdateWithoutMessagesInput>
  }

  export type LeagueUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissioner?: UserUpdateOneRequiredWithoutLeaguesCommissionedNestedInput
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUpdateOneWithoutLeagueNestedInput
    draft?: DraftUpdateOneWithoutLeagueNestedInput
    games?: GameUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    commissionerId?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    draft?: DraftUncheckedUpdateOneWithoutLeagueNestedInput
    games?: GameUncheckedUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamsOwned?: TeamUpdateManyWithoutOwnerNestedInput
    leaguesCommissioned?: LeagueUpdateManyWithoutCommissionerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    draftPicks?: DraftPickUpdateManyWithoutUserNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutOffererNestedInput
    tradeTargets?: TradeOfferUpdateManyWithoutTargetNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamsOwned?: TeamUncheckedUpdateManyWithoutOwnerNestedInput
    leaguesCommissioned?: LeagueUncheckedUpdateManyWithoutCommissionerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutUserNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutOffererNestedInput
    tradeTargets?: TradeOfferUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type PlayerCreateWithoutGameStatsInput = {
    id?: string
    externalId?: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number?: number | null
    byeWeek?: number | null
    isActive?: boolean
    injuryStatus?: $Enums.InjuryStatus
    injuryNote?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterCreateNestedManyWithoutPlayerInput
    draftPicks?: DraftPickCreateNestedManyWithoutPlayerInput
    transactions?: TransactionCreateNestedManyWithoutPlayerInput
    weeklyProjections?: WeeklyProjectionCreateNestedManyWithoutPlayerInput
    tradeOfferPlayers?: TradeOfferPlayerCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutGameStatsInput = {
    id?: string
    externalId?: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number?: number | null
    byeWeek?: number | null
    isActive?: boolean
    injuryStatus?: $Enums.InjuryStatus
    injuryNote?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterUncheckedCreateNestedManyWithoutPlayerInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutPlayerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutPlayerInput
    weeklyProjections?: WeeklyProjectionUncheckedCreateNestedManyWithoutPlayerInput
    tradeOfferPlayers?: TradeOfferPlayerUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutGameStatsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutGameStatsInput, PlayerUncheckedCreateWithoutGameStatsInput>
  }

  export type PlayerUpsertWithoutGameStatsInput = {
    update: XOR<PlayerUpdateWithoutGameStatsInput, PlayerUncheckedUpdateWithoutGameStatsInput>
    create: XOR<PlayerCreateWithoutGameStatsInput, PlayerUncheckedCreateWithoutGameStatsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutGameStatsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutGameStatsInput, PlayerUncheckedUpdateWithoutGameStatsInput>
  }

  export type PlayerUpdateWithoutGameStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUpdateManyWithoutPlayerNestedInput
    draftPicks?: DraftPickUpdateManyWithoutPlayerNestedInput
    transactions?: TransactionUpdateManyWithoutPlayerNestedInput
    weeklyProjections?: WeeklyProjectionUpdateManyWithoutPlayerNestedInput
    tradeOfferPlayers?: TradeOfferPlayerUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutGameStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUncheckedUpdateManyWithoutPlayerNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutPlayerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutPlayerNestedInput
    weeklyProjections?: WeeklyProjectionUncheckedUpdateManyWithoutPlayerNestedInput
    tradeOfferPlayers?: TradeOfferPlayerUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerCreateWithoutWeeklyProjectionsInput = {
    id?: string
    externalId?: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number?: number | null
    byeWeek?: number | null
    isActive?: boolean
    injuryStatus?: $Enums.InjuryStatus
    injuryNote?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterCreateNestedManyWithoutPlayerInput
    draftPicks?: DraftPickCreateNestedManyWithoutPlayerInput
    transactions?: TransactionCreateNestedManyWithoutPlayerInput
    gameStats?: GameStatsCreateNestedManyWithoutPlayerInput
    tradeOfferPlayers?: TradeOfferPlayerCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutWeeklyProjectionsInput = {
    id?: string
    externalId?: string | null
    firstName: string
    lastName: string
    position: $Enums.Position
    team: string
    number?: number | null
    byeWeek?: number | null
    isActive?: boolean
    injuryStatus?: $Enums.InjuryStatus
    injuryNote?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roster?: RosterUncheckedCreateNestedManyWithoutPlayerInput
    draftPicks?: DraftPickUncheckedCreateNestedManyWithoutPlayerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutPlayerInput
    gameStats?: GameStatsUncheckedCreateNestedManyWithoutPlayerInput
    tradeOfferPlayers?: TradeOfferPlayerUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutWeeklyProjectionsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutWeeklyProjectionsInput, PlayerUncheckedCreateWithoutWeeklyProjectionsInput>
  }

  export type PlayerUpsertWithoutWeeklyProjectionsInput = {
    update: XOR<PlayerUpdateWithoutWeeklyProjectionsInput, PlayerUncheckedUpdateWithoutWeeklyProjectionsInput>
    create: XOR<PlayerCreateWithoutWeeklyProjectionsInput, PlayerUncheckedCreateWithoutWeeklyProjectionsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutWeeklyProjectionsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutWeeklyProjectionsInput, PlayerUncheckedUpdateWithoutWeeklyProjectionsInput>
  }

  export type PlayerUpdateWithoutWeeklyProjectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUpdateManyWithoutPlayerNestedInput
    draftPicks?: DraftPickUpdateManyWithoutPlayerNestedInput
    transactions?: TransactionUpdateManyWithoutPlayerNestedInput
    gameStats?: GameStatsUpdateManyWithoutPlayerNestedInput
    tradeOfferPlayers?: TradeOfferPlayerUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutWeeklyProjectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    position?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    team?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    byeWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    injuryStatus?: EnumInjuryStatusFieldUpdateOperationsInput | $Enums.InjuryStatus
    injuryNote?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUncheckedUpdateManyWithoutPlayerNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutPlayerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutPlayerNestedInput
    gameStats?: GameStatsUncheckedUpdateManyWithoutPlayerNestedInput
    tradeOfferPlayers?: TradeOfferPlayerUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type TeamCreateManyOwnerInput = {
    id?: string
    leagueId: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeagueCreateManyCommissionerInput = {
    id?: string
    name: string
    password?: string | null
    customUrl?: string | null
    maxTeams?: number
    isActive?: boolean
    isPaid?: boolean
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizeAmount?: Decimal | DecimalJsLike | number | string | null
    draftType?: $Enums.DraftType
    draftDate?: Date | string | null
    seasonStartWeek?: number
    leagueStartDate?: Date | string | null
    rosterDeadline?: Date | string | null
    maxAddsPerSeason?: number | null
    maxAddsPerWeek?: number | null
    tradeRejectTime?: number
    tradeEndDate?: Date | string | null
    waiverTime?: number
    commissionerMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    leagueId: string
    teamId: string
    playerId: string
    transactionType: $Enums.TransactionType
    week: number
    description?: string | null
    isProcessed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    leagueId?: string | null
    recipientId?: string | null
    subject?: string | null
    content: string
    messageType?: $Enums.MessageType
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DraftPickCreateManyUserInput = {
    id?: string
    draftId: string
    teamId: string
    playerId?: string | null
    round: number
    pick: number
    pickInRound: number
    pickTime?: Date | string | null
    isKeeper?: boolean
    createdAt?: Date | string
  }

  export type TradeOfferCreateManyOffererInput = {
    id?: string
    leagueId: string
    offeringTeamId: string
    targetTeamId: string
    targetId: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeOfferCreateManyTargetInput = {
    id?: string
    leagueId: string
    offeringTeamId: string
    targetTeamId: string
    offererId: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTeamsNestedInput
    roster?: RosterUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUpdateManyWithoutTeamNestedInput
    homeGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUpdateManyWithoutTargetTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUncheckedUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutTeamNestedInput
    homeGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUncheckedUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUncheckedUpdateManyWithoutTargetTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeagueUpdateWithoutCommissionerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUpdateOneWithoutLeagueNestedInput
    draft?: DraftUpdateOneWithoutLeagueNestedInput
    games?: GameUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUpdateManyWithoutLeagueNestedInput
    messages?: MessageUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateWithoutCommissionerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutLeagueNestedInput
    leagueSettings?: LeagueSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    scoringSettings?: ScoringSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    rosterSettings?: RosterSettingsUncheckedUpdateOneWithoutLeagueNestedInput
    draft?: DraftUncheckedUpdateOneWithoutLeagueNestedInput
    games?: GameUncheckedUpdateManyWithoutLeagueNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutLeagueNestedInput
    messages?: MessageUncheckedUpdateManyWithoutLeagueNestedInput
    tradeOffers?: TradeOfferUncheckedUpdateManyWithoutLeagueNestedInput
  }

  export type LeagueUncheckedUpdateManyWithoutCommissionerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    customUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    draftType?: EnumDraftTypeFieldUpdateOperationsInput | $Enums.DraftType
    draftDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasonStartWeek?: IntFieldUpdateOperationsInput | number
    leagueStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rosterDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxAddsPerSeason?: NullableIntFieldUpdateOperationsInput | number | null
    maxAddsPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    tradeRejectTime?: IntFieldUpdateOperationsInput | number
    tradeEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waiverTime?: IntFieldUpdateOperationsInput | number
    commissionerMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTransactionsNestedInput
    team?: TeamUpdateOneRequiredWithoutTransactionsNestedInput
    player?: PlayerUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftPickUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draft?: DraftUpdateOneRequiredWithoutPicksNestedInput
    team?: TeamUpdateOneRequiredWithoutDraftPicksNestedInput
    player?: PlayerUpdateOneWithoutDraftPicksNestedInput
  }

  export type DraftPickUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftPickUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeOfferUpdateWithoutOffererInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTradeOffersNestedInput
    offeringTeam?: TeamUpdateOneRequiredWithoutOfferedTradesNestedInput
    targetTeam?: TeamUpdateOneRequiredWithoutTargetedTradesNestedInput
    target?: UserUpdateOneRequiredWithoutTradeTargetsNestedInput
    players?: TradeOfferPlayerUpdateManyWithoutTradeOfferNestedInput
  }

  export type TradeOfferUncheckedUpdateWithoutOffererInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    offeringTeamId?: StringFieldUpdateOperationsInput | string
    targetTeamId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: TradeOfferPlayerUncheckedUpdateManyWithoutTradeOfferNestedInput
  }

  export type TradeOfferUncheckedUpdateManyWithoutOffererInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    offeringTeamId?: StringFieldUpdateOperationsInput | string
    targetTeamId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeOfferUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTradeOffersNestedInput
    offeringTeam?: TeamUpdateOneRequiredWithoutOfferedTradesNestedInput
    targetTeam?: TeamUpdateOneRequiredWithoutTargetedTradesNestedInput
    offerer?: UserUpdateOneRequiredWithoutTradeOffersNestedInput
    players?: TradeOfferPlayerUpdateManyWithoutTradeOfferNestedInput
  }

  export type TradeOfferUncheckedUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    offeringTeamId?: StringFieldUpdateOperationsInput | string
    targetTeamId?: StringFieldUpdateOperationsInput | string
    offererId?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: TradeOfferPlayerUncheckedUpdateManyWithoutTradeOfferNestedInput
  }

  export type TradeOfferUncheckedUpdateManyWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    offeringTeamId?: StringFieldUpdateOperationsInput | string
    targetTeamId?: StringFieldUpdateOperationsInput | string
    offererId?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateManyLeagueInput = {
    id?: string
    ownerId: string
    name: string
    logoUrl?: string | null
    wins?: number
    losses?: number
    ties?: number
    totalPoints?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    waiverPriority?: number
    transactionCount?: number
    paidEntry?: boolean
    amountOwed?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCreateManyLeagueInput = {
    id?: string
    homeTeamId: string
    awayTeamId: string
    week: number
    season?: number
    homeScore?: Decimal | DecimalJsLike | number | string
    awayScore?: Decimal | DecimalJsLike | number | string
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyLeagueInput = {
    id?: string
    teamId: string
    userId: string
    playerId: string
    transactionType: $Enums.TransactionType
    week: number
    description?: string | null
    isProcessed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageCreateManyLeagueInput = {
    id?: string
    senderId: string
    recipientId?: string | null
    subject?: string | null
    content: string
    messageType?: $Enums.MessageType
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TradeOfferCreateManyLeagueInput = {
    id?: string
    offeringTeamId: string
    targetTeamId: string
    offererId: string
    targetId: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutTeamsOwnedNestedInput
    roster?: RosterUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUpdateManyWithoutTeamNestedInput
    homeGames?: GameUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUpdateManyWithoutTargetTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roster?: RosterUncheckedUpdateManyWithoutTeamNestedInput
    draftPicks?: DraftPickUncheckedUpdateManyWithoutTeamNestedInput
    homeGames?: GameUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayGames?: GameUncheckedUpdateManyWithoutAwayTeamNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTeamNestedInput
    offeredTrades?: TradeOfferUncheckedUpdateManyWithoutOfferingTeamNestedInput
    targetedTrades?: TradeOfferUncheckedUpdateManyWithoutTargetTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    ties?: IntFieldUpdateOperationsInput | number
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    waiverPriority?: IntFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    paidEntry?: BoolFieldUpdateOperationsInput | boolean
    amountOwed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    homeScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isPlayoffs?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homeTeam?: TeamUpdateOneRequiredWithoutHomeGamesNestedInput
    awayTeam?: TeamUpdateOneRequiredWithoutAwayGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    homeScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isPlayoffs?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUncheckedUpdateManyWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    homeScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isPlayoffs?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    player?: PlayerUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeOfferUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeringTeam?: TeamUpdateOneRequiredWithoutOfferedTradesNestedInput
    targetTeam?: TeamUpdateOneRequiredWithoutTargetedTradesNestedInput
    offerer?: UserUpdateOneRequiredWithoutTradeOffersNestedInput
    target?: UserUpdateOneRequiredWithoutTradeTargetsNestedInput
    players?: TradeOfferPlayerUpdateManyWithoutTradeOfferNestedInput
  }

  export type TradeOfferUncheckedUpdateWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    offeringTeamId?: StringFieldUpdateOperationsInput | string
    targetTeamId?: StringFieldUpdateOperationsInput | string
    offererId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: TradeOfferPlayerUncheckedUpdateManyWithoutTradeOfferNestedInput
  }

  export type TradeOfferUncheckedUpdateManyWithoutLeagueInput = {
    id?: StringFieldUpdateOperationsInput | string
    offeringTeamId?: StringFieldUpdateOperationsInput | string
    targetTeamId?: StringFieldUpdateOperationsInput | string
    offererId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RosterCreateManyTeamInput = {
    id?: string
    playerId: string
    position?: $Enums.RosterPosition
    isStarter?: boolean
    acquiredDate?: Date | string
    weekAdded?: number | null
  }

  export type DraftPickCreateManyTeamInput = {
    id?: string
    draftId: string
    userId: string
    playerId?: string | null
    round: number
    pick: number
    pickInRound: number
    pickTime?: Date | string | null
    isKeeper?: boolean
    createdAt?: Date | string
  }

  export type GameCreateManyHomeTeamInput = {
    id?: string
    leagueId: string
    awayTeamId: string
    week: number
    season?: number
    homeScore?: Decimal | DecimalJsLike | number | string
    awayScore?: Decimal | DecimalJsLike | number | string
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameCreateManyAwayTeamInput = {
    id?: string
    leagueId: string
    homeTeamId: string
    week: number
    season?: number
    homeScore?: Decimal | DecimalJsLike | number | string
    awayScore?: Decimal | DecimalJsLike | number | string
    isComplete?: boolean
    isPlayoffs?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyTeamInput = {
    id?: string
    leagueId: string
    userId: string
    playerId: string
    transactionType: $Enums.TransactionType
    week: number
    description?: string | null
    isProcessed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TradeOfferCreateManyOfferingTeamInput = {
    id?: string
    leagueId: string
    targetTeamId: string
    offererId: string
    targetId: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeOfferCreateManyTargetTeamInput = {
    id?: string
    leagueId: string
    offeringTeamId: string
    offererId: string
    targetId: string
    status?: $Enums.TradeStatus
    note?: string | null
    expiresAt?: Date | string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RosterUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: EnumRosterPositionFieldUpdateOperationsInput | $Enums.RosterPosition
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weekAdded?: NullableIntFieldUpdateOperationsInput | number | null
    player?: PlayerUpdateOneRequiredWithoutRosterNestedInput
  }

  export type RosterUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    position?: EnumRosterPositionFieldUpdateOperationsInput | $Enums.RosterPosition
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weekAdded?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RosterUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    position?: EnumRosterPositionFieldUpdateOperationsInput | $Enums.RosterPosition
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weekAdded?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DraftPickUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draft?: DraftUpdateOneRequiredWithoutPicksNestedInput
    user?: UserUpdateOneRequiredWithoutDraftPicksNestedInput
    player?: PlayerUpdateOneWithoutDraftPicksNestedInput
  }

  export type DraftPickUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftPickUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUpdateWithoutHomeTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    homeScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isPlayoffs?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutGamesNestedInput
    awayTeam?: TeamUpdateOneRequiredWithoutAwayGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutHomeTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    homeScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isPlayoffs?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUncheckedUpdateManyWithoutHomeTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    homeScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isPlayoffs?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUpdateWithoutAwayTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    homeScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isPlayoffs?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutGamesNestedInput
    homeTeam?: TeamUpdateOneRequiredWithoutHomeGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutAwayTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    homeScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isPlayoffs?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUncheckedUpdateManyWithoutAwayTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    homeTeamId?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    homeScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isPlayoffs?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    player?: PlayerUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeOfferUpdateWithoutOfferingTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTradeOffersNestedInput
    targetTeam?: TeamUpdateOneRequiredWithoutTargetedTradesNestedInput
    offerer?: UserUpdateOneRequiredWithoutTradeOffersNestedInput
    target?: UserUpdateOneRequiredWithoutTradeTargetsNestedInput
    players?: TradeOfferPlayerUpdateManyWithoutTradeOfferNestedInput
  }

  export type TradeOfferUncheckedUpdateWithoutOfferingTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    targetTeamId?: StringFieldUpdateOperationsInput | string
    offererId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: TradeOfferPlayerUncheckedUpdateManyWithoutTradeOfferNestedInput
  }

  export type TradeOfferUncheckedUpdateManyWithoutOfferingTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    targetTeamId?: StringFieldUpdateOperationsInput | string
    offererId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeOfferUpdateWithoutTargetTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTradeOffersNestedInput
    offeringTeam?: TeamUpdateOneRequiredWithoutOfferedTradesNestedInput
    offerer?: UserUpdateOneRequiredWithoutTradeOffersNestedInput
    target?: UserUpdateOneRequiredWithoutTradeTargetsNestedInput
    players?: TradeOfferPlayerUpdateManyWithoutTradeOfferNestedInput
  }

  export type TradeOfferUncheckedUpdateWithoutTargetTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    offeringTeamId?: StringFieldUpdateOperationsInput | string
    offererId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: TradeOfferPlayerUncheckedUpdateManyWithoutTradeOfferNestedInput
  }

  export type TradeOfferUncheckedUpdateManyWithoutTargetTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    offeringTeamId?: StringFieldUpdateOperationsInput | string
    offererId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    status?: EnumTradeStatusFieldUpdateOperationsInput | $Enums.TradeStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RosterCreateManyPlayerInput = {
    id?: string
    teamId: string
    position?: $Enums.RosterPosition
    isStarter?: boolean
    acquiredDate?: Date | string
    weekAdded?: number | null
  }

  export type DraftPickCreateManyPlayerInput = {
    id?: string
    draftId: string
    teamId: string
    userId: string
    round: number
    pick: number
    pickInRound: number
    pickTime?: Date | string | null
    isKeeper?: boolean
    createdAt?: Date | string
  }

  export type TransactionCreateManyPlayerInput = {
    id?: string
    leagueId: string
    teamId: string
    userId: string
    transactionType: $Enums.TransactionType
    week: number
    description?: string | null
    isProcessed?: boolean
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type GameStatsCreateManyPlayerInput = {
    id?: string
    week: number
    season?: number
    passingYards?: number
    passingTds?: number
    passingInts?: number
    passingAttempts?: number
    rushingYards?: number
    rushingTds?: number
    rushingAttempts?: number
    receptions?: number
    receivingYards?: number
    receivingTds?: number
    targets?: number
    fumbles?: number
    fumblesLost?: number
    fieldGoalsMade?: number
    fieldGoalsAttempted?: number
    extraPointsMade?: number
    extraPointsAttempted?: number
    sacks?: Decimal | DecimalJsLike | number | string
    interceptions?: number
    fumbleRecoveries?: number
    safeties?: number
    defensiveTds?: number
    pointsAllowed?: number
    fantasyPoints?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyProjectionCreateManyPlayerInput = {
    id?: string
    week: number
    season?: number
    projectedPoints?: Decimal | DecimalJsLike | number | string
    confidence?: Decimal | DecimalJsLike | number | string
    projPassingYards?: Decimal | DecimalJsLike | number | string
    projPassingTds?: Decimal | DecimalJsLike | number | string
    projRushingYards?: Decimal | DecimalJsLike | number | string
    projRushingTds?: Decimal | DecimalJsLike | number | string
    projReceptions?: Decimal | DecimalJsLike | number | string
    projReceivingYards?: Decimal | DecimalJsLike | number | string
    projReceivingTds?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeOfferPlayerCreateManyPlayerInput = {
    id?: string
    tradeOfferId: string
    fromTeam: boolean
  }

  export type RosterUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: EnumRosterPositionFieldUpdateOperationsInput | $Enums.RosterPosition
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weekAdded?: NullableIntFieldUpdateOperationsInput | number | null
    team?: TeamUpdateOneRequiredWithoutRosterNestedInput
  }

  export type RosterUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    position?: EnumRosterPositionFieldUpdateOperationsInput | $Enums.RosterPosition
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weekAdded?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RosterUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    position?: EnumRosterPositionFieldUpdateOperationsInput | $Enums.RosterPosition
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weekAdded?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DraftPickUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draft?: DraftUpdateOneRequiredWithoutPicksNestedInput
    team?: TeamUpdateOneRequiredWithoutDraftPicksNestedInput
    user?: UserUpdateOneRequiredWithoutDraftPicksNestedInput
  }

  export type DraftPickUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftPickUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    draftId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    league?: LeagueUpdateOneRequiredWithoutTransactionsNestedInput
    team?: TeamUpdateOneRequiredWithoutTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    leagueId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    week?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameStatsUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    passingYards?: IntFieldUpdateOperationsInput | number
    passingTds?: IntFieldUpdateOperationsInput | number
    passingInts?: IntFieldUpdateOperationsInput | number
    passingAttempts?: IntFieldUpdateOperationsInput | number
    rushingYards?: IntFieldUpdateOperationsInput | number
    rushingTds?: IntFieldUpdateOperationsInput | number
    rushingAttempts?: IntFieldUpdateOperationsInput | number
    receptions?: IntFieldUpdateOperationsInput | number
    receivingYards?: IntFieldUpdateOperationsInput | number
    receivingTds?: IntFieldUpdateOperationsInput | number
    targets?: IntFieldUpdateOperationsInput | number
    fumbles?: IntFieldUpdateOperationsInput | number
    fumblesLost?: IntFieldUpdateOperationsInput | number
    fieldGoalsMade?: IntFieldUpdateOperationsInput | number
    fieldGoalsAttempted?: IntFieldUpdateOperationsInput | number
    extraPointsMade?: IntFieldUpdateOperationsInput | number
    extraPointsAttempted?: IntFieldUpdateOperationsInput | number
    sacks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interceptions?: IntFieldUpdateOperationsInput | number
    fumbleRecoveries?: IntFieldUpdateOperationsInput | number
    safeties?: IntFieldUpdateOperationsInput | number
    defensiveTds?: IntFieldUpdateOperationsInput | number
    pointsAllowed?: IntFieldUpdateOperationsInput | number
    fantasyPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameStatsUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    passingYards?: IntFieldUpdateOperationsInput | number
    passingTds?: IntFieldUpdateOperationsInput | number
    passingInts?: IntFieldUpdateOperationsInput | number
    passingAttempts?: IntFieldUpdateOperationsInput | number
    rushingYards?: IntFieldUpdateOperationsInput | number
    rushingTds?: IntFieldUpdateOperationsInput | number
    rushingAttempts?: IntFieldUpdateOperationsInput | number
    receptions?: IntFieldUpdateOperationsInput | number
    receivingYards?: IntFieldUpdateOperationsInput | number
    receivingTds?: IntFieldUpdateOperationsInput | number
    targets?: IntFieldUpdateOperationsInput | number
    fumbles?: IntFieldUpdateOperationsInput | number
    fumblesLost?: IntFieldUpdateOperationsInput | number
    fieldGoalsMade?: IntFieldUpdateOperationsInput | number
    fieldGoalsAttempted?: IntFieldUpdateOperationsInput | number
    extraPointsMade?: IntFieldUpdateOperationsInput | number
    extraPointsAttempted?: IntFieldUpdateOperationsInput | number
    sacks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interceptions?: IntFieldUpdateOperationsInput | number
    fumbleRecoveries?: IntFieldUpdateOperationsInput | number
    safeties?: IntFieldUpdateOperationsInput | number
    defensiveTds?: IntFieldUpdateOperationsInput | number
    pointsAllowed?: IntFieldUpdateOperationsInput | number
    fantasyPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameStatsUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    passingYards?: IntFieldUpdateOperationsInput | number
    passingTds?: IntFieldUpdateOperationsInput | number
    passingInts?: IntFieldUpdateOperationsInput | number
    passingAttempts?: IntFieldUpdateOperationsInput | number
    rushingYards?: IntFieldUpdateOperationsInput | number
    rushingTds?: IntFieldUpdateOperationsInput | number
    rushingAttempts?: IntFieldUpdateOperationsInput | number
    receptions?: IntFieldUpdateOperationsInput | number
    receivingYards?: IntFieldUpdateOperationsInput | number
    receivingTds?: IntFieldUpdateOperationsInput | number
    targets?: IntFieldUpdateOperationsInput | number
    fumbles?: IntFieldUpdateOperationsInput | number
    fumblesLost?: IntFieldUpdateOperationsInput | number
    fieldGoalsMade?: IntFieldUpdateOperationsInput | number
    fieldGoalsAttempted?: IntFieldUpdateOperationsInput | number
    extraPointsMade?: IntFieldUpdateOperationsInput | number
    extraPointsAttempted?: IntFieldUpdateOperationsInput | number
    sacks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    interceptions?: IntFieldUpdateOperationsInput | number
    fumbleRecoveries?: IntFieldUpdateOperationsInput | number
    safeties?: IntFieldUpdateOperationsInput | number
    defensiveTds?: IntFieldUpdateOperationsInput | number
    pointsAllowed?: IntFieldUpdateOperationsInput | number
    fantasyPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyProjectionUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    projectedPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projPassingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projPassingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projRushingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projRushingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceivingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceivingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyProjectionUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    projectedPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projPassingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projPassingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projRushingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projRushingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceivingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceivingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyProjectionUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    week?: IntFieldUpdateOperationsInput | number
    season?: IntFieldUpdateOperationsInput | number
    projectedPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projPassingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projPassingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projRushingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projRushingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceptions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceivingYards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    projReceivingTds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeOfferPlayerUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromTeam?: BoolFieldUpdateOperationsInput | boolean
    tradeOffer?: TradeOfferUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type TradeOfferPlayerUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeOfferId?: StringFieldUpdateOperationsInput | string
    fromTeam?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TradeOfferPlayerUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeOfferId?: StringFieldUpdateOperationsInput | string
    fromTeam?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DraftPickCreateManyDraftInput = {
    id?: string
    teamId: string
    userId: string
    playerId?: string | null
    round: number
    pick: number
    pickInRound: number
    pickTime?: Date | string | null
    isKeeper?: boolean
    createdAt?: Date | string
  }

  export type DraftPickUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutDraftPicksNestedInput
    user?: UserUpdateOneRequiredWithoutDraftPicksNestedInput
    player?: PlayerUpdateOneWithoutDraftPicksNestedInput
  }

  export type DraftPickUncheckedUpdateWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftPickUncheckedUpdateManyWithoutDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playerId?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    pick?: IntFieldUpdateOperationsInput | number
    pickInRound?: IntFieldUpdateOperationsInput | number
    pickTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isKeeper?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeOfferPlayerCreateManyTradeOfferInput = {
    id?: string
    playerId: string
    fromTeam: boolean
  }

  export type TradeOfferPlayerUpdateWithoutTradeOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromTeam?: BoolFieldUpdateOperationsInput | boolean
    player?: PlayerUpdateOneRequiredWithoutTradeOfferPlayersNestedInput
  }

  export type TradeOfferPlayerUncheckedUpdateWithoutTradeOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    fromTeam?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TradeOfferPlayerUncheckedUpdateManyWithoutTradeOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    fromTeam?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}